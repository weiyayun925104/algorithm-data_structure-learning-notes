// Source https://leetcode.com/problems/circle-and-rectangle-overlapping/

Given a circle represented as (radius, x_center, y_center) and an axis-aligned rectangle represented as (x1, y1, x2, y2), 
where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the rectangle.

Return True if the circle and rectangle are overlapped otherwise return False.

In other words, check if there are any point (xi, yi) such that belongs to the circle and the rectangle at the same time.

 

Example 1:



Input: radius = 1, x_center = 0, y_center = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1
Output: true
Explanation: Circle and rectangle share the point (1,0) 
Example 2:



Input: radius = 1, x_center = 0, y_center = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1
Output: true
Example 3:



Input: radius = 1, x_center = 1, y_center = 1, x1 = -3, y1 = -3, x2 = 3, y2 = 3
Output: true
Example 4:

Input: radius = 1, x_center = 1, y_center = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1
Output: false
 

Constraints:

1 <= radius <= 2000
-10^4 <= x_center, y_center, x1, y1, x2, y2 <= 10^4
x1 < x2
y1 < y2

class Solution
{
public:
    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2)
    {
        int xclose, yclose;
        if(x_center < x1) xclose = x1;
        else if(x_center > x2) xclose = x2;
        else xclose = x_center;

        if(y_center < y1) yclose = y1;
        else if(y_center > y2) yclose = y2;
        else yclose = y_center;

        return (x_center - xclose) * (x_center - xclose) + (y_center - yclose) * (y_center - yclose) <= radius * radius;
    }
};

// Source https://leetcode.com/problems/reducing-dishes/

A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time.

Like-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. time[i] * satisfaction[i].

Return the maximum sum of like-time coefficient that the chef can obtain after dishes preparation.

Dishes can be prepared in any order and the chef can discard some dishes to get this maximum value.

 

Example 1:

Input: satisfaction = [-1,-8,0,5,-9]
Output: 14
Explanation: After Removing the second and last dish, the maximum total like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14).
Each dish is prepared in one unit of time.
Example 2:

Input: satisfaction = [4,3,2]
Output: 20
Explanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)
Example 3:

Input: satisfaction = [-1,-4,-5]
Output: 0
Explanation: People don't like the dishes. No dish is prepared.
Example 4:

Input: satisfaction = [-2,5,-1,0,3,-3]
Output: 35
 

Constraints:

n == satisfaction.length
1 <= n <= 500
-1000 <= satisfaction[i] <= 1000

class Solution
{
public:
    int maxSatisfaction(vector<int> &satisfaction)
    {
        vector<int> pos;
        vector<int> neg;

        for(auto x : satisfaction)
        {
            if(x < 0)
            {
                neg.push_back(x);
            }
            else
            {
                pos.push_back(x);
            }
        }

        sort(neg.begin(), neg.end(), greater<int>());
        sort(pos.begin(), pos.end());

        int curr = 0, score = 0;

        for(int i = 0; i < pos.size(); i++)
        {
            curr += pos[i];
            score += (i + 1) * pos[i];
        }

        for(int i = 0; i < neg.size(); i++)
        {
            if(neg[i] + curr > 0)
            {
                score += (neg[i] + curr);
                curr += neg[i];
            }
            else
            {
                break;
            }
        }

        return score;
    }
};

// Source https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/

Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. 

If there are multiple solutions, return the subsequence with minimum size 
and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. 
A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. 

Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.

 

Example 1:

Input: nums = [4,3,10,9,8]
Output: [10,9] 
Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included, 
however, the subsequence [10,9] has the maximum total sum of its elements. 
Example 2:

Input: nums = [4,4,7,6,7]
Output: [7,7,6] 
Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to returned in non-decreasing order.  
Example 3:

Input: nums = [6]
Output: [6]
 

Constraints:

1 <= nums.length <= 500
1 <= nums[i] <= 100

class Solution
{
public:
    vector<int> minSubsequence(vector<int> &nums)
    {
        if(nums.size() == 1)
            return  nums;
        int sum = 0, res = 0;
        vector<int> v;
        for(int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
        }
        sort(nums.begin(), nums.end());
        for(int i = nums.size() - 1; i >= 0; i--)
        {
            res += nums[i];
            if(res > (sum - res))
            {
                v.push_back(nums[i]);
                return v;
            }
            else
            {
                v.push_back(nums[i]);
            }
        }
        return {};
    }
};

// Source https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/

Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:

If the current number is even, you have to divide it by 2.

If the current number is odd, you have to add 1 to it.

It is guaranteed that you can always reach one for all test cases.

 

Example 1:

Input: s = "1101"
Output: 6
Explanation: "1101" corressponds to number 13 in their decimal representation.
Step 1) 13 is odd, add 1 and obtain 14. 
Step 2) 14 is even, divide by 2 and obtain 7.
Step 3) 7 is odd, add 1 and obtain 8.
Step 4) 8 is even, divide by 2 and obtain 4.  
Step 5) 4 is even, divide by 2 and obtain 2. 
Step 6) 2 is even, divide by 2 and obtain 1.  
Example 2:

Input: s = "10"
Output: 1
Explanation: "10" corressponds to number 2 in their decimal representation.
Step 1) 2 is even, divide by 2 and obtain 1.  
Example 3:

Input: s = "1"
Output: 0
 

Constraints:

1 <= s.length <= 500
s consists of characters '0' or '1'
s[0] == '1'

class Solution
{
public:
    int numSteps(string s)
    {
        bitset<501> num(s);
        int count = 0;
        while(num != 1)
        {
            if(num[0] == 0)
                num = num >> 1;
            else
            {
                for(int i = 0; i < 501; i++)
                {
                    if(num[i] == 0)
                    {
                        num[i] = 1;
                        break;
                    }
                    else
                        num[i] = 0;
                }
            }
            count++;
        }
        return count;
    }
};

// Source https://leetcode.com/problems/stone-game-iii/

Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value 
which is an integer given in the array stoneValue.

Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2 or 3 stones from the first remaining stones in the row.

The score of each player is the sum of values of the stones taken. The score of each player is 0 initially.

The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. 
The game continues until all the stones have been taken.

Assume Alice and Bob play optimally.

Return "Alice" if Alice will win, "Bob" if Bob will win or "Tie" if they end the game with the same score.

 

Example 1:

Input: values = [1,2,3,7]
Output: "Bob"
Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.
Example 2:

Input: values = [1,2,3,-9]
Output: "Alice"
Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.
If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. The next move Alice will take the pile with value = -9 and lose.
If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. The next move Alice will take the pile with value = -9 and also lose.
Remember that both play optimally so here Alice will choose the scenario that makes her win.
Example 3:

Input: values = [1,2,3,6]
Output: "Tie"
Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.
Example 4:

Input: values = [1,2,3,-1,-2,-3,7]
Output: "Alice"
Example 5:

Input: values = [-1,-2,-3]
Output: "Tie"
 

Constraints:

1 <= values.length <= 50000
-1000 <= values[i] <= 1000

dp[i] 表示剩余s[i] ... s[n-1]，Alice,Bob可以得到的分数差最大值

class Solution
{
public:
    int helper(vector<int> &s, int i, vector<int> &dp )
    {
        if(i >= s.size())
            return 0;

        if(dp[i] != -1)
            return dp[i];

        int ans = INT_MIN;
        ans = max(ans, s[i] - helper(s, i + 1, dp));

        if(i + 1 < s.size())
            ans = max(ans, s[i] + s[i + 1] - helper(s, i + 2, dp));

        if(i + 2 < s.size())
            ans = max(ans, s[i] + s[i + 1] + s[i + 2] - helper(s, i + 3, dp));

        dp[i] = ans;
        return ans;
    }

    string stoneGameIII(vector<int> &s)
    {
        int n = s.size();
        vector<int> dp(n, -1);
        int ans = helper(s, 0, dp);

        if(ans > 0)
            return "Alice";
        if(ans == 0) return "Tie";
        return "Bob";
    }
};

// Source https://leetcode.com/problems/string-matching-in-an-array/

Given an array of string words. Return all strings in words which is substring of another word in any order. 

String words[i] is substring of words[j], if can be obtained removing some characters to left and/or right side of words[j].

 

Example 1:

Input: words = ["mass","as","hero","superhero"]
Output: ["as","hero"]
Explanation: "as" is substring of "mass" and "hero" is substring of "superhero".
["hero","as"] is also a valid answer.
Example 2:

Input: words = ["leetcode","et","code"]
Output: ["et","code"]
Explanation: "et", "code" are substring of "leetcode".
Example 3:

Input: words = ["blue","green","bu"]
Output: []
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 30
words[i] contains only lowercase English letters.
It's guaranteed that words[i] will be unique.

class Solution
{
public:
    vector<string> stringMatching(vector<string> &words)
    {
        sort(words.begin(), words.end(), [] (string & a, string & b)
        {
            return a.size() < b.size();
        });

        vector<string> res;

        for(int i = 0; i < words.size(); i++)
        {
            for(int j = i + 1; j < words.size(); j++)
            {
                if(words[j].find(words[i]) != string::npos)
                {
                    res.push_back(words[i]);
                    break;
                }
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/queries-on-a-permutation-with-key/

Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:

In the beginning, you have the permutation P=[1,2,3,...,m].
For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. 
Notice that the position of queries[i] in P is the result for queries[i].
Return an array containing the result for the given queries.

 

Example 1:

Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 
Explanation: The queries are processed as follow: 
For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
Therefore, the array containing the result is [2,1,2,1].  
Example 2:

Input: queries = [4,1,2,2], m = 4
Output: [3,1,2,0]
Example 3:

Input: queries = [7,5,5,8,3], m = 8
Output: [6,5,0,7,5]
 

Constraints:

1 <= m <= 10^3
1 <= queries.length <= m
1 <= queries[i] <= m

class Solution
{
public:
    vector<int> processQueries(vector<int> &queries, int m)
    {
        vector<int> p, ans;
        for(int i = 1; i <= m; i++)
        {
            p.push_back(i);
        }
        for(int i = 0; i < queries.size(); i++)
        {
            auto it = find(p.begin(), p.end(), queries[i]);
            ans.push_back(it - p.begin());
            p.erase(it);
            p.insert(p.begin(), queries[i]);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/html-entity-parser/

HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself.

The special characters and their entities for HTML are:

Quotation Mark: the entity is &quot; and symbol character is ".
Single Quote Mark: the entity is &apos; and symbol character is '.
Ampersand: the entity is &amp; and symbol character is &.
Greater Than Sign: the entity is &gt; and symbol character is >.
Less Than Sign: the entity is &lt; and symbol character is <.
Slash: the entity is &frasl; and symbol character is /.
Given the input text string to the HTML parser, you have to implement the entity parser.

Return the text after replacing the entities by the special characters.

 

Example 1:

Input: text = "&amp; is an HTML entity but &ambassador; is not."
Output: "& is an HTML entity but &ambassador; is not."
Explanation: The parser will replace the &amp; entity by &
Example 2:

Input: text = "and I quote: &quot;...&quot;"
Output: "and I quote: \"...\""
Example 3:

Input: text = "Stay home! Practice on Leetcode :)"
Output: "Stay home! Practice on Leetcode :)"
Example 4:

Input: text = "x &gt; y &amp;&amp; x &lt; y is always false"
Output: "x > y && x < y is always false"
Example 5:

Input: text = "leetcode.com&frasl;problemset&frasl;all"
Output: "leetcode.com/problemset/all"
 

Constraints:

1 <= text.length <= 10^5
The string may contain any possible characters out of all the 256 ASCII characters.

class Solution
{
public:
    string entityParser(string text)
    {
        string result = "";
        unordered_map<string, string> html ({{"&quot;", "\""},
            {"&apos;", "\'"},
            {"&amp;", "&"},
            {"&gt;", ">"},
            {"&lt;", "<"},
            {"&frasl;", "/"}});
        for(int i = 0; i < text.size(); i++)
        {
            if(text[i] == '&')
            {
                bool found_match = false;
                for(int k = 4; i + k <= text.size() && k <= 7; k++)
                {
                    string extra = text.substr(i, k);
                    if(html.count(extra))
                    {
                        result += html[extra];
                        i += k - 1;
                        found_match = true;
                        break;
                    }
                }
                if(!found_match)
                {
                    result += text[i];
                }
            }
            else
            {
                result += text[i];
            }
        }
        return result;
    }
};

// Source https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/

You have a grid of size n x 3 and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green 
while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).

Given n the number of rows of the grid, return the number of ways you can paint this grid. 
As the answer may grow large, the answer must be computed modulo 109 + 7.

 

Example 1:


Input: n = 1
Output: 12
Explanation: There are 12 possible way to paint the grid as shown.
Example 2:

Input: n = 2
Output: 54
Example 3:

Input: n = 3
Output: 246
Example 4:

Input: n = 7
Output: 106494
Example 5:

Input: n = 5000
Output: 30228214
 

Constraints:

n == grid.length
grid[i].length == 3
1 <= n <= 5000

当前行	当前行
ABA	ABC
下一行	下一行
BAB	BAB
BCB	BCB
CAC	BCA
BAC	CAB
CAB	

1个ABA 可以产生 3个ABA (BAB，BCB，CAC) + 2个ABC (BAC，CAB)
1个ABC 可以产生 2个ABA (BAB，BCB)+ 2个ABC(BCA，CAB)

考虑第一行，则ABA有3 * 2 = 6种，ABC有3 * 2 = 6种
考虑第二行，则ABA有3 * 6 + 2 * 6 = 30，ABC有2 * 6 + 2 * 6 = 24
考虑第三行，则ABA有3 * 30 + 2 * 24 = 138，ABC有2 * 30 + 2 * 24 = 108

class Solution
{
public:
    int numOfWays(int n)
    {
        long aba = 6, abc = 6, aba_t, abc_t, mod = 1e9 + 7;
        for(int i = 1; i < n; ++i)
        {
            aba_t = (3 * aba + 2 * abc) % mod;
            abc_t = (2 * (aba + abc)) % mod;
            aba = aba_t;
            abc = abc_t;
        }
        return (aba + abc) % mod;
    }
};

// Source https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/

Given an array of integers nums, you start with an initial positive value startValue.

In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right).

Return the minimum positive value of startValue such that the step by step sum is never less than 1.

 

Example 1:

Input: nums = [-3,2,-3,4,2]
Output: 5
Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.
step by step sum
startValue = 4 | startValue = 5 | nums
  (4 -3 ) = 1  | (5 -3 ) = 2    |  -3
  (1 +2 ) = 3  | (2 +2 ) = 4    |   2
  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3
  (0 +4 ) = 4  | (1 +4 ) = 5    |   4
  (4 +2 ) = 6  | (5 +2 ) = 7    |   2
Example 2:

Input: nums = [1,2]
Output: 1
Explanation: Minimum start value should be positive. 
Example 3:

Input: nums = [1,-2,-3]
Output: 5
 

Constraints:

1 <= nums.length <= 100
-100 <= nums[i] <= 100

class Solution
{
public:
    int minStartValue(vector<int> &nums)
    {
        int temp = INT_MAX;
        int sum = 0;
        for(auto ele : nums)
        {
            sum += ele;
            temp = min(temp, sum);
        }
        if(temp >= 1)
        {
            return 1;
        }
        return abs(temp) + 1;
    }
};

// Source https://leetcode.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/

Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k. The same Fibonacci number can be used multiple times.

The Fibonacci numbers are defined as:

F1 = 1
F2 = 1
Fn = Fn-1 + Fn-2 for n > 2.
It is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to k.
 

Example 1:

Input: k = 7
Output: 2 
Explanation: The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... 
For k = 7 we can use 2 + 5 = 7.
Example 2:

Input: k = 10
Output: 2 
Explanation: For k = 10 we can use 2 + 8 = 10.
Example 3:

Input: k = 19
Output: 3 
Explanation: For k = 19 we can use 1 + 5 + 13 = 19.
 

Constraints:

1 <= k <= 109

class Solution
{
public:
    vector<int> fib;

    void fill_fib(int n)
    {
        fib.push_back(1);
        fib.push_back(1);
        int i = 2;
        while(true)
        {
            fib.push_back(fib[i - 1] + fib[i - 2]);
            i += 1;
            if (fib.back() > n) break;
        }
        fib.pop_back();
    }

    int findMinFibonacciNumbers(int k)
    {
        fill_fib(k);
        int ans = 0;
        int i = fib.size() - 1;
        if(fib[i] == k) return 1;

        while(k > 0)
        {
            k = k - fib[i];
            ans += 1;
            while(fib[i] > k && i > 0)
            {
                i--;
            }
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/

A happy string is a string that:

consists only of letters of the set ['a', 'b', 'c'].
s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).
For example, strings "abc", "ac", "b" and "abcbabcbcb" are all happy strings and strings "aa", "baa" and "ababbc" are not happy strings.

Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.

Return the kth string of this list or return an empty string if there are less than k happy strings of length n.

 

Example 1:

Input: n = 1, k = 3
Output: "c"
Explanation: The list ["a", "b", "c"] contains all happy strings of length 1. The third string is "c".
Example 2:

Input: n = 1, k = 4
Output: ""
Explanation: There are only 3 happy strings of length 1.
Example 3:

Input: n = 3, k = 9
Output: "cab"
Explanation: There are 12 different happy string of length 3 ["aba", "abc", "aca", "acb", "bab", "bac", "bca", "bcb", "cab", "cac", "cba", "cbc"]. You will find the 9th string = "cab"
Example 4:

Input: n = 2, k = 7
Output: ""
Example 5:

Input: n = 10, k = 100
Output: "abacbabacb"
 

Constraints:

1 <= n <= 10
1 <= k <= 100

class Solution
{
public:
    string ans;

    void solve(int n, int &k, string asf)
    {
        if(k <= 0)
            return;

        if(asf.size() == n)
        {
            k--;
            if(k == 0)
                ans = asf;
            return ;
        }

        if(asf.size() == 0)
        {
            solve(n, k, asf + 'a');
            solve(n, k, asf + 'b');
            solve(n, k, asf + 'c');
        }
        else
        {
            int m = asf.size();

            if('a' != asf[m - 1])
            {
                solve(n, k, asf + 'a');
            }

            if('b' != asf[m - 1])
            {
                solve(n, k, asf + 'b');
            }

            if('c' != asf[m - 1])
            {
                solve(n, k, asf + 'c');
            }
        }
    }

    string getHappyString(int n, int k)
    {
        solve(n, k, "");
        return ans;
    }
};


// Source https://leetcode.com/problems/restore-the-array/

A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s 
and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.

Given the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. 
Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:

Input: s = "1000", k = 10000
Output: 1
Explanation: The only possible array is [1000]
Example 2:

Input: s = "1000", k = 10
Output: 0
Explanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.
Example 3:

Input: s = "1317", k = 2000
Output: 8
Explanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]
Example 4:

Input: s = "2020", k = 30
Output: 1
Explanation: The only possible array is [20,20]. [2020] is invalid because 2020 > 30. [2,020] is ivalid because 020 contains leading zeros.
Example 5:

Input: s = "1234567890", k = 90
Output: 34
 

Constraints:

1 <= s.length <= 105
s consists of only digits and does not contain leading zeros.
1 <= k <= 109

dp[i] 表示s[i] ... s[n-1]可行的划分方案数量

class Solution
{
public:
    int mod = 1000000007;
    int solver(string &s, int k, int i, int n, vector<int> &dp)
    {
        if(i == n)
            return 1;

        if(s[i] == '0')
            return 0;

        if(dp[i] != -1)
            return dp[i];

        long int nums = 0, ans = 0;
        for(int j = i; (nums * 10 + (s[j] - '0')) <= k && j < n; j++)
        {
            nums = nums * 10 + (s[j] - '0');
            ans = (ans + solver(s, k, j + 1, n, dp)) % mod;
        }
        return dp[i] = ans % mod;
    }
    int numberOfArrays(string s, int k)
    {
        int n = s.length();
        vector<int>dp(n + 1, -1);
        return solver(s, k, 0, n, dp);
    }
};


// Source https://leetcode.com/problems/reformat-the-string/

Given alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).

You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. 
That is, no two adjacent characters have the same type.

Return the reformatted string or return an empty string if it is impossible to reformat the string.

 

Example 1:

Input: s = "a0b1c2"
Output: "0a1b2c"
Explanation: No two adjacent characters have the same type in "0a1b2c". "a0b1c2", "0a1b2c", "0c2a1b" are also valid permutations.
Example 2:

Input: s = "leetcode"
Output: ""
Explanation: "leetcode" has only characters so we cannot separate them by digits.
Example 3:

Input: s = "1229857369"
Output: ""
Explanation: "1229857369" has only digits so we cannot separate them by characters.
Example 4:

Input: s = "covid2019"
Output: "c2o0v1i9d"
Example 5:

Input: s = "ab123"
Output: "1a2b3"
 

Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters and/or digits.

class Solution
{
public:
    string reformat(string s)
    {
        string str = "";
        int digit = 0, letter = 0;
        vector<char> d;
        vector<char> l;
        for(int i = 0; i < s.size(); i++)
        {
            if(isdigit(s[i]))
            {
                digit++;
                d.push_back(s[i]);
            }
            else
            {
                letter++;
                l.push_back(s[i]);
            }
        }
        if(abs(digit - letter) > 1)
            return "";
        if(digit >= letter)
        {
            int i = 0, j = 0;
            while(i < d.size() && i < l.size())
            {
                str += d[i];
                str += l[i];
                i++;
            }
            if(i != d.size())
                str += d[i];
        }
        else
        {
            int i = 0, j = 0;
            while(i < d.size() && i < l.size())
            {
                str += l[i];
                str += d[i];
                i++;
            }
            str += l[i];
        }
        return str;
    }
};


// Source https://leetcode.com/problems/display-table-of-food-orders-in-a-restaurant/

Given the array orders, which represents the orders that customers have done in a restaurant. 
More specifically orders[i]=[customerNamei,tableNumberi,foodItemi] 
where customerNamei is the name of the customer, tableNumberi is the table customer sit at, and foodItemi is the item customer orders.

Return the restaurant's “display table”. The “display table” is a table whose row entries denote how many of each food item each table ordered. 
The first column is the table number and the remaining columns correspond to each food item in alphabetical order. 
The first row should be a header whose first column is “Table”, followed by the names of the food items. 
Note that the customer names are not part of the table. Additionally, the rows should be sorted in numerically increasing order.

 

Example 1:

Input: orders = [["David","3","Ceviche"],["Corina","10","Beef Burrito"],["David","3","Fried Chicken"],["Carla","5","Water"],["Carla","5","Ceviche"],["Rous","3","Ceviche"]]
Output: [["Table","Beef Burrito","Ceviche","Fried Chicken","Water"],["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]] 
Explanation:
The displaying table looks like:
Table,Beef Burrito,Ceviche,Fried Chicken,Water
3    ,0           ,2      ,1            ,0
5    ,0           ,1      ,0            ,1
10   ,1           ,0      ,0            ,0
For the table 3: David orders "Ceviche" and "Fried Chicken", and Rous orders "Ceviche".
For the table 5: Carla orders "Water" and "Ceviche".
For the table 10: Corina orders "Beef Burrito". 
Example 2:

Input: orders = [["James","12","Fried Chicken"],["Ratesh","12","Fried Chicken"],["Amadeus","12","Fried Chicken"],["Adam","1","Canadian Waffles"],["Brianna","1","Canadian Waffles"]]
Output: [["Table","Canadian Waffles","Fried Chicken"],["1","2","0"],["12","0","3"]] 
Explanation: 
For the table 1: Adam and Brianna order "Canadian Waffles".
For the table 12: James, Ratesh and Amadeus order "Fried Chicken".
Example 3:

Input: orders = [["Laura","2","Bean Burrito"],["Jhon","2","Beef Burrito"],["Melissa","2","Soda"]]
Output: [["Table","Bean Burrito","Beef Burrito","Soda"],["2","1","1","1"]]
 

Constraints:

1 <= orders.length <= 5 * 10^4
orders[i].length == 3
1 <= customerNamei.length, foodItemi.length <= 20
customerNamei and foodItemi consist of lowercase and uppercase English letters and the space character.
tableNumberi is a valid integer between 1 and 500.

class Solution
{
public:
    struct comp
    {
        constexpr bool operator()( string const &a, string const &b) const noexcept
        {
            return a.size() < b.size() ? true : a.size() > b.size() ? false : a < b;
        }
    };

    vector<vector<string>> displayTable(vector<vector<string>> &orders)
    {
        set<string> dishes;
        map<string, unordered_map<string, int>, comp>table;

        for(auto &it : orders)
        {
            dishes.insert(it[2]);
            table[it[1]][it[2]]++;
        }

        orders.clear();
        orders.push_back({"Table"});
        for(auto &d : dishes) orders[0].push_back(d);

        for(auto &it : table)
        {
            orders.push_back({it.first});
            for(auto &d : dishes)
                if(it.second.count(d)) orders.back().push_back(to_string(it.second[d]));
                else orders.back().push_back("0");
        }

        return orders;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-frogs-croaking/

You are given the string croakOfFrogs, which represents a combination of the string "croak" from different frogs, 
that is, multiple frogs can croak at the same time, so multiple "croak" are mixed.

Return the minimum number of different frogs to finish all the croaks in the given string.

A valid "croak" means a frog is printing five letters 'c', 'r', 'o', 'a', and 'k' sequentially. 
The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid "croak" return -1.

 

Example 1:

Input: croakOfFrogs = "croakcroak"
Output: 1 
Explanation: One frog yelling "croak" twice.
Example 2:

Input: croakOfFrogs = "crcoakroak"
Output: 2 
Explanation: The minimum number of frogs is two. 
The first frog could yell "crcoakroak".
The second frog could yell later "crcoakroak".
Example 3:

Input: croakOfFrogs = "croakcrook"
Output: -1
Explanation: The given string is an invalid combination of "croak" from different frogs.
 

Constraints:

1 <= croakOfFrogs.length <= 105
croakOfFrogs is either 'c', 'r', 'o', 'a', or 'k'.

class Solution {
public:
    int minNumberOfFrogs(string A) {
        vector<int> count(5,0);

        for(int i = 0; i < A.length(); ++i) {
            switch(A[i]) {
                case 'c': count[0]++; if (count[4] != 0) count[4]--; break;
                case 'r': if (count[0] <= 0) return -1; count[1]++; count[0]--; break;
                case 'o': if (count[1] <= 0) return -1; count[2]++; count[1]--; break;
                case 'a': if (count[2] <= 0) return -1; count[3]++; count[2]--; break;
                case 'k': if (count[3] <= 0) return -1; count[4]++; count[3]--; break;
                default : return -1;
            }
        }
        for (int i = 0; i < count.size() - 1; ++i) {
            if (count[i] != 0) return -1;
        }
        return count[4];
    }
};


// Source https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/

Given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:
maximum_value = -1;
maximum_index = -1;
search_cost = 0;
n = arr.length;
for (i = 0; i < n; i++)
{
    if (maximum_value < arr[i])
    {
        maximum_value = arr[i];
        maximum_index = i;
        search_cost = search_cost + 1;
    }
}
return maximum_index;

You should build the array arr which has the following properties:

arr has exactly n integers.
1 <= arr[i] <= m where (0 <= i < n).
After applying the mentioned algorithm to arr, the value search_cost is equal to k.
Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 10^9 + 7.

 

Example 1:

Input: n = 2, m = 3, k = 1
Output: 6
Explanation: The possible arrays are [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3]
Example 2:

Input: n = 5, m = 2, k = 3
Output: 0
Explanation: There are no possible arrays that satisify the mentioned conditions.
Example 3:

Input: n = 9, m = 1, k = 1
Output: 1
Explanation: The only possible array is [1, 1, 1, 1, 1, 1, 1, 1, 1]
Example 4:

Input: n = 50, m = 100, k = 25
Output: 34549172
Explanation: Don't forget to compute the answer modulo 1000000007
Example 5:

Input: n = 37, m = 17, k = 7
Output: 418930126
 

Constraints:

1 <= n <= 50
1 <= m <= 100
0 <= k <= n

ways[i][j][k]表示满足数组长度为i，最大元素为j， cost为k，the number of ways to build the array
初始化ways[1][j][1] = 1
ways[i][j][k] = j * ways[i-1][j][k]
ways[i][j][k] += ∑(x = 1 to x = j - 1) ways[i-1][x][k-1]
最后将∑(x = 1 to x = m) ways[n][x][k] 取余即可

class Solution
{
    long long ways[55][105][55];
    const int mod = 1000000007;
public:
    int numOfArrays(int n, int m, int num)
    {
        memset(ways, 0, sizeof(ways));

        for (int j = 1; j <= m; ++j) ways[1][j][1] = 1;
        for (int i = 2; i <= n; ++i)
        {
            for (int j = 1; j <= m; ++j)
            {
                for (int k = 1; k <= num; ++k)
                {
                    long long s = 0;
                    s = (j * ways[i - 1][j][k]) % mod;
                    for (int p = 1; p < j; ++p)
                        s = (s + ways[i - 1][p][k - 1]) % mod;
                    ways[i][j][k] = (s + ways[i][j][k]) % mod;
                }
            }
        }
        long long ans = 0;
        for (int j = 1; j <= m; ++j)
        {
            ans = (ans + ways[n][j][num]) % mod;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/maximum-score-after-splitting-a-string/

Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).

The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.

 

Example 1:

Input: s = "011101"
Output: 5 
Explanation: 
All possible ways of splitting s into two non-empty substrings are:
left = "0" and right = "11101", score = 1 + 4 = 5 
left = "01" and right = "1101", score = 1 + 3 = 4 
left = "011" and right = "101", score = 1 + 2 = 3 
left = "0111" and right = "01", score = 1 + 1 = 2 
left = "01110" and right = "1", score = 2 + 1 = 3
Example 2:

Input: s = "00111"
Output: 5
Explanation: When left = "00" and right = "111", we get the maximum score = 2 + 3 = 5
Example 3:

Input: s = "1111"
Output: 3
 

Constraints:

2 <= s.length <= 500
The string s consists of characters '0' and '1' only.

class Solution
{
public:
    int maxScore(string s)
    {
        int zero = 0, one = 0, sum = 0;
        if(s[0] == '0')
            zero++;
        for(int i = 1; i < s.size(); i++)
        {
            if(s[i] == '1')
                one++;
        }
        sum = zero + one;
        for(int i = 1; i < s.size() - 1; i++)
        {
            if(s[i] == '1')
                one--;
            else
            {
                zero++;
            }
            sum = max(sum, (one + zero));
        }
        return sum;
    }
};


// Source https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/

There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.

In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.

Your score is the sum of the points of the cards you have taken.

Given the integer array cardPoints and the integer k, return the maximum score you can obtain.

 

Example 1:

Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12
Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.
Example 2:

Input: cardPoints = [2,2,2], k = 2
Output: 4
Explanation: Regardless of which two cards you take, your score will always be 4.
Example 3:

Input: cardPoints = [9,7,7,9,7,7,9], k = 7
Output: 55
Explanation: You have to take all the cards. Your score is the sum of points of all cards.
Example 4:

Input: cardPoints = [1,1000,1], k = 1
Output: 1
Explanation: You cannot take the card in the middle. Your best score is 1. 
Example 5:

Input: cardPoints = [1,79,80,1,1,1,200,1], k = 3
Output: 202
 

Constraints:

1 <= cardPoints.length <= 105
1 <= cardPoints[i] <= 104
1 <= k <= cardPoints.length

Input: cardPoints = [1,2,3,4,5,6,1], k = 3
Output: 12

1 2 3

1 6 5

1 2 1
1 1 2
1 1 2

1 6 1
1 1 6
1 1 6
总共4种组合
前3个
后3个
前2个 + 后1个
前1个 + 后2个


class Solution
{
public:

    int maxScore(vector<int> &cardPoints, int k)
    {
        int n = cardPoints.size();
        int pre[n];
        pre[0] = cardPoints[0];
        for(int i = 1; i < n; i++)
        {
            pre[i] = pre[i - 1] + cardPoints[i];
        }
        int suf[n];
        suf[n - 1] = cardPoints[n - 1];
        for(int i = n - 2; i >= 0; i--)
        {
            suf[i] = suf[i + 1] + cardPoints[i];
        }
        int res = 0;
        for(int i = 1; i < k; i++)
        {
            int sum = pre[i - 1] + suf[n - k + i];
            res = max(res, sum);
        }
        res = max({res, pre[k - 1], suf[n - k]});
        return res;
    }
};

// Source https://leetcode.com/problems/diagonal-traverse-ii/

Given a list of lists of integers, nums, return all elements of nums in diagonal order as shown in the below images.
 

Example 1:



Input: nums = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,4,2,7,5,3,8,6,9]
Example 2:



Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
Example 3:

Input: nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
Output: [1,4,2,5,3,8,6,9,7,10,11]
Example 4:

Input: nums = [[1,2,3,4,5,6]]
Output: [1,2,3,4,5,6]
 

Constraints:

1 <= nums.length <= 10^5
1 <= nums[i].length <= 10^5
1 <= nums[i][j] <= 10^9
There at most 10^5 elements in nums.

class Solution
{
public:
    vector<int> findDiagonalOrder(vector<vector<int>> &nums)
    {
        queue<pair<int, int>> q;
        q.push({0, 0});
        vector<int> res;
        while(!q.empty())
        {
            auto p = q.front();
            q.pop();
            res.push_back(nums[p.first][p.second]);
            if(p.first < nums.size() - 1 && p.second == 0)
            {
                q.push({p.first + 1, p.second});
            }
            if(p.second < nums[p.first].size() - 1)
            {
                q.push({p.first, p.second + 1});
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/constrained-subsequence-sum/

Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array 
such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.

A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.

 

Example 1:

Input: nums = [10,2,-10,5,20], k = 2
Output: 37
Explanation: The subsequence is [10, 2, 5, 20].
Example 2:

Input: nums = [-1,-2,-3], k = 1
Output: -1
Explanation: The subsequence must be non-empty, so we choose the largest number.
Example 3:

Input: nums = [10,-2,-10,-5,20], k = 2
Output: 23
Explanation: The subsequence is [10, -2, -5, 20].
 

Constraints:

1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104

dp[i] 表示the maximum sum of a non-empty subsequence（以num[i]为最后一个元素）

class Solution
{
public:
    int constrainedSubsetSum(vector<int> &nums, int k)
    {
        int n = nums.size();
        int ans = -10000;
        int dp[n];

        for(int i = 0; i < n; i++)
        {
            dp[i] = nums[i];
            ans = max(ans, dp[i]);
        }
        priority_queue<pair<int, int>> pq;
        pq.push(make_pair(nums[0], 0));
        for(int i = 1; i < n; i++)
        {
            while(i - pq.top().second > k)
            {
                pq.pop();
            }
            dp[i] = max(dp[i], nums[i] + pq.top().first);
            pq.push(make_pair(dp[i], i));
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/

There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, 
denoting the number of extra candies that you have.

Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, 
they will have the greatest number of candies among all the kids, or false otherwise.

Note that multiple kids can have the greatest number of candies.

 

Example 1:

Input: candies = [2,3,5,1,3], extraCandies = 3
Output: [true,true,true,false,true] 
Explanation: If you give all extraCandies to:
- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.
- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.
- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.
- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
Example 2:

Input: candies = [4,2,1,1,2], extraCandies = 1
Output: [true,false,false,false,false] 
Explanation: There is only 1 extra candy.
Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.
Example 3:

Input: candies = [12,1,12], extraCandies = 10
Output: [true,false,true]
 

Constraints:

n == candies.length
2 <= n <= 100
1 <= candies[i] <= 100
1 <= extraCandies <= 50

class Solution {
public:
    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) 
    {
        int max=candies[0];
        for(int i=1;i<candies.size();i++)
        {
            if(candies[i]>max)
                max=candies[i];
        }
        vector<bool>v;
        for(int i=0;i<candies.size();i++)
        {
            if(candies[i]+extraCandies>=max)
                v.push_back(true);
            else
                v.push_back(false);
        }
        return v;
    }
};

// Source https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/

You are given an integer num. You will apply the following steps exactly two times:

Pick a digit x (0 <= x <= 9).
Pick another digit y (0 <= y <= 9). The digit y can be equal to x.
Replace all the occurrences of x in the decimal representation of num by y.
The new integer cannot have any leading zeros, also the new integer cannot be 0.
Let a and b be the results of applying the operations to num the first and second times, respectively.

Return the max difference between a and b.

 

Example 1:

Input: num = 555
Output: 888
Explanation: The first time pick x = 5 and y = 9 and store the new integer in a.
The second time pick x = 5 and y = 1 and store the new integer in b.
We have now a = 999 and b = 111 and max difference = 888
Example 2:

Input: num = 9
Output: 8
Explanation: The first time pick x = 9 and y = 9 and store the new integer in a.
The second time pick x = 9 and y = 1 and store the new integer in b.
We have now a = 9 and b = 1 and max difference = 8
Example 3:

Input: num = 123456
Output: 820000
Example 4:

Input: num = 10000
Output: 80000
Example 5:

Input: num = 9288
Output: 8700
 

Constraints:

1 <= num <= 10^8

class Solution
{
public:
    //a-b=max when a=maximum possible num, b=Minum possible num
    int maxDiff(int num)
    {
        if(num / 10 == 0)
            return (9 - 1);
        string str = to_string(num);
        int n = str.length();
        string a = str;
        string b = str;
        for(int i = 0; i < n; i++)
        {
            if(str[i] != '9')
            {
                replace(a.begin(), a.end(), str[i], '9');
                break;
            }
        }
        for(int i = 0; i < n; i++)
        {
            if(i == 0 && str[i] != '1')
            {
                replace(b.begin(), b.end(), str[i], '1');

                break;
            }
            else if(i != 0 && str[i] != '0' && str[0] != str[i])
            {
                replace(b.begin(), b.end(), str[i], '0');

                break;
            }
        }

        return (stoi(a) - stoi(b));
    }
};

// Source https://leetcode.com/problems/check-if-a-string-can-break-another-string/

Given two strings: s1 and s2 with the same size, check if some permutation of string s1 can break some permutation of string s2 or vice-versa. 
In other words s2 can break s1 or vice-versa.

A string x can break string y (both of size n) if x[i] >= y[i] (in alphabetical order) for all i between 0 and n-1.

 

Example 1:

Input: s1 = "abc", s2 = "xya"
Output: true
Explanation: "ayx" is a permutation of s2="xya" which can break to string "abc" which is a permutation of s1="abc".
Example 2:

Input: s1 = "abe", s2 = "acd"
Output: false 
Explanation: All permutations for s1="abe" are: "abe", "aeb", "bae", "bea", "eab" and "eba" and all permutation for s2="acd" are: "acd", "adc", "cad", "cda", "dac" and "dca". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa.
Example 3:

Input: s1 = "leetcodee", s2 = "interview"
Output: true
 

Constraints:

s1.length == n
s2.length == n
1 <= n <= 10^5
All strings consist of lowercase English letters.

class Solution
{
public:
    bool checkIfCanBreak(string a, string b)
    {
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        int i;

        for (i = 0; i < a.length(); i++)
        {
            if (a[i] < b[i])
                break;
        }
        if (i < a.length())
        {
            for (i = 0; i < a.length(); i++)
            {
                if (b[i] < a[i])
                    break;
            }
            if (i < a.length())
            {
                return  false;
            }
        }
        return true;
    }
};

// Source https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/

There are n people and 40 types of hats labeled from 1 to 40.

Given a list of list of integers hats, where hats[i] is a list of all hats preferred by the i-th person.

Return the number of ways that the n people wear different hats to each other.

Since the answer may be too large, return it modulo 10^9 + 7.

 

Example 1:

Input: hats = [[3,4],[4,5],[5]]
Output: 1
Explanation: There is only one way to choose hats given the conditions. 
First person choose hat 3, Second person choose hat 4 and last one hat 5.
Example 2:

Input: hats = [[3,5,1],[3,5]]
Output: 4
Explanation: There are 4 ways to choose hats
(3,5), (5,3), (1,3) and (1,5)
Example 3:

Input: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
Output: 24
Explanation: Each person can choose hats labeled from 1 to 4.
Number of Permutations of (1,2,3,4) = 24.
Example 4:

Input: hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]
Output: 111
 

Constraints:

n == hats.length
1 <= n <= 10
1 <= hats[i].length <= 40
1 <= hats[i][j] <= 40
hats[i] contains a list of unique integers.

dp[i] 表示使得n个人戴帽子的状态为i的方案数量

class Solution
{
public:
    int numberWays(vector<vector<int>> &hats)
    {
        const long long MOD = 1e9 + 7;
        int n = hats.size();
        vector<long long> dp(1 << n);
        vector<set<int>> s(41);
        dp[0] = 1;
        for(int i = 0; i < n; i++)
            for(int hat : hats[i])
                s[hat].insert(i);
        for(int i = 1; i <= 40; i++)
        {
            vector<long long> ndp(dp);
            for(int state = (1 << n) - 1; state >= 0; state--)
            {
                for(int person : s[i])
                {
                    if(state & (1 << person)) continue;
                    int nxt = state + (1 << person);
                    ndp[nxt] += dp[state];
                    ndp[nxt] %= MOD;
                }
            }
            swap(dp, ndp);
        }
        return dp[(1 << n) - 1];
    }
};

// Source https://leetcode.com/problems/destination-city/

You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. 
Return the destination city, that is, the city without any path outgoing to another city.

It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.

 

Example 1:

Input: paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]
Output: "Sao Paulo" 
Explanation: Starting at "London" city you will reach "Sao Paulo" city which is the destination city. Your trip consist of: "London" -> "New York" -> "Lima" -> "Sao Paulo".
Example 2:

Input: paths = [["B","C"],["D","B"],["C","A"]]
Output: "A"
Explanation: All possible trips are: 
"D" -> "B" -> "C" -> "A". 
"B" -> "C" -> "A". 
"C" -> "A". 
"A". 
Clearly the destination city is "A".
Example 3:

Input: paths = [["A","Z"]]
Output: "Z"
 

Constraints:

1 <= paths.length <= 100
paths[i].length == 2
1 <= cityAi.length, cityBi.length <= 10
cityAi != cityBi
All strings consist of lowercase and uppercase English letters and the space character.

class Solution
{
public:
    string destCity(vector<vector<string>> &paths)
    {
        string res = "";
        unordered_set<string> h;
        for (int i = 0; i < paths.size(); i++)
        {
            h.insert(paths[i][0]);
        }
        for (int i = 0; i < paths.size(); i++)
        {
            if (h.find(paths[i][1]) == h.end())
            {
                res = paths[i][1];
                break;
            }
        }
        return res;
    }
};

// Source https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/

Given an array nums of 0s and 1s and an integer k, return True if all 1's are at least k places away from each other, otherwise return False.

 

Example 1:



Input: nums = [1,0,0,0,1,0,0,1], k = 2
Output: true
Explanation: Each of the 1s are at least 2 places away from each other.
Example 2:



Input: nums = [1,0,0,1,0,1], k = 2
Output: false
Explanation: The second 1 and third 1 are only one apart from each other.
Example 3:

Input: nums = [1,1,1,1,1], k = 0
Output: true
Example 4:

Input: nums = [0,1,0,1], k = 1
Output: true
 

Constraints:

1 <= nums.length <= 105
0 <= k <= nums.length
nums[i] is 0 or 1

class Solution
{
public:
    bool kLengthApart(vector<int> &nums, int k)
    {
        vector<int> pos;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] == 1)
            {
                pos.push_back(i);
            }
        }
        if(pos.size() < 2)
        {
            return true;
        }
        for(int i = 0; i < pos.size() - 1; i++)
        {
            if(pos[i + 1] - pos[i] - 1 < k)
            {
                return false;
            }
        }

        return true;
    }
};

// Source https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/

Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray 
such that the absolute difference between any two elements of this subarray is less than or equal to limit.

 

Example 1:

Input: nums = [8,2,4,7], limit = 4
Output: 2 
Explanation: All subarrays are: 
[8] with maximum absolute diff |8-8| = 0 <= 4.
[8,2] with maximum absolute diff |8-2| = 6 > 4. 
[8,2,4] with maximum absolute diff |8-2| = 6 > 4.
[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.
[2] with maximum absolute diff |2-2| = 0 <= 4.
[2,4] with maximum absolute diff |2-4| = 2 <= 4.
[2,4,7] with maximum absolute diff |2-7| = 5 > 4.
[4] with maximum absolute diff |4-4| = 0 <= 4.
[4,7] with maximum absolute diff |4-7| = 3 <= 4.
[7] with maximum absolute diff |7-7| = 0 <= 4. 
Therefore, the size of the longest subarray is 2.
Example 2:

Input: nums = [10,1,2,4,7,2], limit = 5
Output: 4 
Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.
Example 3:

Input: nums = [4,2,2,2,4,4,2,2], limit = 0
Output: 3
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109
0 <= limit <= 109

class Solution
{
public:
    int longestSubarray(vector<int> &nums, int limit)
    {
        map<int, int> mp;
        int start = 0, end = 0;
        int ans = 0;
        int size = nums.size();
        int maxOfWindow, minOfWindow;

        while(end < size)
        {
            mp[nums[end]]++;
            maxOfWindow = (--mp.end())->first;
            minOfWindow = mp.begin()->first;

            if(maxOfWindow - minOfWindow <= limit)
            {
                ans = max(ans, end - start + 1);
            }
            else
            {
                while(maxOfWindow - minOfWindow > limit)
                {
                    mp[nums[start]]--;
                    if(mp[nums[start]] == 0)
                    {
                        mp.erase(nums[start]);
                    }
                    start++;
                    maxOfWindow = (--mp.end())->first;
                    minOfWindow = mp.begin()->first;
                }
            }
            end++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/

You are given an m * n matrix, mat, and an integer k, which has its rows sorted in non-decreasing order.

You are allowed to choose exactly 1 element from each row to form an array. Return the Kth smallest array sum among all possible arrays.

 

Example 1:

Input: mat = [[1,3,11],[2,4,6]], k = 5
Output: 7
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.  
Example 2:

Input: mat = [[1,3,11],[2,4,6]], k = 9
Output: 17
Example 3:

Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
Output: 9
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  
Example 4:

Input: mat = [[1,1,10],[2,2,9]], k = 7
Output: 12
 

Constraints:

m == mat.length
n == mat.length[i]
1 <= m, n <= 40
1 <= k <= min(200, n ^ m)
1 <= mat[i][j] <= 5000
mat[i] is a non decreasing array.

class Solution
{
public:
    int kthSmallest(vector<vector<int>> &mat, int k)
    {
        int m = mat.size(), n = mat[0].size();
        using pivec = pair<int, vector<int>>;
        priority_queue<pivec, vector<pivec>, greater<pivec>> pq;
        map<vector<int>, bool> distincts;
        int smallestSum = 0;
        for(auto &row : mat) smallestSum += row[0];
        pq.push({smallestSum, vector<int>(m)});
        while(k--)
        {
            auto p = pq.top();
            pq.pop();
            smallestSum = p.first;
            vector<int> colIndicesNew;
            for(int i = 0; i < m; ++i)
            {
                colIndicesNew = p.second;
                int curSum = smallestSum;
                if(colIndicesNew[i] < n - 1)
                {
                    curSum -= mat[i][colIndicesNew[i]++];
                    curSum += mat[i][colIndicesNew[i]];
                }

                if(!distincts[colIndicesNew])
                {
                    distincts[colIndicesNew] = true;
                    pq.push({curSum, colIndicesNew});
                }
            }
        }
        return smallestSum;
    }
};

// Source https://leetcode.com/problems/build-an-array-with-stack-operations/

Given an array target and an integer n. In each iteration, you will read a number from  list = {1,2,3..., n}.

Build the target array using the following operations:

Push: Read a new element from the beginning list, and push it in the array.
Pop: delete the last element of the array.
If the target array is already built, stop reading more elements.
Return the operations to build the target array. You are guaranteed that the answer is unique.

 

Example 1:

Input: target = [1,3], n = 3
Output: ["Push","Push","Pop","Push"]
Explanation: 
Read number 1 and automatically push in the array -> [1]
Read number 2 and automatically push in the array then Pop it -> [1]
Read number 3 and automatically push in the array -> [1,3]
Example 2:

Input: target = [1,2,3], n = 3
Output: ["Push","Push","Push"]
Example 3:

Input: target = [1,2], n = 4
Output: ["Push","Push"]
Explanation: You only need to read the first 2 numbers and stop.
Example 4:

Input: target = [2,3,4], n = 4
Output: ["Push","Pop","Push","Push","Push"]
 

Constraints:

1 <= target.length <= 100
1 <= target[i] <= n
1 <= n <= 100
target is strictly increasing.

class Solution
{
public:
    vector<string> buildArray(vector<int> &target, int n)
    {
        vector<string> v;
        int qs = 0;
        for(int i = 1; i <= n; i++)
        {
            if(qs >= target.size())
            {
                break;
            }
            else if(i == target[qs])
            {
                v.push_back("Push");
                qs++;
            }
            else
            {
                v.push_back("Push");
                v.push_back("Pop");
            }
        }
        return v;
    }
};


// Source https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/

Given an array of integers arr.

We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).

Let's define a and b as follows:

a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
Note that ^ denotes the bitwise-xor operation.

Return the number of triplets (i, j and k) Where a == b.

 a ^ b = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] ^ arr[j] ^ arr[j + 1] ^ ... ^ arr[k] = 0

Example 1:

Input: arr = [2,3,1,6,7]
Output: 4
Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)
Example 2:

Input: arr = [1,1,1,1,1]
Output: 10
Example 3:

Input: arr = [2,3]
Output: 0
Example 4:

Input: arr = [1,3,5,7,9]
Output: 3
Example 5:

Input: arr = [7,11,12,9,5,2,7,17,22]
Output: 8
 

Constraints:

1 <= arr.length <= 300
1 <= arr[i] <= 10^8

class Solution
{
public:
    int countTriplets(vector<int> &arr)
    {
        int ans = 0;
        for(int i = 0; i < arr.size() - 1; i++)
        {
            int check = arr[i];
            for(int j = i + 1; j < arr.size(); j++)
            {
                check = (check ^ arr[j]);
                if(check == 0)
                    ans += (j - i);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/

Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. 
You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend to collect all apples in the tree, 
starting at vertex 0 and coming back to this vertex.

The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. 
Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple; otherwise, it does not have any apple.

 

Example 1:


Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
Output: 8 
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
Example 2:


Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]
Output: 6
Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  
Example 3:

Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]
Output: 0
 

Constraints:

1 <= n <= 105
edges.length == n - 1
edges[i].length == 2
0 <= ai < bi <= n - 1
fromi < toi
hasApple.length == n

class Solution
{
    int result = 0;
public:
    int minTime(int n, vector<vector<int>> &edges, vector<bool> &hasApple)
    {
        std::vector<std::vector<int>>map(n, std::vector<int>());
        std::vector<int> visited_map(n, 0);
        for(int i = 0; i < edges.size(); i++)
        {
            int parents = edges[i][0];
            int child = edges[i][1];
            map[parents].push_back(child);
            map[child].push_back(parents);
        }
        DFS(map, visited_map, hasApple, 0);
        return result;
    }
    bool DFS(std::vector<std::vector<int>> &map, std::vector<int> &visited_map, std::vector<bool> &apple_map, int current)
    {
        if(visited_map[current] == 1) return false;
        visited_map[current] = 1;
        bool path_contian_apple = false;
        for(int i = 0; i < map[current].size(); i++)
        {
            int next = map[current][i];
            bool is_apple_node = DFS(map, visited_map, apple_map, next);
            if(is_apple_node)
            {
                result += 2;
                path_contian_apple = true;
            }
        }
        return apple_map[current] || path_contian_apple;
    }
};


// Source https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/

Given a rectangular pizza represented as a rows x cols matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. 
You have to cut the pizza into k pieces using k-1 cuts. 

For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. 
If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. 
Give the last piece of pizza to the last person.

Return the number of ways of cutting the pizza such that each piece contains at least one apple. Since the answer can be a huge number, return this modulo 10^9 + 7.

 

Example 1:



Input: pizza = ["A..","AAA","..."], k = 3
Output: 3 
Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.
Example 2:

Input: pizza = ["A..","AA.","..."], k = 3
Output: 1
Example 3:

Input: pizza = ["A..","A..","..."], k = 1
Output: 1
 

Constraints:

1 <= rows, cols <= 50
rows == pizza.length
cols == pizza[i].length
1 <= k <= 10
pizza consists of characters 'A' and '.' only.

area[i][j] 表示左上角为[i,j]，右下角为[m-1,n-1]的披萨中包含的苹果数目
dp[i][j][k] 表示剩余的披萨左上角为[i,j]，右下角为[m-1,n-1]，要划分为k块，可行的切分方案数目

class Solution
{
public:
    int mod = 1e9 + 7;
    int dp[51][51][11];
    int area[52][52];
    int dfs(int r, int c, int k)
    {
        if (k == 1) return 1;
        auto &ans = dp[r][c][k];
        if (ans >= 0) return ans;
        ans = 0;
        for (int i = r + 1; area[i][c]; i++)
        {
            if (area[r][c] - area[i][c])
            {
                ans = (ans + dfs(i, c, k - 1)) % mod;
            }
        }
        for (int i = c + 1; area[r][i]; i++)
        {
            if (area[r][c] - area[r][i])
            {
                ans = (ans + dfs(r, i, k - 1)) % mod;
            }
        }
        return ans;
    }
    int ways(vector<string> &pizza, int k)
    {
        int m = pizza.size(), n = pizza[0].size();
        memset(dp, -1, sizeof(dp));
        memset(area, 0, sizeof(area));
        for (int i = m - 1, t = 0; i >= 0; i--, t = 0)
        {
            for (int j = n - 1; j >= 0; j--)
            {
                t += pizza[i][j] == 'A';
                area[i][j] = t + area[i + 1][j];
            }
        }
        return dfs(0, 0, k);
    }
};

// Source https://leetcode.com/problems/consecutive-characters/

The power of the string is the maximum length of a non-empty substring that contains only one unique character.

Given a string s, return the power of s.

 

Example 1:

Input: s = "leetcode"
Output: 2
Explanation: The substring "ee" is of length 2 with the character 'e' only.
Example 2:

Input: s = "abbcccddddeeeeedcba"
Output: 5
Explanation: The substring "eeeee" is of length 5 with the character 'e' only.
Example 3:

Input: s = "triplepillooooow"
Output: 5
Example 4:

Input: s = "hooraaaaaaaaaaay"
Output: 11
Example 5:

Input: s = "tourist"
Output: 1
 

Constraints:

1 <= s.length <= 500
s consists of only lowercase English letters.

class Solution
{
public:
    int maxPower(string s)
    {
        int count = 0;
        int n = s.size();
        int res = 0;
        for (int i = 0; i < n - 1; i++)
        {
            if (s[i] == s[i + 1])
                count++;
            else
                count = 0;
            res = max(res, count);
        }
        return res + 1;
    }
};

// Source https://leetcode.com/problems/simplified-fractions/

Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. The fractions can be in any order.

 

Example 1:

Input: n = 2
Output: ["1/2"]
Explanation: "1/2" is the only unique fraction with a denominator less-than-or-equal-to 2.
Example 2:

Input: n = 3
Output: ["1/2","1/3","2/3"]
Example 3:

Input: n = 4
Output: ["1/2","1/3","1/4","2/3","3/4"]
Explanation: "2/4" is not a simplified fraction because it can be simplified to "1/2".
Example 4:

Input: n = 1
Output: []
 

Constraints:

1 <= n <= 100

class Solution
{
public:
    vector<string> simplifiedFractions(int n)
    {
        vector<string> ans;
        for(int i = 2; i <= n; i++)
        {
            for(int j = 1; j < i; j++)
            {
                if(gcd(i, j) == 1)
                {
                    ans.push_back(to_string(j) + "/" + to_string(i));
                }
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/count-good-nodes-in-binary-tree/

Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.

Return the number of good nodes in the binary tree.

 

Example 1:



Input: root = [3,1,4,3,null,1,5]
Output: 4
Explanation: Nodes in blue are good.
Root Node (3) is always a good node.
Node 4 -> (3,4) is the maximum value in the path starting from the root.
Node 5 -> (3,4,5) is the maximum value in the path
Node 3 -> (3,1,3) is the maximum value in the path.
Example 2:



Input: root = [3,3,null,4,2]
Output: 3
Explanation: Node 2 -> (3, 3, 2) is not good, because "3" is higher than it.
Example 3:

Input: root = [1]
Output: 1
Explanation: Root is considered as good.
 

Constraints:

The number of nodes in the binary tree is in the range [1, 10^5].
Each node's value is between [-10^4, 10^4].

class Solution
{
private:
    int ans = 0;

    void traverse(TreeNode *root, int currMax)
    {
        if (!root)
        {
            return;
        }
        if (root->val >= currMax)
        {
            ++ans;
        }
        currMax = max(currMax, root->val);
        traverse(root->left, currMax);
        traverse(root->right, currMax);
    }
public:
    int goodNodes(TreeNode *root)
    {
        traverse(root, root->val);
        return ans;
    }
};

// Source https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/

Given an array of integers cost and an integer target. Return the maximum integer you can paint under the following rules:

The cost of painting a digit (i+1) is given by cost[i] (0 indexed).
The total cost used must be equal to target.
Integer does not have digits 0.
Since the answer may be too large, return it as string.

If there is no way to paint any integer given the condition, return "0".

 

Example 1:

Input: cost = [4,3,2,5,6,7,2,5,5], target = 9
Output: "7772"
Explanation:  The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost("7772") = 2*3+ 3*1 = 9. You could also paint "977", but "7772" is the largest number.
Digit    cost
  1  ->   4
  2  ->   3
  3  ->   2
  4  ->   5
  5  ->   6
  6  ->   7
  7  ->   2
  8  ->   5
  9  ->   5
Example 2:

Input: cost = [7,6,5,5,5,6,8,7,8], target = 12
Output: "85"
Explanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost("85") = 7 + 5 = 12.
Example 3:

Input: cost = [2,4,6,2,4,6,4,4,4], target = 5
Output: "0"
Explanation: It's not possible to paint any integer with total cost equal to target.
Example 4:

Input: cost = [6,10,15,40,40,40,40,40,40], target = 47
Output: "32211"
 

Constraints:

cost.length == 9
1 <= cost[i] <= 5000
1 <= target <= 5000

dp[i] 表示构成 i 所需要的数字个数最大值

class Solution
{
public:
    string largestNumber(vector<int> &cost, int target)
    {
        int dp[target + 1];
        memset(dp, -1, sizeof(dp));
        dp[0] = 0;

        for(int i = 0; i < 9; i++)
        {
            for(int j = cost[i]; j <= target; j++)
            {
                if(dp[j - cost[i]] != -1)
                    dp[j] = max(dp[j], dp[j - cost[i]] + 1);
            }
        }
        if (dp[target] < 0) return "0";
        string res = "";
        for (int i = 8; i >= 0; --i)
        {
            while (target >= cost[i] && dp[target] == dp[target - cost[i]] + 1)
            {
                res.push_back('1' + i);
                target -= cost[i];
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/

Given two integer arrays startTime and endTime and given an integer queryTime.

The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].

Return the number of students doing their homework at time queryTime. 
More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.

 

Example 1:

Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
Output: 1
Explanation: We have 3 students where:
The first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.
The second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.
The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.
Example 2:

Input: startTime = [4], endTime = [4], queryTime = 4
Output: 1
Explanation: The only student was doing their homework at the queryTime.
Example 3:

Input: startTime = [4], endTime = [4], queryTime = 5
Output: 0
Example 4:

Input: startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7
Output: 0
Example 5:

Input: startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5
Output: 5
 

Constraints:

startTime.length == endTime.length
1 <= startTime.length <= 100
1 <= startTime[i] <= endTime[i] <= 1000
1 <= queryTime <= 1000

class Solution
{
public:
    int busyStudent(vector<int> &startTime, vector<int> &endTime, int queryTime)
    {
        int ans = 0;
        for (int i = 0; i < startTime.size(); i++)
        {
            if (queryTime >= startTime[i] && queryTime <= endTime[i])
                ans++;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/rearrange-words-in-a-sentence/

Given a sentence text (A sentence is a string of space-separated words) in the following format:

First letter is in upper case.
Each word in text are separated by a single space.
Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. 
If two words have the same length, arrange them in their original order.

Return the new text following the format shown above.

 

Example 1:

Input: text = "Leetcode is cool"
Output: "Is cool leetcode"
Explanation: There are 3 words, "Leetcode" of length 8, "is" of length 2 and "cool" of length 4.
Output is ordered by length and the new first word starts with capital letter.
Example 2:

Input: text = "Keep calm and code on"
Output: "On and keep calm code"
Explanation: Output is ordered as follows:
"On" 2 letters.
"and" 3 letters.
"keep" 4 letters in case of tie order by position in original text.
"calm" 4 letters.
"code" 4 letters.
Example 3:

Input: text = "To be or not to be"
Output: "To be or to be not"
 

Constraints:

text begins with a capital letter and then contains lowercase letters and single space between words.
1 <= text.length <= 10^5

class Solution
{
public:
    string arrangeWords(string text)
    {
        string result;
        map<int, vector<string>>m;
        for(int i = 0; i < text.size(); i++)
        {
            string str = "";
            while(i < text.size() && text[i] != ' ')
            {
                str += tolower(text[i]);
                i++;
            }
            m[str.size()].push_back(str);
        }
        for(auto &p : m)
        {
            for(auto &s : p.second)
            {
                result += s;
                result += " ";
            }
        }
        result[0] = toupper(result[0]);
        result.pop_back();
        return result;
    }
};

// Source https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/

Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0).

Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.

 

Example 1:

Input: favoriteCompanies = [["leetcode","google","facebook"],["google","microsoft"],["google","facebook"],["google"],["amazon"]]
Output: [0,1,4] 
Explanation: 
Person with index=2 has favoriteCompanies[2]=["google","facebook"] which is a subset of favoriteCompanies[0]=["leetcode","google","facebook"] corresponding to the person with index 0. 
Person with index=3 has favoriteCompanies[3]=["google"] which is a subset of favoriteCompanies[0]=["leetcode","google","facebook"] and favoriteCompanies[1]=["google","microsoft"]. 
Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4].
Example 2:

Input: favoriteCompanies = [["leetcode","google","facebook"],["leetcode","amazon"],["facebook","google"]]
Output: [0,1] 
Explanation: In this case favoriteCompanies[2]=["facebook","google"] is a subset of favoriteCompanies[0]=["leetcode","google","facebook"], therefore, the answer is [0,1].
Example 3:

Input: favoriteCompanies = [["leetcode"],["google"],["facebook"],["amazon"]]
Output: [0,1,2,3]
 

Constraints:

1 <= favoriteCompanies.length <= 100
1 <= favoriteCompanies[i].length <= 500
1 <= favoriteCompanies[i][j].length <= 20
All strings in favoriteCompanies[i] are distinct.
All lists of favorite companies are distinct, that is, If we sort alphabetically each list then favoriteCompanies[i] != favoriteCompanies[j].
All strings consist of lowercase English letters only.

["leetcode","google","facebook"],["google","microsoft"],["google","facebook"],["google"],["amazon"]

leetcode	1	0	0	0	0
google		1	1	1	1	0
facebook	1	0	1	0	0
microsoft	0	1	0	0	0
amazon		0	0	0	0	1

class Solution
{
public:
    vector<int> peopleIndexes(vector<vector<string>> &favoriteCompanies)
    {
        unordered_map<string, bitset<100>> table;

        for(int i = 0; i != favoriteCompanies.size(); i++)
        {
            bitset<100> comp;
            comp.set(i);
            for(auto &f : favoriteCompanies[i]) table[f] |= comp;
        }

        vector<int> answer;
        for(int i = 0; i != favoriteCompanies.size(); i++)
        {
            bitset<100> comp;
            comp.flip();
            for(auto &f : favoriteCompanies[i]) comp &= table[f];

            if(comp.count() == 1) answer.push_back(i);
        }

        return answer;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/

You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. 
Darts thrown at the wall are represented as an array of points on a 2D plane. 

Return the maximum number of points that are within or lie on any circular dartboard of radius r.

 

Example 1:



Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2
Output: 4
Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.
Example 2:



Input: points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5
Output: 5
Explanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).
Example 3:

Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1
Output: 1
Example 4:

Input: points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2
Output: 4
 

Constraints:

1 <= points.length <= 100
points[i].length == 2
-10^4 <= points[i][0], points[i][1] <= 10^4
1 <= r <= 5000

一个点的时候，一定可以被覆盖，因为圆心可以调整。
两个点的时候，只要满足两点的距离d <= 2r就可以同时被覆盖。
在原来覆盖两个点的基础上，我们要去覆盖一个新的点，如果我们不想舍弃这两个点，那么最极限的状态就是当两个点都是圆边上的时候。
基于这个结论，我们可枚举两个点的集合情况，这两个点都是圆边上的点，然后根据两个点的坐标推算出圆心的坐标，然后根据得到的圆去计算能够覆盖的点的个数。

假设圆边上的两个点为A(xa, ya), B(xb,yb)，那么我们可以得到直线AB的斜率，进而得到了θ（AB与水平线的夹角）的值
θ=arctan( (ya-yb) / (xa - xb) )
直线AB的中点为(xa+xb/2, ya+yb/2)，中点与圆心的连线与直线AB相互垂直
中点与圆心的距离d = sqrt( r的平方 - (B与中点的距离平方) )
圆心的横坐标为中点的横坐标+d *sinθ
圆心的纵坐标为中点的纵坐标+d *cosθ
然后去计算这个圆能够覆盖多少点就行，最后求最大值就是答案。

#define eps 1e-8

class Solution
{
public:
    struct Point
    {
        double x, y;
        Point() {}
        Point(double tx, double ty)
        {
            x = tx;
            y = ty;
        }
    };
    double dist(Point p1, Point p2)
    {
        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
    }

    Point GetCircleCenter(Point p1, Point p2, int r)
    {
        Point mid = Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
        double angle = atan2(p1.y - p2.y, p2.x - p1.x);
        double d = sqrt(r * r - pow(dist(p1, mid), 2));
        return Point(mid.x + d * sin(angle), mid.y + d * cos(angle));
    }

    int max(int a, int b)
    {
        if(a > b)
            return a;
        return b;
    }

    int numPoints(vector<vector<int>> &points, int r)
    {
        int n = points.size();
        int ans = 1;
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                Point p1 = Point(points[i][0], points[i][1]);
                Point p2 = Point(points[j][0], points[j][1]);
                if(dist(p1, p2) > 2.0 * r) continue;
                Point center = GetCircleCenter(p1, p2, r);
                int cnt = 0;
                for(int k = 0; k < n; k++)
                {
                    Point pk = Point(points[k][0], points[k][1]);
                    if(dist(center, pk) < 1.0 * r + eps) cnt++;
                }
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/

Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence.

Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. 
If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.

A prefix of a string s is any leading contiguous substring of s.

 

Example 1:

Input: sentence = "i love eating burger", searchWord = "burg"
Output: 4
Explanation: "burg" is prefix of "burger" which is the 4th word in the sentence.
Example 2:

Input: sentence = "this problem is an easy problem", searchWord = "pro"
Output: 2
Explanation: "pro" is prefix of "problem" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index.
Example 3:

Input: sentence = "i am tired", searchWord = "you"
Output: -1
Explanation: "you" is not a prefix of any word in the sentence.
Example 4:

Input: sentence = "i use triple pillow", searchWord = "pill"
Output: 4
Example 5:

Input: sentence = "hello from the other side", searchWord = "they"
Output: -1
 

Constraints:

1 <= sentence.length <= 100
1 <= searchWord.length <= 10
sentence consists of lowercase English letters and spaces.
searchWord consists of lowercase English letters.

class Solution
{
public:
    int isPrefixOfWord(string sen, string sw)
    {
        vector<pair<string, int>> v;
        string str;
        int c = 1;
        for (auto i : sen)
        {
            str.push_back(i);
            if (i == ' ')
            {
                v.push_back({str, c});
                c++;
                str.clear();
            }
        }
        v.push_back({str, c});

        for (int i = 0; i < v.size(); i++)
        {
            auto pos = v[i].first.find(sw);
            
            if (pos == 0)
            {
                return v[i].second;
            }
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/

Given a string s and an integer k.

Return the maximum number of vowel letters in any substring of s with length k.

Vowel letters in English are (a, e, i, o, u).

 

Example 1:

Input: s = "abciiidef", k = 3
Output: 3
Explanation: The substring "iii" contains 3 vowel letters.
Example 2:

Input: s = "aeiou", k = 2
Output: 2
Explanation: Any substring of length 2 contains 2 vowels.
Example 3:

Input: s = "leetcode", k = 3
Output: 2
Explanation: "lee", "eet" and "ode" contain 2 vowels.
Example 4:

Input: s = "rhythms", k = 4
Output: 0
Explanation: We can see that s doesn't have any vowel letters.
Example 5:

Input: s = "tryhard", k = 4
Output: 1
 

Constraints:

1 <= s.length <= 10^5
s consists of lowercase English letters.
1 <= k <= s.length

class Solution
{
public:
    bool isVowel(char ch)
    {
        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')
        {
            return true;
        }
        return false;
    }
    int maxVowels(string s, int k)
    {
        int count = 0, j = 0, result = -1;
        for(int i = 0; i < k; i++)
        {
            if(isVowel(s[i]))
                count++;
        }

        result = count;

        for(int i = k; i < s.size(); i++)
        {
            if(isVowel(s[i]))
                count++;

            if(isVowel(s[j]))
                count--;

            result = max(result, count);
            j++;
        }

        return result;
    }
};

// Source https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/

Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic 
if at least one permutation of the node values in the path is a palindrome.

Return the number of pseudo-palindromic paths going from the root node to leaf nodes.

 

Example 1:



Input: root = [2,3,1,3,1,null,1]
Output: 2 
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).
Example 2:



Input: root = [2,1,1,1,3,null,null,null,null,null,1]
Output: 1 
Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).
Example 3:

Input: root = [9]
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [1, 105].
1 <= Node.val <= 9

class Solution
{
public:
    int result = 0;
    int digits[10];

    void dfs(TreeNode *root)
    {
        if(root == NULL) return;
        digits[root->val]++;
        if(root->left == NULL && root->right == NULL)
        {
            if(isPalindrome())
            {
                result++;
            }
        }
        else
        {
            dfs(root->left);
            dfs(root->right);
        }
        digits[root->val]--;
    }

    bool isPalindrome()
    {
        int odd = 0;
        for(int i = 1; i <= 9; i++)
        {
            if(digits[i] % 2 != 0)
                odd++;
        }
        if(odd > 1) return false;
        return true;
    }

    int pseudoPalindromicPaths (TreeNode *root)
    {
        dfs(root);
        return result;
    }
};



// Source https://leetcode.com/problems/max-dot-product-of-two-subsequences/

Given two arrays nums1 and nums2.

Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters 
without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).

 

Example 1:

Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]
Output: 18
Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.
Their dot product is (2*3 + (-2)*(-6)) = 18.
Example 2:

Input: nums1 = [3,-2], nums2 = [2,-6,7]
Output: 21
Explanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.
Their dot product is (3*7) = 21.
Example 3:

Input: nums1 = [-1,-1], nums2 = [1,1]
Output: -1
Explanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.
Their dot product is -1.
 

Constraints:

1 <= nums1.length, nums2.length <= 500
-1000 <= nums1[i], nums2[i] <= 1000

两个向量a = [a1, a2,…, an]和b = [b1, b2,…, bn]的点积定义为：
a・b=a1b1+a2b2+……+anbn。

dp[i][j]表示 the maximum dot product between non-empty subsequences of num1[i ... n-1] and num2[j ... m-1] with the same length.

5种情况 
不选择num1[i]和num2[j]		          dp[i+1][j+1]
只选择num1[i]                                             dp[i][j+1]
只选择num2[j]			          dp[i+1][j]
同时选择num1[i]和num2[j]，加上其他的    num1[i] * num2[j] + dp[i+1][j+1]
同时选择num1[i]和num2[j]，不加上其他的 num1[i] * num2[j]

class Solution
{
public:
    int maxDotProduct(vector<int> &nums1, vector<int> &nums2)
    {
        int n = nums1.size();
        int m = nums2.size();
        int dp[n][m];
        dp[n - 1][m - 1] = nums1[n - 1] * nums2[m - 1];
        for(int i = m - 2; i >= 0; i--)
        {
            dp[n - 1][i] = max(nums1[n - 1] * nums2[i], dp[n - 1][i + 1]);
        }
        for(int i = n - 2; i >= 0; i--)
        {
            dp[i][m - 1] = max(nums1[i] * nums2[m - 1], dp[i + 1][m - 1]);
        }
        for(int i = n - 2; i >= 0; i--)
        {
            for(int j = m - 2; j >= 0; j--)
            {
                dp[i][j] = nums1[i] * nums2[j];
                dp[i][j] = max(dp[i][j], max(max(dp[i][j] + dp[i + 1][j + 1], dp[i + 1][j]), max(dp[i + 1][j + 1], dp[i][j + 1])));
            }
        }
        return dp[0][0];
    }
};

// Source https://leetcode.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/

Given two integer arrays of equal length target and arr.

In one step, you can select any non-empty sub-array of arr and reverse it. You are allowed to make any number of steps.

Return True if you can make arr equal to target, or False otherwise.

 

Example 1:

Input: target = [1,2,3,4], arr = [2,4,1,3]
Output: true
Explanation: You can follow the next steps to convert arr to target:
1- Reverse sub-array [2,4,1], arr becomes [1,4,2,3]
2- Reverse sub-array [4,2], arr becomes [1,2,4,3]
3- Reverse sub-array [4,3], arr becomes [1,2,3,4]
There are multiple ways to convert arr to target, this is not the only way to do so.
Example 2:

Input: target = [7], arr = [7]
Output: true
Explanation: arr is equal to target without any reverses.
Example 3:

Input: target = [1,12], arr = [12,1]
Output: true
Example 4:

Input: target = [3,7,9], arr = [3,7,11]
Output: false
Explanation: arr doesn't have value 9 and it can never be converted to target.
Example 5:

Input: target = [1,1,1,1,1], arr = [1,1,1,1,1]
Output: true
 

Constraints:

target.length == arr.length
1 <= target.length <= 1000
1 <= target[i] <= 1000
1 <= arr[i] <= 1000

class Solution
{
public:
    bool canBeEqual(vector<int> &target, vector<int> &arr)
    {
        sort(target.begin(), target.end());
        sort(arr.begin(), arr.end());

        bool flag = true ;
        for(int i = 0; i < target.size(); i++)
        {
            if(target[i] != arr[i])
            {
                flag = false ;
                break;
            }
        }
        return flag ;
    }
};

// Source https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/

Given a binary string s and an integer k.

Return true if every binary code of length k is a substring of s. Otherwise, return false.

 

Example 1:

Input: s = "00110110", k = 2
Output: true
Explanation: The binary codes of length 2 are "00", "01", "10" and "11". They can be all found as substrings at indicies 0, 1, 3 and 2 respectively.
Example 2:

Input: s = "00110", k = 2
Output: true
Example 3:

Input: s = "0110", k = 1
Output: true
Explanation: The binary codes of length 1 are "0" and "1", it is clear that both exist as a substring. 
Example 4:

Input: s = "0110", k = 2
Output: false
Explanation: The binary code "00" is of length 2 and doesn't exist in the array.
Example 5:

Input: s = "0000000001011100", k = 4
Output: false
 

Constraints:

1 <= s.length <= 5 * 105
s[i] is either '0' or '1'.
1 <= k <= 20

class Solution
{
public:
    bool hasAllCodes(string s, int k)
    {
        int n = s.length();

        if (k > n)
        {
            return false;
        }

        vector<bool> given(1 << k, false);

        unsigned long long power = 1;
        for (int i = 1; i < k; i++)
        {
            power *= 2;
        }

        int remaining = 1 << k;
        int hash = 0;
        for (int i = 0; i < k; i++)
        {
            hash = hash * 2 + (s[i] == '1');
        }
        given[hash] = true;
        remaining--;

        for (int i = k; i < n; i++)
        {
            hash = hash - power * (s[i - k] == '1');
            hash = hash * 2 + (s[i] == '1');
            if (!given[hash])
            {
                remaining--;
            }
            given[hash] = true;
        }

        return remaining == 0;
    }
};


// Source https://leetcode.com/problems/course-schedule-iv/

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. 
You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi.

For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1.
Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c.

You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not.

Return a boolean array answer, where answer[j] is the answer to the jth query.

 

Example 1:


Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
Output: [false,true]
Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
Course 0 is not a prerequisite of course 1, but the opposite is true.
Example 2:

Input: numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
Output: [false,false]
Explanation: There are no prerequisites, and each course is independent.
Example 3:


Input: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
Output: [true,true]
 

Constraints:

2 <= numCourses <= 100
0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)
prerequisites[i].length == 2
0 <= ai, bi <= n - 1
ai != bi
All the pairs [ai, bi] are unique.
The prerequisites graph has no cycles.
1 <= queries.length <= 104
0 <= ui, vi <= n - 1
ui != vi

class Solution
{
public:
    vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>> &prerequisites, vector<vector<int>> &queries)
    {
        int n = numCourses;
        vector<int> indegree(n, 0);

        vector<vector<int>> adj(n);

        for(auto &e : prerequisites)
        {
            adj[e[0]].push_back(e[1]);
            indegree[e[1]]++;
        }

        vector<unordered_set<int>> prereqs(n);
        queue<int> q;
        for(int i = 0; i < n; i++)
            if(indegree[i] == 0)
                q.push(i);

        while(q.size())
        {
            int qsize = q.size();

            for(int k = 0; k < qsize; k++)
            {
                int currNode = q.front();
                q.pop();

                for(auto adjNode : adj[currNode])
                {
                    indegree[adjNode]--;
                    if(indegree[adjNode] == 0)
                        q.push(adjNode);

                    prereqs[adjNode].insert(currNode);
                    for(auto prereq : prereqs[currNode])
                        prereqs[adjNode].insert(prereq);
                }
            }
        }

        vector<bool> ans;
        for(int q = 0; q < queries.size(); q++)
        {
            int prereq = queries[q][0];
            int node = queries[q][1];

            ans.push_back(prereqs[node].find(prereq) != prereqs[node].end());
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/cherry-pickup-ii/

Given a rows x cols matrix grid representing a field of cherries. Each cell in grid represents the number of cherries that you can collect.

You have two robots that can collect cherries for you, Robot #1 is located at the top-left corner (0,0) , and Robot #2 is located at the top-right corner (0, cols-1) of the grid.

Return the maximum number of cherries collection using both robots  by following the rules below:

From a cell (i,j), robots can move to cell (i+1, j-1) , (i+1, j) or (i+1, j+1).
When any robot is passing through a cell, It picks it up all cherries, and the cell becomes an empty cell (0).
When both robots stay on the same cell, only one of them takes the cherries.
Both robots cannot move outside of the grid at any moment.
Both robots should reach the bottom row in the grid.
 

Example 1:



Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
Output: 24
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.
Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.
Total of cherries: 12 + 12 = 24.
Example 2:



Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
Output: 28
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.
Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.
Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.
Total of cherries: 17 + 11 = 28.
Example 3:

Input: grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
Output: 22
Example 4:

Input: grid = [[1,1],[1,1]]
Output: 4
 

Constraints:

rows == grid.length
cols == grid[i].length
2 <= rows, cols <= 70
0 <= grid[i][j] <= 100 

dp[r][c1][c2] 表示机器人1当前在[r][c1]，机器人2当前在[r][c2]，可以获得的 the maximum number of cherries 

class Solution
{
public:
    int dp[75][75][75];

    int func(vector<vector<int>> &grid, int r1, int c1, int r2, int c2)
    {
        if(r1 >= grid.size() || r2 >= grid.size() || c1 < 0 || c2 < 0 || c1 >= grid[0].size() || c2 >= grid[0].size())
        {
            return 0;
        }

        if(dp[r1][c1][c2] != -1)
        {
            return dp[r1][c1][c2];
        }

        int cherries = 0;

        if(r1 == r2 && c1 == c2)
        {
            cherries += grid[r1][c1];
        }
        else
        {
            cherries += grid[r1][c1];
            cherries += grid[r2][c2];
        }

        int path1 = func(grid, r1 + 1, c1 - 1, r2 + 1, c2 - 1);
        int path2 = func(grid, r1 + 1, c1 - 1, r2 + 1, c2);
        int path3 = func(grid, r1 + 1, c1 - 1, r2 + 1, c2 + 1);
        int path4 = func(grid, r1 + 1, c1, r2 + 1, c2 - 1);
        int path5 = func(grid, r1 + 1, c1, r2 + 1, c2);
        int path6 = func(grid, r1 + 1, c1, r2 + 1, c2 + 1);
        int path7 = func(grid, r1 + 1, c1 + 1, r2 + 1, c2 - 1);
        int path8 = func(grid, r1 + 1, c1 + 1, r2 + 1, c2);
        int path9 = func(grid, r1 + 1, c1 + 1, r2 + 1, c2 + 1);

        int max1 = max(max(path1, path2), max(path3, path4));
        int max2 = max(max(path5, path6), max(path7, path8));
        max1 = max(max1, path9);

        cherries += max(max1, max2);

        return dp[r1][c1][c2] = cherries;
    }

    int cherryPickup(vector<vector<int>> &grid)
    {
        int m = grid.size();
        int n = grid[0].size();

        memset(dp, -1, sizeof(dp));

        return func(grid, 0, 0, 0, n - 1) <= 0 ? 0 : func(grid, 0, 0, 0, n - 1);
    }
};

// Source https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/

Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).
 

Example 1:

Input: nums = [3,4,5,2]
Output: 12 
Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. 
Example 2:

Input: nums = [1,5,4,5]
Output: 16
Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.
Example 3:

Input: nums = [3,7]
Output: 12
 

Constraints:

2 <= nums.length <= 500
1 <= nums[i] <= 10^3

class Solution
{
public:
    int maxProduct(vector<int> &nums)
    {
        int a = 0, b = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] >= a)
            {
                b = a;
                a = nums[i];
                continue;
            }
            if(nums[i] > b)
                b = nums[i];
        }
        return ((a - 1) * (b - 1));
    }
};

// Source https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/

You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where:

horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and
verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.
Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. 
Since the answer can be a large number, return this modulo 109 + 7.

 

Example 1:


Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]
Output: 4 
Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.
Example 2:


Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]
Output: 6
Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.
Example 3:

Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]
Output: 9
 

Constraints:

2 <= h, w <= 109
1 <= horizontalCuts.length <= min(h - 1, 105)
1 <= verticalCuts.length <= min(w - 1, 105)
1 <= horizontalCuts[i] < h
1 <= verticalCuts[i] < w
All the elements in horizontalCuts are distinct.
All the elements in verticalCuts are distinct.

class Solution
{
public:
    int maxArea(int h, int w, vector<int> &horizontalCuts, vector<int> &verticalCuts)
    {
        sort(horizontalCuts.begin(), horizontalCuts.end());
        sort(verticalCuts.begin(), verticalCuts.end());
        int n = horizontalCuts.size(), m = verticalCuts.size();
        vector<int> horizontalDiffs{horizontalCuts[0]}, verticalDiffs{verticalCuts[0]};
        horizontalDiffs.reserve(n + 1);
        verticalDiffs.reserve(m + 1);
        for (int i = 1; i < n; ++i)
        {
            horizontalDiffs.push_back(horizontalCuts[i] - horizontalCuts[i - 1]);
        }
        horizontalDiffs.push_back(h - horizontalCuts.back());
        for (int i = 1; i < m; ++i)
        {
            verticalDiffs.push_back(verticalCuts[i] - verticalCuts[i - 1]);
        }
        verticalDiffs.push_back(w - verticalCuts.back());
        return ( (long) *max_element(horizontalDiffs.begin(), horizontalDiffs.end()) % 1000000007 *
                (long) *max_element(verticalDiffs.begin(), verticalDiffs.end()) % 1000000007 );
    }
};

// Source https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/

There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). 
Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.

This year, there will be a big event in the capital (city 0), and many people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.

It's guaranteed that each city can reach city 0 after reorder.

 

Example 1:


Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
Output: 3
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
Example 2:


Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
Output: 2
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
Example 3:

Input: n = 3, connections = [[1,0],[2,0]]
Output: 0
 

Constraints:

2 <= n <= 5 * 104
connections.length == n - 1
connections[i].length == 2
0 <= ai, bi <= n - 1
ai != bi

class Solution
{
public:
    void dfs(int node, int &ans, vector<pair<int, int>> graph[], vector<bool> &visited)
    {
        visited[node] = true;
        for(auto np : graph[node])
        {
            int nb = np.first;
            int weight = np.second;
            if(visited[nb] == false)
            {
                ans += weight;
                dfs(nb, ans, graph, visited);
            }
        }
    }
    int minReorder(int n, vector<vector<int>> &connections)
    {
        vector<pair<int, int>> graph[n];
        int m = connections.size();
        for(int i = 0; i < m; i++)
        {
            int u = connections[i][0];
            int v = connections[i][1];
            graph[u].push_back({v, 1});
            graph[v].push_back({u, 0});
        }
        int ans = 0;
        vector<bool> visited(n, false);
        dfs(0, ans, graph, visited);
        return ans;
    }
};


// Source https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/

Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.

All the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box 
(Please read the explanation of the second example carefully).

Please note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), 
then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).

Return the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.

 把2n个球随机分成数量相等均为n的两堆，统计两堆中各自的不同颜色数量，问两者相等的概率是多少？

Example 1:

Input: balls = [1,1]
Output: 1.00000
Explanation: Only 2 ways to divide the balls equally:
- A ball of color 1 to box 1 and a ball of color 2 to box 2
- A ball of color 2 to box 1 and a ball of color 1 to box 2
In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1

2 / C(1,2) = 2 /2 = 1

Example 2:

Input: balls = [2,1,1]
Output: 0.66667
Explanation: We have the set of balls [1, 1, 2, 3]
This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):
[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]
After that, we add the first two balls to the first box and the second two balls to the second box.
We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.
Probability is 8/12 = 0.66667

4 / C(2,4) = 4 / 6 = 2/3

Example 3:

Input: balls = [1,2,1,2]
Output: 0.60000
Explanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.
Probability = 108 / 180 = 0.6

1 2 2 
1 2 3 ->
1 2 4 
1 2 4 
1 2 3  ->
1 2 4
1 2 4
1 3 4 ->
1 3 4 ->
1 4 4
2 2 3
2 2 4 ->
2 2 4 ->
2 3 4
2 3 4
2 4 4 ->
2 3 4
2 3 4
2 4 4 ->
3 4 4 

12 / C(3,6) = 12 / 20 = 3 / 5

Example 4:

Input: balls = [3,2,1]
Output: 0.30000
Explanation: The set of balls is [1, 1, 1, 2, 2, 3]. It is hard to display all the 60 possible random shuffles of this set but it is easy to check that 18 of them will have the same number of distinct colors in each box.
Probability = 18 / 60 = 0.3

1 1 1 ->
1 1 2 ->
1 1 2 ->
1 1 3 
1 1 2 ->
1 1 2 ->
1 1 3
1 2 2
1 2 3 ->
1 2 3 ->
1 1 2 ->
1 1 2 ->
1 1 3
1 2 2
1 2 3 ->
1 2 3 ->
1 2 2
1 2 3 ->
1 2 3 ->
2 2 3 ->


6 / C(3, 6) = 6 / 20 = 3/ 10

Example 5:

Input: balls = [6,6,6,6,6,6]
Output: 0.90327
 

Constraints:

1 <= balls.length <= 8
1 <= balls[i] <= 6
sum(balls) is even.

a b
C(1,2) -> C(0,1) + C(1,1) = 2

a b c d
C(2,4) -> C(1,3) + C(2,3) = 6
C(1,3) -> C(0,2) + C(1,2) = 3
C(1,2) -> C(0,1) + C(1,1) = 2
C(2,3) -> C(1,2) + C(2,2) = 3

a b c d e f
C(3,6) -> C(2,5) + C(3,5) = 20
C(2,5) -> C(1,4) + C(2,4) = 10
C(1,4) -> C(0,3) + C(1,3) = 4
C(3,5) -> C(2,4) + C(3,4) = 10
C(3,4) -> C(2,3) + C(3,3) = 4

排列的公式：A（n，m）= n!/（n-m）!（n为下标，m为上标,以下同）。

例如：A（4，2）=4!/2!=4*3=12。

组合的公式：C（n，m）= n!/m!*（n-m）!。

例如：C（4，2）=4!/（2!*2!）=4*3/(2*1)=6。

class Solution
{
private:
    int sum;
    vector<vector<long>> memc;
public:
    double getProbability(vector<int> &balls)
    {
        sum = 0;
        memc = vector(25, vector<long>(50, 0)); //the maximum balls's numbers is 48.
        for(int ball : balls)
        {
            sum += ball;
        }
        long total = C(sum / 2, sum); //cnt of total cases
        long valid = dfs(balls, 0, 0, 0, 0, 0, 1); //cnt of valid cases
        return 1.0 * valid / total;
    }
    long dfs(vector<int> &balls, int pos, int suma, int sumb, int cnta, int cntb, long res)
    {
        if(suma > sum / 2 || sumb > sum / 2 )
            return 0;
        if(pos == balls.size())
            return cnta == cntb ? res : 0;
        long cnt = 0;
        cnt += dfs(balls, pos + 1, suma, sumb + balls[pos], cnta, cntb + 1, res * 1); //put all ith color balls to b blanket
        cnt += dfs(balls, pos + 1, suma + balls[pos], sumb, cnta + 1, cntb, res * 1); //put all ith color balls to a blanket
        for(int j = 1; j < balls[pos]; j++)
        {
            //put j ith color balls to blanket a and the rest to blanket b.refresh the color combination's cnt.
            cnt += dfs(balls, pos + 1, suma + j, sumb + balls[pos] - j, cnta + 1, cntb + 1, res * C(j, balls[pos]));
        }
        return cnt;
    }
    long C(int a, int b)
    {
        if(a == b || a == 0)
            return 1;
        if(memc[a][b] > 0)
            return memc[a][b];
        memc[a][b] = C(a - 1, b - 1) + C(a, b - 1);
        return memc[a][b];
    }
};


// Source https://leetcode.com/problems/shuffle-the-array/

Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].

Return the array in the form [x1,y1,x2,y2,...,xn,yn].

 

Example 1:

Input: nums = [2,5,1,3,4,7], n = 3
Output: [2,3,5,4,1,7] 
Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].
Example 2:

Input: nums = [1,2,3,4,4,3,2,1], n = 4
Output: [1,4,2,3,3,2,4,1]
Example 3:

Input: nums = [1,1,2,2], n = 2
Output: [1,2,1,2]
 

Constraints:

1 <= n <= 500
nums.length == 2n
1 <= nums[i] <= 10^3

class Solution
{
public:
    vector<int> shuffle(vector<int> &nums, int n)
    {
        vector<int>v;
        for(int i = 0; i < n; i++)
        {
            v.push_back(nums[i]);
            v.push_back(nums[n + i]);
        }
        return v;
    }
};

// Source https://leetcode.com/problems/the-k-strongest-values-in-an-array/

Given an array of integers arr and an integer k.

A value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the median of the array.
If |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j].

Return a list of the strongest k values in the array. return the answer in any arbitrary order.

Median is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) / 2) in the sorted list (0-indexed).

For arr = [6, -3, 7, 2, 11], n = 5 and the median is obtained by sorting the array arr = [-3, 2, 6, 7, 11] and the median is arr[m] where m = ((5 - 1) / 2) = 2. The median is 6.
For arr = [-7, 22, 17, 3], n = 4 and the median is obtained by sorting the array arr = [-7, 3, 17, 22] and the median is arr[m] where m = ((4 - 1) / 2) = 1. The median is 3.
 

Example 1:

Input: arr = [1,2,3,4,5], k = 2
Output: [5,1]
Explanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.
Please note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1.
Example 2:

Input: arr = [1,1,3,5,5], k = 2
Output: [5,5]
Explanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].
Example 3:

Input: arr = [6,7,11,7,6,8], k = 5
Output: [11,8,6,6,7]
Explanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].
Any permutation of [11,8,6,6,7] is accepted.
Example 4:

Input: arr = [6,-3,7,2,11], k = 3
Output: [-3,11,2]
Example 5:

Input: arr = [-7,22,17,3], k = 2
Output: [22,17]
 

Constraints:

1 <= arr.length <= 10^5
-10^5 <= arr[i] <= 10^5
1 <= k <= arr.length

class Solution
{
public:
    vector<int> getStrongest(vector<int> &arr, int k)
    {
        sort(arr.begin(), arr.end());
        int f = (arr.size() - 1) / 2;
        int m = arr[f];
        priority_queue<pair<int, int>>p;
        for(int i = 0; i < arr.size(); i++)
        {
            int s = abs(arr[i] - m);
            p.push({s, arr[i]});
        }
        vector<int>v;
        while(k)
        {
            v.push_back(p.top().second);
            p.pop();
            k--;
        }
        return v;
    }
};

class Solution
{
public:
    vector<int> getStrongest(vector<int> &arr, int k)
    {
        sort(arr.begin(), arr.end());
        int n = arr.size();
        int median = (n - 1) / 2;
        int medval = arr[median];
        vector<int> ans;
        int left = 0;
        int right = n - 1;
        while (left <= right)
        {
            if (left == right)
            {
                ans.push_back(arr[left]);
                ++left;
            }
            else if (abs(arr[right] - medval) > abs(arr[left] - medval))
            {
                ans.push_back(arr[right]);
                --right;
            }
            else if (abs(arr[right] - medval) < abs(arr[left] - medval))
            {
                ans.push_back(arr[left]);
                ++left;
            }
            else
            {
                if (arr[right] > arr[left])
                {
                    ans.push_back(arr[right]);
                    --right;
                }
                else
                {
                    ans.push_back(arr[left]);
                    ++left;
                }
            }
            if (ans.size() == k)  return ans;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/design-browser-history/

You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.

Implement the BrowserHistory class:

BrowserHistory(string homepage) Initializes the object with the homepage of the browser.
void visit(string url) Visits url from the current page. It clears up all the forward history.
string back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps.
string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps.
 

Example:

Input:
["BrowserHistory","visit","visit","visit","back","back","forward","visit","forward","back","back"]
[["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]
Output:
[null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"]

Explanation:
BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
browserHistory.visit("google.com");       // You are in "leetcode.com". Visit "google.com"
browserHistory.visit("facebook.com");     // You are in "google.com". Visit "facebook.com"
browserHistory.visit("youtube.com");      // You are in "facebook.com". Visit "youtube.com"
browserHistory.back(1);                   // You are in "youtube.com", move back to "facebook.com" return "facebook.com"
browserHistory.back(1);                   // You are in "facebook.com", move back to "google.com" return "google.com"
browserHistory.forward(1);                // You are in "google.com", move forward to "facebook.com" return "facebook.com"
browserHistory.visit("linkedin.com");     // You are in "facebook.com". Visit "linkedin.com"
browserHistory.forward(2);                // You are in "linkedin.com", you cannot move forward any steps.
browserHistory.back(2);                   // You are in "linkedin.com", move back two steps to "facebook.com" then to "google.com". return "google.com"
browserHistory.back(7);                   // You are in "google.com", you can move back only one step to "leetcode.com". return "leetcode.com"
 

Constraints:

1 <= homepage.length <= 20
1 <= url.length <= 20
1 <= steps <= 100
homepage and url consist of  '.' or lower case English letters.
At most 5000 calls will be made to visit, back, and forward.

struct node                     // Doubly linked list node structure
{
    string val;
    node *pre;
    node *next;
    node(string x)
    {
        val =  x;
        pre  = NULL;
        next = NULL ;
    }
};

class BrowserHistory
{
public:
    node *p ;

    BrowserHistory(string a)
    {
        p = new node(a);
    }

    void visit(string a)
    {
        node *t = new node(a);
        p->next = t;
        t->pre = p;
        p = t;
    }

    string back(int n)
    {
        while(n-- && p->pre)
        {
            p = p->pre;
        }
        return p->val;
    }

    string forward(int n)
    {
        while(n-- && p->next)
        {
            p = p->next;
        }
        return p->val;
    }
};


// Source https://leetcode.com/problems/paint-house-iii/

There is a row of m houses in a small city, each house must be painted with one of the n colors (labeled from 1 to n), 
some houses that have been painted last summer should not be painted again.

A neighborhood is a maximal group of continuous houses that are painted with the same color.

For example: houses = [1,2,2,3,3,2,1,1] contains 5 neighborhoods [{1}, {2,2}, {3,3}, {2}, {1,1}].
Given an array houses, an m x n matrix cost and an integer target where:

houses[i]: is the color of the house i, and 0 if the house is not painted yet.
cost[i][j]: is the cost of paint the house i with the color j + 1.
Return the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods. If it is not possible, return -1.

 

Example 1:

Input: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
Output: 9
Explanation: Paint houses of this way [1,2,2,1,1]
This array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}].
Cost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.
Example 2:

Input: houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
Output: 11
Explanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2]
This array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}]. 
Cost of paint the first and last house (10 + 1) = 11.
Example 3:

Input: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
Output: 5
Example 4:

Input: houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
Output: -1
Explanation: Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3.
 

Constraints:

m == houses.length == cost.length
n == cost[i].length
1 <= m <= 100
1 <= n <= 20
1 <= target <= m
0 <= houses[i] <= n
1 <= cost[i][j] <= 10^4

dp[i][j][k] 表示paint下标范围为[i ... m-1]的房子，形成j个新的neighborhood，且下标 i 前一个neighborhood的颜色为k，所需的the minimum cost 

class Solution
{
public:
    int dp[102][102][22];
    int solve(vector<int> &h, vector<vector<int>> &cost, int m, int n, int target, int i, int prev_col)
    {
        if(i == m && target == 0)
            return 0;

        if(i >= m || target < 0)
            return INT_MAX;

        if(dp[i][target][prev_col] != -1)
            return dp[i][target][prev_col];

        if(h[i] != 0)
        {
            if(h[i] == prev_col)
                return solve(h, cost, m, n, target, i + 1, h[i]);
            else
                return solve(h, cost, m, n, target - 1, i + 1, h[i]);
        }

        int ans = INT_MAX;
        if(h[i] == 0)
        {
            for(int j = 0 ; j  < n ; j++)
            {
                if(prev_col == j + 1)
                {
                    int val = solve(h, cost, m, n, target, i + 1, j + 1);
                    if(val != INT_MAX)
                    {
                        ans = min(ans, val + cost[i][j]);
                    }
                }
                else
                {
                    int val = solve(h, cost, m, n, target - 1, i + 1, j + 1);
                    if(val != INT_MAX)
                    {
                        ans = min(ans, val + cost[i][j]);
                    }
                }
            }
        }
        return dp[i][target][prev_col] = ans;
    }
    int minCost(vector<int> &h, vector<vector<int>> &cost, int m, int n, int target)
    {
        memset(dp, -1, sizeof(dp));
        int p = solve(h, cost, m, n, target, 0, 0);

        return p == INT_MAX ? -1 : p;
    }
};


// Source https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/

Given the array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop, 
if you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i], 
otherwise, you will not receive any discount at all.

Return an array where the ith element is the final price you will pay for the ith item of the shop considering the special discount.

 

Example 1:

Input: prices = [8,4,6,2,3]
Output: [4,2,4,2,3]
Explanation: 
For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. 
For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. 
For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. 
For items 3 and 4 you will not receive any discount at all.
Example 2:

Input: prices = [1,2,3,4,5]
Output: [1,2,3,4,5]
Explanation: In this case, for all items, you will not receive any discount at all.
Example 3:

Input: prices = [10,1,1,6]
Output: [9,0,1,6]
 

Constraints:

1 <= prices.length <= 500
1 <= prices[i] <= 10^3

class Solution
{
public:
    vector<int> finalPrices(vector<int> &prices)
    {
        int n = prices.size();
        vector<int> dis(n, -1);
        for(int i = 0; i < n ; i++)
        {
            for(int j = i + 1 ; j < n ; j++)
            {
                if(prices[j] <= prices[i])
                {
                    dis[i] = prices[j];
                    break;
                }
            }
        }

        for(int i = 0 ; i < n; i++)
        {
            if(dis[i] != -1)
            {
                prices[i] -= dis[i];
            }
        }
        return prices;
    }
};


// Source https://leetcode.com/problems/subrectangle-queries/

Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:

1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)

Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).
2. getValue(int row, int col)

Returns the current value of the coordinate (row,col) from the rectangle.
 

Example 1:

Input
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue","getValue"]
[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]
Output
[null,1,null,5,5,null,10,5]
Explanation
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  
// The initial rectangle (4x3) looks like:
// 1 2 1
// 4 3 4
// 3 2 1
// 1 1 1
subrectangleQueries.getValue(0, 2); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);
// After this update the rectangle looks like:
// 5 5 5
// 5 5 5
// 5 5 5
// 5 5 5 
subrectangleQueries.getValue(0, 2); // return 5
subrectangleQueries.getValue(3, 1); // return 5
subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);
// After this update the rectangle looks like:
// 5   5   5
// 5   5   5
// 5   5   5
// 10  10  10 
subrectangleQueries.getValue(3, 1); // return 10
subrectangleQueries.getValue(0, 2); // return 5
Example 2:

Input
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue"]
[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]
Output
[null,1,null,100,100,null,20]
Explanation
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);
subrectangleQueries.getValue(0, 0); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);
subrectangleQueries.getValue(0, 0); // return 100
subrectangleQueries.getValue(2, 2); // return 100
subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);
subrectangleQueries.getValue(2, 2); // return 20
 

Constraints:

There will be at most 500 operations considering both methods: updateSubrectangle and getValue.
1 <= rows, cols <= 100
rows == rectangle.length
cols == rectangle[i].length
0 <= row1 <= row2 < rows
0 <= col1 <= col2 < cols
1 <= newValue, rectangle[i][j] <= 10^9
0 <= row < rows
0 <= col < cols

class SubrectangleQueries
{
public:

    vector<vector<int>> v ; // to store updates
    vector<vector<int>> rect ; // to store the original rectangle

    SubrectangleQueries(vector<vector<int>> &rectangle)
    {
        v.clear() ;
        rect = rectangle ;
    }

    void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)
    {
        v.push_back({row1, col1, row2, col2, newValue}) ;
    }

    int getValue(int row, int col)
    {
        int n = v.size() ;

        for(int i = n - 1; i >= 0; i--)
        {
            if(row >= v[i][0] && row <= v[i][2] && col >= v[i][1] && col <= v[i][3])
                return v[i][4] ;
        }

        return rect[row][col] ;
    }
};


// Source https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/

Given an array of integers arr and an integer target.

You have to find two non-overlapping sub-arrays of arr each with a sum equal target. 
There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.

Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.

 

Example 1:

Input: arr = [3,2,2,4,3], target = 3
Output: 2
Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.
Example 2:

Input: arr = [7,3,4,7], target = 7
Output: 2
Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.
Example 3:

Input: arr = [4,3,2,6,2,3,4], target = 6
Output: -1
Explanation: We have only one sub-array of sum = 6.
Example 4:

Input: arr = [5,5,4,4,5], target = 3
Output: -1
Explanation: We cannot find a sub-array of sum = 3.
Example 5:

Input: arr = [3,1,1,1,5,1,2,1], target = 3
Output: 3
Explanation: Note that sub-arrays [1,2] and [2,1] cannot be an answer because they overlap.
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 1000
1 <= target <= 108

dp[i] 表示下标范围为[0 ... i]，各元素之和为target的子数组长度最小值

class Solution
{
public:
    int minSumOfLengths(vector<int> &arr, int target)
    {
        int n = arr.size();
        vector<int> dp(n, INT_MAX);

        int sum = 0;
        int ans = INT_MAX;
        int len = INT_MAX;
        int start = 0;
        int end = 0;

        for (end = 0; end < n; end++)
        {
            sum += arr[end];

            while (sum > target)
            {
                sum -= arr[start];
                start++;
            }

            if (sum == target)
            {
                int curLen = end - start + 1;
                if (start > 0 && dp[start - 1] != INT_MAX)
                {
                    ans = min(ans, curLen + dp[start - 1]);
                }
                len = min(curLen, len);
            }
            dp[end] = len;
        }
        return ans == INT_MAX ? -1 : ans;
    }
};


// Source https://leetcode.com/problems/allocate-mailboxes/

Given the array houses and an integer k. where houses[i] is the location of the ith house along a street, your task is to allocate k mailboxes in the street.

Return the minimum total distance between each house and its nearest mailbox.

The answer is guaranteed to fit in a 32-bit signed integer.

 

Example 1:



Input: houses = [1,4,8,10,20], k = 3
Output: 5
Explanation: Allocate mailboxes in position 3, 9 and 20.
Minimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 
Example 2:



Input: houses = [2,3,5,12,18], k = 2
Output: 9
Explanation: Allocate mailboxes in position 3 and 14.
Minimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.
Example 3:

Input: houses = [7,4,6,1], k = 1
Output: 8
Example 4:

Input: houses = [3,6,14,10], k = 4
Output: 0
 

Constraints:

n == houses.length
1 <= n <= 100
1 <= houses[i] <= 10^4
1 <= k <= n
Array houses contain unique integers.

n个房子分成k组，每个小组有一个共同的最近邮箱，问每个房子与最近的邮箱距离之和最小值是多少
cost[i][j] 表示在下标[i ... j]的所有房子中间位置放一个邮箱，所有房子与这个邮箱距离之和
dp[i][k] 表示把下标[i ... n-1]的所有房子分成k组，每组房子中间位置放一个邮箱，每个房子与最近的邮箱距离之和最小值

class Solution
{
public:
    int dp[101][101];
    int solve(vector<int> &h, int k, int n, int i, vector<vector<int>> &cost)
    {
        if(i == n && k == 0) return 0;
        if(i == n || k == 0) return 1e7;
        if(dp[i][k] != -1)  return dp[i][k];
        int ans = 1e7;
        for(int j = i ; j <= n - k ; j++)
            ans = min(ans, cost[i][j] + solve(h, k - 1, n, j + 1, cost));
        dp[i][k] = ans;
        return dp[i][k];
    }
    int minDistance(vector<int> &h, int k)
    {
        int n = h.size();
        if (k == n) return 0;
        vector<vector<int>>cost(n, vector<int>(n, 0));
        sort(h.begin(), h.end());
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                int l = i;
                int r = j;
                while(r > l)
                {
                    cost[i][j] += h[r--] - h[l++];
                }
            }
        }
        memset(dp, -1, sizeof(dp));
        return solve(h, k, n, 0, cost);
    }
};


// Source https://leetcode.com/problems/running-sum-of-1d-array/

Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).

Return the running sum of nums.

 

Example 1:

Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].
Example 2:

Input: nums = [1,1,1,1,1]
Output: [1,2,3,4,5]
Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].
Example 3:

Input: nums = [3,1,2,10,1]
Output: [3,4,6,16,17]
 

Constraints:

1 <= nums.length <= 1000
-10^6 <= nums[i] <= 10^6

class Solution
{
public:
    vector<int> runningSum(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> ans(n);
        ans[0] = nums[0];
        for(int i = 1; i < n; i++)
        {
            ans[i] = ans[i - 1] + nums[i];
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/

Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.

 

Example 1:

Input: arr = [5,5,4], k = 1
Output: 1
Explanation: Remove the single 4, only 5 is left.
Example 2:
Input: arr = [4,3,1,1,3,3,2], k = 3
Output: 2
Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.
 

Constraints:

1 <= arr.length <= 10^5
1 <= arr[i] <= 10^9
0 <= k <= arr.length

class Solution
{
private:
    unordered_map <int, int> occurences;
    priority_queue < int, vector<int>, greater<int> > minHeap;
public:

    int findLeastNumOfUniqueInts(vector<int> &arr, int k)
    {
        for (auto number : arr)
        {
            occurences[number]++;
        }

        for (auto it = occurences.begin(); it != occurences.end(); it++)
            minHeap.push(it->second);

        while (k > 0)
        {
            int occ = minHeap.top();
            minHeap.pop();

            if (occ > 1)
                minHeap.push(occ - 1);
            k--;
        }

        return minHeap.size();
    }
};


// Source https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/

Given an integer array bloomDay, an integer m and an integer k.

We need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.

The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.

Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.

 

Example 1:

Input: bloomDay = [1,10,3,10,2], m = 3, k = 1
Output: 3
Explanation: Let's see what happened in the first three days. x means flower bloomed and _ means flower didn't bloom in the garden.
We need 3 bouquets each should contain 1 flower.
After day 1: [x, _, _, _, _]   // we can only make one bouquet.
After day 2: [x, _, _, _, x]   // we can only make two bouquets.
After day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.
Example 2:

Input: bloomDay = [1,10,3,10,2], m = 3, k = 2
Output: -1
Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.
Example 3:

Input: bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
Output: 12
Explanation: We need 2 bouquets each should have 3 flowers.
Here's the garden after the 7 and 12 days:
After day 7: [x, x, x, x, _, x, x]
We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.
After day 12: [x, x, x, x, x, x, x]
It is obvious that we can make two bouquets in different ways.
Example 4:

Input: bloomDay = [1000000000,1000000000], m = 1, k = 1
Output: 1000000000
Explanation: You need to wait 1000000000 days to have a flower ready for a bouquet.
Example 5:

Input: bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
Output: 9
 

Constraints:

bloomDay.length == n
1 <= n <= 10^5
1 <= bloomDay[i] <= 10^9
1 <= m <= 10^6
1 <= k <= n

class Solution
{
public:
    int minDays(vector<int> &b, int m, int k)
    {
        int size = b.size();
        if(size < m * k)
            return -1;

        int low = *min_element(b.begin(), b.end());
        int high = *max_element(b.begin(), b.end());

        while(low < high)
        {
            int mid = low + (high - low) / 2;

            if(check(mid, b, m, k))
                high = mid;
            else
                low = mid + 1;
        }

        return low;
    }

    bool check(int day, vector<int> &b, int m, int k)
    {
        int flow = 0, bouq = 0;
        for(int i = 0; i < b.size(); i++)
        {
            if(b[i] <= day)
            {
                flow++;
                if(flow == k)
                {
                    bouq ++;
                    flow = 0;
                }
            }
            else
                flow = 0;
        }

        if(bouq >= m)
            return true;
        else
            return false;
    }
};


// Source https://leetcode.com/problems/kth-ancestor-of-a-tree-node/

You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. 
The root of the tree is node 0. Find the kth ancestor of a given node.

The kth ancestor of a tree node is the kth node in the path from that node to the root node.

Implement the TreeAncestor class:

TreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.
int getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.
 

Example 1:


Input
["TreeAncestor", "getKthAncestor", "getKthAncestor", "getKthAncestor"]
[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]
Output
[null, 1, 0, -1]

Explanation
TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);
treeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3
treeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5
treeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor
 

Constraints:

1 <= k <= n <= 5 * 104
parent.length == n
parent[0] == -1
0 <= parent[i] < n for all 0 < i < n
0 <= node < n
There will be at most 5 * 104 queries.

0->1->2->3->4->5->6->7->8->9->10

The 8th ancestor of node 10 = The 4th ancestor of node 6 (The 4th ancestor of node 10)
The 7th ancestor of node 10 = The 4th ancestor of node 7 (The 2th ancestor of node 9 (The 1th ancestor of node 10)  )

P
	0	1	2	3	4	5	6	7	8	9	10
0	-1	0	1	2	3	4	5	6	7	8	9
1	-1	-1	0	1	2	3	4	5	6	7	8
2	-1	-1	-1	-1	0	1	2	3	4	5	6
3	-1	-1	-1	-1	-1	-1	-1	-1	0	1	2
4	-1	-1	-1	-1	-1	-1	-1	-1	-1	-1	-1

class TreeAncestor
{
public:
    vector<vector<int> > P; // P[i][node] = node 's 2^i th parent
    TreeAncestor(int n, vector<int> &parent)
    {
        P.resize(20, vector<int>(parent.size(), -1));

        for(int i = 0; i < parent.size(); i++)
        {
            P[0][i] = parent[i];
        }

        for(int i = 1; i < 20; i++)
        {
            for(int node = 0; node < parent.size(); node ++)
            {
                int nodep = P[i - 1][node];
                if(nodep != -1) P[i][node] = P[i - 1][nodep];
            }
        }
    }

    int getKthAncestor(int node, int k)
    {
        for(int i = 0; i < 20; i++)
        {
            if(k & (1 << i))
            {
                node = P[i][node];
                if(node == -1) return -1;
            }
        }

        return node;
    }
};


// Source https://leetcode.com/problems/xor-operation-in-an-array/

Given an integer n and an integer start.

Define an array nums where nums[i] = start + 2*i (0-indexed) and n == nums.length.

Return the bitwise XOR of all elements of nums.

 

Example 1:

Input: n = 5, start = 0
Output: 8
Explanation: Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.
Where "^" corresponds to bitwise XOR operator.
Example 2:

Input: n = 4, start = 3
Output: 8
Explanation: Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.
Example 3:

Input: n = 1, start = 7
Output: 7
Example 4:

Input: n = 10, start = 5
Output: 2
 

Constraints:

1 <= n <= 1000
0 <= start <= 1000
n == nums.length

class Solution
{
public:
    int xorOperation(int n, int start)
    {
        int x = start;
        for(int i = 1; i < n; i++)
        {
            x ^= (start + (2 * i));
        }
        return x;
    }
};

// Source https://leetcode.com/problems/making-file-names-unique/

Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].

Since two files cannot have the same name, if you enter a folder name which is previously used, the system will have a suffix addition to its name in the form of (k), 
where, k is the smallest positive integer such that the obtained name remains unique.

Return an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.

 

Example 1:

Input: names = ["pes","fifa","gta","pes(2019)"]
Output: ["pes","fifa","gta","pes(2019)"]
Explanation: Let's see how the file system creates folder names:
"pes" --> not assigned before, remains "pes"
"fifa" --> not assigned before, remains "fifa"
"gta" --> not assigned before, remains "gta"
"pes(2019)" --> not assigned before, remains "pes(2019)"
Example 2:

Input: names = ["gta","gta(1)","gta","avalon"]
Output: ["gta","gta(1)","gta(2)","avalon"]
Explanation: Let's see how the file system creates folder names:
"gta" --> not assigned before, remains "gta"
"gta(1)" --> not assigned before, remains "gta(1)"
"gta" --> the name is reserved, system adds (k), since "gta(1)" is also reserved, systems put k = 2. it becomes "gta(2)"
"avalon" --> not assigned before, remains "avalon"
Example 3:

Input: names = ["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece"]
Output: ["onepiece","onepiece(1)","onepiece(2)","onepiece(3)","onepiece(4)"]
Explanation: When the last folder is created, the smallest positive valid k is 4, and it becomes "onepiece(4)".
Example 4:

Input: names = ["wano","wano","wano","wano"]
Output: ["wano","wano(1)","wano(2)","wano(3)"]
Explanation: Just increase the value of k each time you create folder "wano".
Example 5:

Input: names = ["kaido","kaido(1)","kaido","kaido(1)"]
Output: ["kaido","kaido(1)","kaido(2)","kaido(1)(1)"]
Explanation: Please note that system adds the suffix (k) to current name even it contained the same suffix before.
 

Constraints:

1 <= names.length <= 5 * 10^4
1 <= names[i].length <= 20
names[i] consists of lower case English letters, digits and/or round brackets.

class Solution
{
public:
    vector<string> getFolderNames(vector<string> &names)
    {
        int n = names.size();
        unordered_map<string, int> mp;
        vector<string>res;
        for(int i = 0; i < n; i++)
        {
            if(mp.find(names[i]) != mp.end())
            {
                string check = names[i] + '(' + to_string(mp[names[i]]) + ')';
                while(mp.find(check) != mp.end())
                {
                    mp[names[i]]++;
                    check = names[i] + '(' + to_string(mp[names[i]]) + ')';
                }
                res.push_back(check);
                mp[check]++;
                mp[names[i]]++;
            }
            else
            {
                res.push_back(names[i]);
                mp[names[i]]++;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/avoid-flood-in-the-city/

Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the nth lake, the nth lake becomes full of water. 
If it rains over a lake which is full of water, there will be a flood. Your goal is to avoid the flood in any lake.

Given an integer array rains where:

rains[i] > 0 means there will be rains over the rains[i] lake.
rains[i] == 0 means there are no rains this day and you can choose one lake this day and dry it.
Return an array ans where:

ans.length == rains.length
ans[i] == -1 if rains[i] > 0.
ans[i] is the lake you choose to dry in the ith day if rains[i] == 0.
If there are multiple valid answers return any of them. If it is impossible to avoid flood return an empty array.

Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes. (see example 4)

 

Example 1:

Input: rains = [1,2,3,4]
Output: [-1,-1,-1,-1]
Explanation: After the first day full lakes are [1]
After the second day full lakes are [1,2]
After the third day full lakes are [1,2,3]
After the fourth day full lakes are [1,2,3,4]
There's no day to dry any lake and there is no flood in any lake.
Example 2:

Input: rains = [1,2,0,0,2,1]
Output: [-1,-1,2,1,-1,-1]
Explanation: After the first day full lakes are [1]
After the second day full lakes are [1,2]
After the third day, we dry lake 2. Full lakes are [1]
After the fourth day, we dry lake 1. There is no full lakes.
After the fifth day, full lakes are [2].
After the sixth day, full lakes are [1,2].
It is easy that this scenario is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario.
Example 3:

Input: rains = [1,2,0,1,2]
Output: []
Explanation: After the second day, full lakes are  [1,2]. We have to dry one lake in the third day.
After that, it will rain over lakes [1,2]. It's easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood.
Example 4:

Input: rains = [69,0,0,0,69]
Output: [-1,69,1,1,-1]
Explanation: Any solution on one of the forms [-1,69,x,y,-1], [-1,x,69,y,-1] or [-1,x,y,69,-1] is acceptable where 1 <= x,y <= 10^9
Example 5:

Input: rains = [10,20,20]
Output: []
Explanation: It will rain over lake 20 two consecutive days. There is no chance to dry any lake.
 

Constraints:

1 <= rains.length <= 105
0 <= rains[i] <= 109

class Solution
{
public:
    vector<int> avoidFlood(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> ans(n, -1);
        set<int> s;
        unordered_map<int, int> mp;
        for(int i = 0; i < n; i++)
        {
            if(nums[i] == 0)
            {
                s.insert(i);
                ans[i] = 19;
            }
            else
            {
                if(mp.find(nums[i]) != mp.end())
                {
                    int index = mp[nums[i]];
                    auto it = s.lower_bound(index);
                    if(it == s.end())
                    {
                        return {};
                    }
                    ans[*it] = nums[i];
                    s.erase(it);
                }
                mp[nums[i]] = i;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/

Given a weighted undirected connected graph with n vertices numbered from 0 to n - 1, 
and an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional and weighted edge between nodes ai and bi. 
A minimum spanning tree (MST) is a subset of the graph's edges that connects all vertices without cycles and with the minimum possible total edge weight.

Find all the critical and pseudo-critical edges in the given graph's minimum spanning tree (MST). 
An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. 
On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.

Note that you can return the indices of the edges in any order.

 

Example 1:



Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
Output: [[0,1],[2,3,4,5]]
Explanation: The figure above describes the graph.
The following figure shows all the possible MSTs:

Notice that the two edges 0 and 1 appear in all MSTs, therefore they are critical edges, so we return them in the first list of the output.
The edges 2, 3, 4, and 5 are only part of some MSTs, therefore they are considered pseudo-critical edges. We add them to the second list of the output.
Example 2:



Input: n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
Output: [[],[0,1,2,3]]
Explanation: We can observe that since all 4 edges have equal weight, choosing any 3 edges from the given 4 will yield an MST. Therefore all 4 edges are pseudo-critical.
 

Constraints:

2 <= n <= 100
1 <= edges.length <= min(200, n * (n - 1) / 2)
edges[i].length == 3
0 <= ai < bi < n
1 <= weighti <= 1000
All pairs (ai, bi) are distinct.

class UnionFind
{
public:
    vector<int> parent;
    UnionFind(int n)
    {
        parent.resize(n);
        for(int i = 0; i < n; i++)
            parent[i] = i;
    }

    int findParent(int p)
    {
        return parent[p] == p ? p : parent[p] = findParent(parent[p]);
    }

    void Union(int u, int v)
    {
        int pu = findParent(u), pv = findParent(v);
        parent[pu] = pv;
    }
};

class Solution
{
public:
    static bool cmp(vector<int> &a, vector<int> &b)
    {
        return a[2] < b[2];
    }

    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>> &edges)
    {
        vector<int> critical,  pscritical ;

        for(int i = 0; i < edges.size(); i++)
            edges[i].push_back(i);

        sort(edges.begin(), edges.end(), cmp) ;

        int mstwt = findMST(n, edges, -1, -1);
        for(int i = 0; i < edges.size(); i++)
        {
            if(mstwt < findMST(n, edges, i, -1))
                critical.push_back(edges[i][3]);
            else if(mstwt == findMST(n, edges, -1, i))
                pscritical.push_back(edges[i][3]);
        }
        return {critical, pscritical};
    }

private:
    int findMST(int n,  vector<vector<int>> &edges, int block, int e)
    {
        UnionFind uf(n);
        int weight = 0 ;
        if(e != -1)
        {
            weight += edges[e][2];
            uf.Union(edges[e][0], edges[e][1]);
        }

        for(int i = 0; i < edges.size(); i++)
        {
            if(i == block)
                continue;
            if(uf.findParent(edges[i][0]) == uf.findParent(edges[i][1]))
                continue;
            uf.Union(edges[i][0], edges[i][1]);
            weight += edges[i][2];
        }

        for(int i = 0; i < n; i++)
        {
            if(uf.findParent(i) != uf.findParent(0))
                return INT_MAX;
        }

        return weight;
    }
};

// Source https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/

Given an array of unique integers salary where salary[i] is the salary of the employee i.

Return the average salary of employees excluding the minimum and maximum salary.

 

Example 1:

Input: salary = [4000,3000,1000,2000]
Output: 2500.00000
Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
Average salary excluding minimum and maximum salary is (2000+3000)/2= 2500
Example 2:

Input: salary = [1000,2000,3000]
Output: 2000.00000
Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.
Average salary excluding minimum and maximum salary is (2000)/1= 2000
Example 3:

Input: salary = [6000,5000,4000,3000,2000,1000]
Output: 3500.00000
Example 4:

Input: salary = [8000,9000,2000,3000,6000,1000]
Output: 4750.00000
 

Constraints:

3 <= salary.length <= 100
10^3 <= salary[i] <= 10^6
salary[i] is unique.
Answers within 10^-5 of the actual value will be accepted as correct.

class Solution
{
public:
    double average(vector<int> &salary)
    {
        sort(salary.begin(), salary.end());
        double sum = 0;
        double avg;
        int n = salary.size();
        if(n == 2)
        {
            return 0;
        }
        for(int i = 1; i < n - 1; i++)
        {
            sum = sum + salary[i];
        }
        avg = sum / (n - 2);
        return avg;
    }
};

// Source https://leetcode.com/problems/the-kth-factor-of-n/

Given two positive integers n and k.

A factor of an integer n is defined as an integer i where n % i == 0.

Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.

 

Example 1:

Input: n = 12, k = 3
Output: 3
Explanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.
Example 2:

Input: n = 7, k = 2
Output: 7
Explanation: Factors list is [1, 7], the 2nd factor is 7.
Example 3:

Input: n = 4, k = 4
Output: -1
Explanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.
Example 4:

Input: n = 1, k = 1
Output: 1
Explanation: Factors list is [1], the 1st factor is 1.
Example 5:

Input: n = 1000, k = 3
Output: 4
Explanation: Factors list is [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000].
 

Constraints:

1 <= k <= n <= 1000

class Solution
{
public:

    int kthFactor(int n, int k)
    {
        vector<int> result;
        for(int i = 1; i * i <= n; i++)
        {
            if(n % i == 0)
            {
                result.push_back(i);
                if(i != n / i)
                    result.push_back(n / i);
            }
        }
        sort(result.begin(), result.end());
        if(k <= result.size())
        {
            return result[k - 1];
        }
        return -1;
    }
};

// Source https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/

Given a binary array nums, you should delete one element from it.

Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.

 

Example 1:

Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.
Example 2:

Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].
Example 3:

Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.
Example 4:

Input: nums = [1,1,0,0,1,1,1,0,1]
Output: 4
Example 5:

Input: nums = [0,0,0]
Output: 0
 

Constraints:

1 <= nums.length <= 105
nums[i] is either 0 or 1.

class Solution
{
public:
    int longestSubarray(vector<int> &a)
    {
        int z = 0, i = 0, j = 0, ans = 0, n = a.size();

        while(j < n)
        {
            if(a[j] == 1)
            {
                j++;
            }
            else
            {
                z++;
                while(i<j && z>1)
                {
                    if(a[i] == 0)
                        z--;
                    i++;
                }
                j++;
            }
            ans = max(ans, j - i - 1);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/parallel-courses-ii/

You are given an integer n, which indicates that there are n courses labeled from 1 to n. 
You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], 
representing a prerequisite relationship between course prevCoursei and course nextCoursei: 
course prevCoursei has to be taken before course nextCoursei. Also, you are given the integer k.

In one semester, you can take at most k courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.

Return the minimum number of semesters needed to take all courses. The testcases will be generated such that it is possible to take every course.

 

Example 1:



Input: n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2
Output: 3 
Explanation: The figure above represents the given graph.
In the first semester, you can take courses 2 and 3.
In the second semester, you can take course 1.
In the third semester, you can take course 4.
Example 2:



Input: n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2
Output: 4 
Explanation: The figure above represents the given graph.
In the first semester, you can take courses 2 and 3 only since you cannot take more than two per semester.
In the second semester, you can take course 4.
In the third semester, you can take course 1.
In the fourth semester, you can take course 5.
Example 3:

Input: n = 11, dependencies = [], k = 2
Output: 6
 

Constraints:

1 <= n <= 15
1 <= k <= n
0 <= relations.length <= n * (n-1) / 2
relations[i].length == 2
1 <= prevCoursei, nextCoursei <= n
prevCoursei != nextCoursei
All the pairs [prevCoursei, nextCoursei] are unique.
The given graph is a directed acyclic graph.

deps[i] 记录 课程 i + 1 的前置课程有哪些
dp[s] 表示上一学期n courses的选择状态是否可以为s
tmp[s] 表示当前学期n courses的选择状态是否可以为s

class Solution
{
public:
    int minNumberOfSemesters(int n, vector<vector<int>> &relations, int k)
    {
        vector<int> deps(n, 0);
        for(auto &r : relations)
            deps[r[1] - 1] |= 1 << (r[0] - 1);

        int S = 1 << n;
        vector<bool> dp(S, false);
        dp[0] = true;
        for(int r = 1; r <= n; r++)
        {
            vector<bool> tmp(S, false);
            for(int s = 0; s < S; s++)
            {
                if(!dp[s]) continue;
                int mask = 0;
                for(int i = 0; i < n; i++)
                {
                    if((s & (1 << i))) continue;
                    if((s & deps[i]) != deps[i]) continue;
                    mask |= (1 << i);
                }
                if(__builtin_popcount(mask) <= k)
                {
                    tmp[s | mask] = true;
                }
                else
                {
                    for(int c = mask; c; c = (c - 1)&mask)
                    {
                        if(__builtin_popcount(c) == k)
                            tmp[s | c] = true;
                    }
                }
                if(tmp.back()) return r;
            }
            dp.swap(tmp);
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/path-crossing/

Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. 
You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.

Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.

 

Example 1:


Input: path = "NES"
Output: false 
Explanation: Notice that the path doesn't cross any point more than once.
Example 2:


Input: path = "NESWW"
Output: true
Explanation: Notice that the path visits the origin twice.
 

Constraints:

1 <= path.length <= 104
path[i] is either 'N', 'S', 'E', or 'W'.

class Solution
{
public:
    bool isPathCrossing(string path)
    {
        set<pair<int, int>>s;
        pair<int, int>a = {0, 0};
        s.insert({0, 0});
        for(int i = 0; i < path.size(); i++)
        {
            if(path[i] == 'N')
            {
                a.second++;
            }
            else if(path[i] == 'E')
            {
                a.first++;
            }
            else  if(path[i] == 'W')
            {
                a.first--;
            }
            else
            {
                a.second--;
            }
            if(s.find(a) == s.end())
                s.insert(a);
            else
                return true;
        }
        return false;
    }
};

// Source https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/

Given an array of integers arr of even length n and an integer k.

We want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k.

Return True If you can find a way to do that or False otherwise.

 

Example 1:

Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5
Output: true
Explanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10).
Example 2:

Input: arr = [1,2,3,4,5,6], k = 7
Output: true
Explanation: Pairs are (1,6),(2,5) and(3,4).
Example 3:

Input: arr = [1,2,3,4,5,6], k = 10
Output: false
Explanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.
Example 4:

Input: arr = [-10,10], k = 2
Output: true
Example 5:

Input: arr = [-1,1,-2,2,-3,3,-4,4], k = 3
Output: true
 

Constraints:

arr.length == n
1 <= n <= 105
n is even.
-109 <= arr[i] <= 109
1 <= k <= 105

class Solution
{
public:
    bool canArrange(vector<int> &arr, int k)
    {
        unordered_map<int, int> mp;

        for (int x : arr) mp[(x % k + k ) % k]++;

        for (int x : arr)
        {
            int rem = (x % k  + k ) % k;
            if (rem == 0)
            {
                if (mp[rem] % 2 == 1) return false;
            }
            else if (mp[rem] != mp[k - rem]) return false;
        }

        return true;
    }
};


// Source https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/

Given an array of integers nums and an integer target.

Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. 
Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: nums = [3,5,6,7], target = 9
Output: 4
Explanation: There are 4 subsequences that satisfy the condition.
[3] -> Min value + max value <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)
Example 2:

Input: nums = [3,3,6,8], target = 10
Output: 6
Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
Example 3:

Input: nums = [2,3,3,4,6,7], target = 12
Output: 61
Explanation: There are 63 non-empty subsequences, two of them don't satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).
Example 4:

Input: nums = [5,2,4,1,7,6,8], target = 16
Output: 127
Explanation: All non-empty subset satisfy the condition (2^7 - 1) = 127
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 106
1 <= target <= 106

先对nums排序
如果nums[i] + nums[j] <= target，则
2^(j - i -1)个nums[i] ... nums[j]子序列满足要求（同时包含nums[i]和nums[j]）
2^(j - i -1)个nums[i] ... 子序列满足要求（只包含nums[i]）
总共有2^(j - i)个子序列满足要求

class Solution
{
public:
    int numSubseq(vector<int> &nums, int target)
    {
        int mod = 1000000007;

        int n = nums.size();
        sort(nums.begin(), nums.end());

        vector<int> power = {1};
        for(int i = 1; i < n; i++)
        {
            power.push_back((power.back() << 1) % mod);
        }

        int res = 0;

        int j = n - 1;
        for(int i = 0; i <= j; i++)
        {
            while(nums[i] + nums[j] > target && i < j) j--;

            if(nums[i] + nums[j] <= target)
            {
                res = (res % mod + power[j - i] % mod) % mod;
            }
        }

        return res;
    }
};


// Source https://leetcode.com/problems/max-value-of-equation/

You are given an array points containing the coordinates of points on a 2D plane, sorted by the x-values, 
where points[i] = [xi, yi] such that xi < xj for all 1 <= i < j <= points.length. You are also given an integer k.

Return the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| <= k and 1 <= i < j <= points.length.

It is guaranteed that there exists at least one pair of points that satisfy the constraint |xi - xj| <= k.

 

Example 1:

Input: points = [[1,3],[2,0],[5,10],[6,-10]], k = 1
Output: 4
Explanation: The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. 
Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.
No other pairs satisfy the condition, so we return the max of 4 and 1.
Example 2:

Input: points = [[0,0],[3,0],[9,2]], k = 3
Output: 3
Explanation: Only the first two points have an absolute difference of 3 or less in the x-values, and give the value of 0 + 0 + |0 - 3| = 3.
 

Constraints:

2 <= points.length <= 105
points[i].length == 2
-108 <= xi, yi <= 108
0 <= k <= 2 * 108
xi < xj for all 1 <= i < j <= points.length
xi form a strictly increasing sequence.

yi + yj + |xi - xj| = yi - xi + yj + xj

class Solution
{
public:
    int findMaxValueOfEquation(vector<vector<int>> &points, int k)
    {
        int ans = INT_MIN;
        int n = points.size();
        priority_queue<pair<int, int>> p;
        for(int i = 0 ; i < n; i++)
        {
            while((!p.empty()) && (points[i][0] - p.top().second > k)) p.pop();
            if(!p.empty())
            {
                ans = max(ans, p.top().first + points[i][0] + points[i][1]);
            }
            p.push({points[i][1] - points[i][0], points[i][0]});
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/

A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.

Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.

 

Example 1:

Input: arr = [3,5,1]
Output: true
Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.
Example 2:

Input: arr = [1,2,4]
Output: false
Explanation: There is no way to reorder the elements to obtain an arithmetic progression.
 

Constraints:

2 <= arr.length <= 1000
-106 <= arr[i] <= 106

class Solution
{
public:
    bool canMakeArithmeticProgression(vector<int> &arr)
    {
        int n = arr.size();
        sort(arr.begin(), arr.end());
        int dif = arr[0] - arr[1];
        for(int i = 1; i < n - 1; i++)
        {
            if(arr[i] - arr[i + 1] != dif)
                return false;
        }
        return true;
    }
};

// Source https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/

We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with speed 1 unit per second. 
Some of the ants move to the left, the other move to the right.

When two ants moving in two different directions meet at some point, they change their directions and continue moving again. 
Assume changing directions doesn't take any additional time.

When an ant reaches one end of the plank at a time t, it falls out of the plank imediately.

Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right. 
Return the moment when the last ant(s) fall out of the plank.

 

Example 1:


Input: n = 4, left = [4,3], right = [0,1]
Output: 4
Explanation: In the image above:
-The ant at index 0 is named A and going to the right.
-The ant at index 1 is named B and going to the right.
-The ant at index 3 is named C and going to the left.
-The ant at index 4 is named D and going to the left.
Note that the last moment when an ant was on the plank is t = 4 second, after that it falls imediately out of the plank. (i.e. We can say that at t = 4.0000000001, there is no ants on the plank).
Example 2:


Input: n = 7, left = [], right = [0,1,2,3,4,5,6,7]
Output: 7
Explanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.
Example 3:


Input: n = 7, left = [0,1,2,3,4,5,6,7], right = []
Output: 7
Explanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall.
Example 4:

Input: n = 9, left = [5], right = [4]
Output: 5
Explanation: At t = 1 second, both ants will be at the same intial position but with different direction.
Example 5:

Input: n = 6, left = [6], right = [0]
Output: 6
 

Constraints:

1 <= n <= 10^4
0 <= left.length <= n + 1
0 <= left[i] <= n
0 <= right.length <= n + 1
0 <= right[i] <= n
1 <= left.length + right.length <= n + 1
All values of left and right are unique, and each value can appear only in one of the two arrays.

两只蚂蚁相遇后同时转变方向等同于两只蚂蚁相遇后各自穿过对方继续沿着原来的方向

class Solution
{
public:
    int getLastMoment(int n, vector<int> &left, vector<int> &right)
    {
        int ans = 0;
        for(auto it : left) ans = max(ans, it);
        for(auto it : right) ans = max(ans, n - it);
        return ans;
    }
};


// Source https://leetcode.com/problems/count-submatrices-with-all-ones/

Given an m x n binary matrix mat, return the number of submatrices that have all ones.

 

Example 1:


Input: mat = [[1,0,1],[1,1,0],[1,1,0]]
Output: 13
Explanation: 
There are 6 rectangles of side 1x1.
There are 2 rectangles of side 1x2.
There are 3 rectangles of side 2x1.
There is 1 rectangle of side 2x2. 
There is 1 rectangle of side 3x1.
Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.
Example 2:


Input: mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
Output: 24
Explanation: 
There are 8 rectangles of side 1x1.
There are 5 rectangles of side 1x2.
There are 2 rectangles of side 1x3. 
There are 4 rectangles of side 2x1.
There are 2 rectangles of side 2x2. 
There are 2 rectangles of side 3x1. 
There is 1 rectangle of side 3x2. 
Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.
 

Constraints:

1 <= m, n <= 150
mat[i][j] is either 0 or 1.

h[j] 表示以第i行的第j列为起点，往上连续为1的个数
idx[j] 表示以第i行的第j列为起点，往左满足h[k]小于h[j]的第一个k
dp[j] 表示以第i行的第j列为右下角，所有单元格全为1的子矩形数量

class Solution
{
public:
    int numSubmat(vector<vector<int>> &mat)
    {
        int m = mat.size(), n = mat[0].size(), ans = 0;
        vector<int> h(n), idx(n), dp(n);
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                h[j] = mat[i][j] ? h[j] + 1 : 0;
                idx[j] = j - 1;
                for (; idx[j] != -1 && h[idx[j]] >= h[j]; idx[j] = idx[idx[j]]);
                dp[j] = h[j] * (j - idx[j]);
                dp[j] += (idx[j] >= 0 ? dp[idx[j]] : 0);
                ans += dp[j];
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/

Given a string num representing the digits of a very large integer and an integer k.

You are allowed to swap any two adjacent digits of the integer at most k times.

Return the minimum integer you can obtain also as a string.

 

Example 1:


Input: num = "4321", k = 4
Output: "1342"
Explanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.
Example 2:

Input: num = "100", k = 1
Output: "010"
Explanation: It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.
Example 3:

Input: num = "36789", k = 1000
Output: "36789"
Explanation: We can keep the number without any swaps.
Example 4:

Input: num = "22", k = 22
Output: "22"
Example 5:

Input: num = "9438957234785635408", k = 23
Output: "0345989723478563548"
 

Constraints:

1 <= num.length <= 30000
num contains digits only and doesn't have leading zeros.
1 <= k <= 10^9

i ... m ... j
假设要把num[j]对应的数移动到num[i]（i < j 且 num[j] < num[i]）
如果之前已经有m个[i ... j]中间的数移动到了前方，则此时需要 j - i - m 次移动就可以把num[j]对应的数移动到num[i]
使用树状数组记录发生移动的坐标位置

class FenwickTree
{
public:
    explicit FenwickTree(int size)
        : arr(size + 1, 0)
    {
    }

    int get(int index)
    {
        ++index;
        int value = 0;

        while (index)
        {
            value += arr[index];
            index -= index & (-index);
        }

        return value;
    }

    void set(int index)
    {
        ++index;

        while (index < arr.size())
        {
            ++arr[index];
            index += index & (-index);
        }
    }

private:
    vector<int> arr;
};

class Solution
{
public:
    string minInteger(string num, int k)
    {
        vector<deque<int>> indexes(10, deque<int>());
        string result;
        FenwickTree tree(num.size());

        for (int i = 0; i < num.size(); ++i)
            indexes[num[i] - '0'].push_back(i);

        for (int i = 0; i < num.size(); ++i)
        {
            auto digit = num[i] - '0';

            if (indexes[digit].empty() || indexes[digit].front() != i)
                continue;

            indexes[digit].pop_front();

            for (int d = 0; d < digit; ++d)
            {
                if (!indexes[d].empty() && indexes[d].front() > i)
                {
                    int temp = indexes[d].front() - i - tree.get(indexes[d].front()) + tree.get(i);
                    if (temp > 0 && temp <= k)
                    {
                        k -= temp;
                        tree.set(indexes[d].front());
                        indexes[d].pop_front();
                        result += (char)(d-- + '0');
                    }
                }
            }

            result += num[i];
        }

        return result;
    }
};


// Source https://leetcode.com/problems/reformat-date/

Given a date string in the form Day Month Year, where:

Day is in the set {"1st", "2nd", "3rd", "4th", ..., "30th", "31st"}.
Month is in the set {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}.
Year is in the range [1900, 2100].
Convert the date string to the format YYYY-MM-DD, where:

YYYY denotes the 4 digit year.
MM denotes the 2 digit month.
DD denotes the 2 digit day.
 

Example 1:

Input: date = "20th Oct 2052"
Output: "2052-10-20"
Example 2:

Input: date = "6th Jun 1933"
Output: "1933-06-06"
Example 3:

Input: date = "26th May 1960"
Output: "1960-05-26"
 

Constraints:

The given dates are guaranteed to be valid, so no error handling is necessary.

class Solution
{
public:
    string convert_mon(string s)
    {
        if (s == "Jan")
            return "01";

        if (s == "Feb")
            return "02";

        if (s == "Mar")
            return "03";

        if (s == "Apr")
            return "04";

        if (s == "May")
            return "05";

        if (s == "Jun")
            return "06";

        if (s == "Jul")
            return "07";

        if (s == "Aug")
            return "08";

        if (s == "Sep")
            return "09";

        if (s == "Oct")
            return "10";

        if (s == "Nov")
            return "11";

        if (s == "Dec")
            return "12";

        return "";
    }

    string convert_date(string s)
    {
        if (s.size() == 3)
        {
            string str;
            str += '0';
            str += s[0];
            return str;
        }

        string str;
        str += s[0];
        str += s[1];
        return str;
    }

    string reformatDate(string date)
    {
        vector<string> v;
        string str;
        for (auto i : date)
        {
            if (i == ' ')
            {
                v.push_back(str);
                str.clear();
            }
            else
            {
                str += i;
            }
        }
        v.push_back(str);
        reverse(v.begin(), v.end());
        date.clear();

        v[1] = convert_mon(v[1]);
        v[2] = convert_date(v[2]);

        for (auto i : v)
        {
            date += i + '-';
        }
        date.pop_back();

        return date;
    }
};


// Source https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/

You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array 
and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.

Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.

 

Example 1:

Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
Output: 13 
Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. 
The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 
Example 2:

Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
Output: 6
Explanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.
Example 3:

Input: nums = [1,2,3,4], n = 4, left = 1, right = 10
Output: 50
 

Constraints:

n == nums.length
1 <= nums.length <= 1000
1 <= nums[i] <= 100
1 <= left <= right <= n * (n + 1) / 2

class Solution
{
public:
    int rangeSum(vector<int> &a, int n, int l, int r)
    {
        vector<int> v;
        for(int i = 0; i < n; i++)
        {
            int temp = 0;
            for(int j = i; j < n; j++)
            {
                temp += a[j];
                v.push_back(temp);
            }
        }
        sort(begin(v), end(v));
        unsigned long long res = 0;
        for(int i = l - 1; i < r; i++)
        {
            res += v[i];
        }
        return res % 1000000007;
    }
};


// Source https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/

Given an array nums, you are allowed to choose one element of nums and change it by any value in one move.

Return the minimum difference between the largest and smallest value of nums after perfoming at most 3 moves.

 

Example 1:

Input: nums = [5,3,2,4]
Output: 0
Explanation: Change the array [5,3,2,4] to [2,2,2,2].
The difference between the maximum and minimum is 2-2 = 0.
Example 2:

Input: nums = [1,5,0,10,14]
Output: 1
Explanation: Change the array [1,5,0,10,14] to [1,1,0,1,1]. 
The difference between the maximum and minimum is 1-0 = 1.
Example 3:

Input: nums = [6,6,0,1,1,4,6]
Output: 2
Example 4:

Input: nums = [1,5,6,14,15]
Output: 1
 

Constraints:

1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9

4种选择
最大的3个缩小
最大的2个缩小，最小的1个增大
最大的1个缩小，最小的2个增大
最小的3个增大

class Solution
{
public:
    int minDifference(vector<int> &nums)
    {
        if (nums.size() <= 4)
        {
            return 0;
        }

        sort(nums.begin(), nums.end());

        int end = nums.size() - 1;
        int low = nums[end - 3] - nums[0];
        low = min(low, nums[end - 2] - nums[1]);
        low = min(low, nums[end - 1] - nums[2]);
        low = min(low, nums[end] - nums[3]);

        return low;
    }
};


// Source https://leetcode.com/problems/stone-game-iv/

Alice and Bob take turns playing a game, with Alice starting first.

Initially, there are n stones in a pile.  On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.

Also, if a player cannot make a move, he/she loses the game.

Given a positive integer n. Return True if and only if Alice wins the game otherwise return False, assuming both players play optimally.

 

Example 1:

Input: n = 1
Output: true
Explanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves.
Example 2:

Input: n = 2
Output: false
Explanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).
Example 3:

Input: n = 4
Output: true
Explanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).
Example 4:

Input: n = 7
Output: false
Explanation: Alice can't win the game if Bob plays optimally.
If Alice starts removing 4 stones, Bob will remove 1 stone then Alice should remove only 1 stone and finally Bob removes the last one (7 -> 3 -> 2 -> 1 -> 0). 
If Alice starts removing 1 stone, Bob will remove 4 stones then Alice only can remove 1 stone and finally Bob removes the last one (7 -> 6 -> 2 -> 1 -> 0).
Example 5:

Input: n = 17
Output: false
Explanation: Alice can't win the game if Bob plays optimally.
 

Constraints:

1 <= n <= 10^5

dp[i] 表示当前剩余n个石头，Alice或Bob是否会赢

class Solution
{
public:
    int dp[100005];

    int func(int n)
    {
        if(n <= 0)
        {
            return 0;
        }

        if(dp[n] != -1)
        {
            return dp[n];
        }

        for(int i = 1; i * i <= n; i++)
        {
            if(func(n - i * i) == 0)
            {
                return dp[n] = 1;
            }
        }

        return dp[n] = 0;
    }

    bool winnerSquareGame(int n)
    {
        memset(dp, -1, sizeof(dp));

        return func(n);
    }
};


// Source https://leetcode.com/problems/number-of-good-pairs/

Given an array of integers nums, return the number of good pairs.

A pair (i, j) is called good if nums[i] == nums[j] and i < j.

 

Example 1:

Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
Example 2:

Input: nums = [1,1,1,1]
Output: 6
Explanation: Each pair in the array are good.
Example 3:

Input: nums = [1,2,3]
Output: 0
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100

class Solution
{
public:
    int numIdenticalPairs(vector<int> &nums)
    {
        unordered_map<int, int> m;
        int n = nums.size();
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            if(m[nums[i]] > 0)
                ans += m[nums[i]];
            m[nums[i]]++;
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/number-of-substrings-with-only-1s/

Given a binary string s, return the number of substrings with all characters 1's. 
Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: s = "0110111"
Output: 9
Explanation: There are 9 substring in total with only 1's characters.
"1" -> 5 times.
"11" -> 3 times.
"111" -> 1 time.
Example 2:

Input: s = "101"
Output: 2
Explanation: Substring "1" is shown 2 times in s.
Example 3:

Input: s = "111111"
Output: 21
Explanation: Each substring contains only 1's characters.
Example 4:

Input: s = "000"
Output: 0
 

Constraints:

1 <= s.length <= 105
s[i] is either '0' or '1'.

class Solution
{
public:
    int numSub(string s)
    {
        int n = s.size();
        int i = 0;
        int j = 0;
        int count = 0;
        while(j < n)
        {
            if(s[j] == '1')
            {
                count = (count + (j - i + 1)) % 1000000007;
            }
            else
            {
                i = j + 1;;
            }
            j++;
        }
        return count;
    }
};


// Source https://leetcode.com/problems/path-with-maximum-probability/

You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list 
where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].

Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.

If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.

 

Example 1:



Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
Output: 0.25000
Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.
Example 2:



Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
Output: 0.30000
Example 3:



Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
Output: 0.00000
Explanation: There is no path between 0 and 2.
 

Constraints:

2 <= n <= 10^4
0 <= start, end < n
start != end
0 <= a, b < n
a != b
0 <= succProb.length == edges.length <= 2*10^4
0 <= succProb[i] <= 1
There is at most one edge between every two nodes.

class Solution
{
public:
    double maxProbability(int n, vector<vector<int>> &edges, vector<double> &succProb, int start, int end)
    {
        vector<vector<pair<int, double>>> g(n);
        for(int i = 0; i < edges.size(); i++)
        {
            g[edges[i][0]].push_back({edges[i][1], succProb[i]});
            g[edges[i][1]].push_back({edges[i][0], succProb[i]});
        }

        priority_queue<pair<double, int>> pq;
        vector<double> prob(n, 0);
        prob[start] = 1;
        pq.push({1.0, start});
        while(!pq.empty())
        {
            int u = pq.top().second;
            pq.pop();
            for(auto v : g[u])
            {
                double p = v.second;
                int node = v.first;
                if(prob[node] < prob[u]*p)
                {
                    prob[node] = prob[u] * p;
                    pq.push({prob[u]*p, node});
                }
            }
        }
        return prob[end];
    }
};


// Source https://leetcode.com/problems/best-position-for-a-service-centre/

A delivery company wants to build a new service centre in a new city. The company knows the positions of all the customers in this city on a 2D-Map 
and wants to build the new centre in a position such that the sum of the euclidean distances to all customers is minimum.

Given an array positions where positions[i] = [xi, yi] is the position of the ith customer on the map, return the minimum sum of the euclidean distances to all customers.

In other words, you need to choose the position of the service centre [xcentre, ycentre] such that the following formula is minimized:
sumof(sqrt((xcentre - xi)^2 + (ycentre - yi)^2))

Answers within 10^-5 of the actual value will be accepted.

 

Example 1:


Input: positions = [[0,1],[1,0],[1,2],[2,1]]
Output: 4.00000
Explanation: As shown, you can see that choosing [xcentre, ycentre] = [1, 1] will make the distance to each customer = 1, 
the sum of all distances is 4 which is the minimum possible we can achieve.
Example 2:


Input: positions = [[1,1],[3,3]]
Output: 2.82843
Explanation: The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843
Example 3:

Input: positions = [[1,1]]
Output: 0.00000
Example 4:

Input: positions = [[1,1],[0,0],[2,0]]
Output: 2.73205
Explanation: At the first glance, you may think that locating the centre at [1, 0] will achieve the minimum sum, but locating it at [1, 0] will make the sum of distances = 3.
Try to locate the centre at [1.0, 0.5773502711] you will see that the sum of distances is 2.73205.
Be careful with the precision!
Example 5:

Input: positions = [[0,1],[3,2],[4,5],[7,6],[8,9],[11,1],[2,12]]
Output: 32.94036
Explanation: You can use [4.3460852395, 4.9813795505] as the position of the centre.
 

Constraints:

1 <= positions.length <= 50
positions[i].length == 2
0 <= positions[i][0], positions[i][1] <= 100

class Solution
{
public:
    double dist(const vector<double> &center, vector<vector<int>> &points)
    {
        double sum = 0;

        for(auto &point : points)
        {
            sum += sqrt((point[0] - center[0]) * (point[0] - center[0]) +
                        (point[1] - center[1]) * (point[1] - center[1]));
        }

        return sum;
    };

    double getMinDistSum(vector<vector<int>> &positions)
    {
        constexpr double kDelta = 1e-6;
        int n = positions.size();
        vector<double> center(2, 0.0);
        for(auto &pos : positions)
        {
            center[0] += pos[0];
            center[1] += pos[1];
        }
        center[0] = center[0] / n;
        center[1] = center[1] / n;
        double minDist = dist(center, positions);

        double step = 1.0;
        while(step > kDelta)
        {
            bool reduceStep = true;
            for(int y = -1; y <= 1; y++)
            {
                for(int x = -1; x <= 1; x++)
                {
                    if (abs(y) + abs(x) != 1)
                        continue;

                    double curX = center[0] + x * step;
                    double curY = center[1] + y * step;
                    double newDist = dist({curX, curY}, positions);
                    if (newDist < minDist)
                    {
                        minDist = newDist;
                        reduceStep = false;
                        center[0] = curX;
                        center[1] = curY;
                    }
                }
            }
            if (reduceStep)
            {
                step /= 10.0;
            }
        }
        return minDist;
    }
};


// Source https://leetcode.com/problems/water-bottles/

Given numBottles full water bottles, you can exchange numExchange empty water bottles for one full water bottle.

The operation of drinking a full water bottle turns it into an empty bottle.

Return the maximum number of water bottles you can drink.

 

Example 1:



Input: numBottles = 9, numExchange = 3
Output: 13
Explanation: You can exchange 3 empty bottles to get 1 full water bottle.
Number of water bottles you can drink: 9 + 3 + 1 = 13.
Example 2:



Input: numBottles = 15, numExchange = 4
Output: 19
Explanation: You can exchange 4 empty bottles to get 1 full water bottle. 
Number of water bottles you can drink: 15 + 3 + 1 = 19.
Example 3:

Input: numBottles = 5, numExchange = 5
Output: 6
Example 4:

Input: numBottles = 2, numExchange = 3
Output: 2
 

Constraints:

1 <= numBottles <= 100
2 <= numExchange <= 100


class Solution
{
public:
    int numWaterBottles(int numBottles, int numExchange)
    {
        int drunk, emptyBottles;
        drunk = emptyBottles = 0;

        while(numBottles > 0)
        {
            drunk += numBottles; //all bottles drunk
            emptyBottles += numBottles; //bottles drunk become empty
            numBottles = emptyBottles / numExchange; //bottles filled after exchange
            emptyBottles %= numExchange; //bottles which couldn't be exchanged are left
        }
        return drunk;
    }
};

// Source https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/

Given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. 
The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels 
(i.e. The node with the number i has the label labels[i]).

The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.

Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i.

A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.

 

Example 1:


Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = "abaedcd"
Output: [2,1,1,1,1,1,1]
Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree.
Node 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself).
Example 2:


Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = "bbbb"
Output: [4,2,1,1]
Explanation: The sub-tree of node 2 contains only node 2, so the answer is 1.
The sub-tree of node 3 contains only node 3, so the answer is 1.
The sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2.
The sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4.
Example 3:


Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = "aabab"
Output: [3,2,1,1,1]
Example 4:

Input: n = 6, edges = [[0,1],[0,2],[1,3],[3,4],[4,5]], labels = "cbabaa"
Output: [1,2,1,1,2,1]
Example 5:

Input: n = 7, edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]], labels = "aaabaaa"
Output: [6,5,4,1,3,2,1]
 

Constraints:

1 <= n <= 10^5
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
labels.length == n
labels is consisting of only of lower-case English letters.

class Solution
{
private:
    vector<int> response;
    vector<vector<int>> graph;
    string *pLabels;
    int labelCount[26];

    void dfs(int nodeId, int parentNodeId)
    {
        int nodeLabelId = int(pLabels->at(nodeId)) - 97;
        int before = labelCount[nodeLabelId];
        ++labelCount[nodeLabelId];
        for (auto nextNodeId : graph[nodeId])
        {
            if (nextNodeId == parentNodeId)
            {
                continue;
            }
            dfs(nextNodeId, nodeId);
        }
        response[nodeId] = labelCount[nodeLabelId] - before;
    }

public:
    vector<int> countSubTrees(int n, vector<vector<int>> &edges, string labels)
    {
        response.resize(n);
        graph.resize(n);
        pLabels = &labels;
        for (auto &edge : edges)
        {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        dfs(0, -1);
        return std::move(response);
    }
};


// Source https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/

Given a string s of lowercase letters, you need to find the maximum number of non-empty substrings of s that meet the following conditions:

The substrings do not overlap, that is for any two substrings s[i..j] and s[k..l], either j < k or i > l is true.
A substring that contains a certain character c must also contain all occurrences of c.
Find the maximum number of substrings that meet the above conditions. 
If there are multiple solutions with the same number of substrings, return the one with minimum total length. 
It can be shown that there exists a unique solution of minimum total length.

Notice that you can return the substrings in any order.

 

Example 1:

Input: s = "adefaddaccc"
Output: ["e","f","ccc"]
Explanation: The following are all the possible substrings that meet the conditions:
[
  "adefaddaccc"
  "adefadda",
  "ef",
  "e",
  "f",
  "ccc",
]
If we choose the first string, we cannot choose anything else and we'd get only 1. If we choose "adefadda", we are left with "ccc" which is the only one that doesn't overlap, thus obtaining 2 substrings. Notice also, that it's not optimal to choose "ef" since it can be split into two. Therefore, the optimal way is to choose ["e","f","ccc"] which gives us 3 substrings. No other solution of the same number of substrings exist.
Example 2:

Input: s = "abbaccd"
Output: ["d","bb","cc"]
Explanation: Notice that while the set of substrings ["d","abba","cc"] also has length 3, it's considered incorrect since it has larger total length.
 

Constraints:

1 <= s.length <= 10^5
s contains only lowercase English letters.

先找出26种字符各自出现位置的左边界，右边界
遍历26种字符的左边界，中间，右边界，根据这些字符，调整包含这些字符的子字符串的左右边界
再按照子字符串的左右边界进行排序，再分2种情况挑选这些子字符串
1种是优先保证子字符串的个数最多，1种是保证子字符串的总长度最小

class Solution
{
public:
    vector<string> maxNumOfSubstrings(string s)
    {
        vector<pair<int, int>> v(26, pair{1000000, -1});
        for(int i = 0; i < s.size(); i++)
        {
            auto& [l, r] = v[s[i] - 'a'];
            l = min(i, l), r = max(i, r);
        }

        auto u = v;
        for(char c = 'a'; c <= 'z'; c++)
        {
            auto& [l, r] = u[c - 'a'];
            if(r == -1) continue;
            for(int i = l, j = l; i <= r || j >= l;)
            {
                if(i <= r)
                {
                    auto [l1, r1] = v[s[i] - 'a'];
                    r = max(r, r1);
                    l = min(l, l1);
                    i++;
                }
                if(j >= l)
                {
                    auto [l1, r1] = v[s[j] - 'a'];
                    r = max(r, r1);
                    l = min(l, l1);
                    j--;
                }
            }
        }
        u.erase(remove(u.begin(), u.end(), pair{1000000, -1}), u.end());
        sort(u.begin(), u.end());

        vector<pair<int, int>> w1 = {u.front()};
        for(auto [l, r] : u)
        {
            auto& [l0, r0] = w1.back();
            if(l > r0) w1.push_back(pair{l, r});
            else if(r <= r0) w1.back() = pair{l, r};
        }
        vector<pair<int, int>> w2 = {u.front()};
        for(auto [l, r] : u)
        {
            auto& [l0, r0] = w2.back();
            if(l > r0) w2.push_back(pair{l, r});
            else if(r <= r0) w2.back() = pair{l, r};
            else
            {
                if ( (r -l) < (r0 - l0) ) w2.back() = pair{l, r};
            } 
        }
        vector<string> res;
        if (w1.size() > w2.size())
        {
            for(auto [l, r] : w1) res.push_back(s.substr(l, r - l + 1));
        }
        else
        {
            for(auto [l, r] : w2) res.push_back(s.substr(l, r - l + 1));
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/

func(arr, l, r)
{
    if (r < l)
    {
        return -1000000000;
    }
    ans = arr[l]
    for (i = l + 1; i <= r; i++)
    {
        ans = ans & arr[i]
    }
    return ans
}

Winston was given the above mysterious function func. He has an integer array arr and an integer target 
and he wants to find the values l and r that make the value |func(arr, l, r) - target| minimum possible.

Return the minimum possible value of |func(arr, l, r) - target|.

Notice that func should be called with the values l and r where 0 <= l, r < arr.length.

 

Example 1:

Input: arr = [9,12,3,7,15], target = 5
Output: 2
Explanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], 
Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2.
Example 2:

Input: arr = [1000000,1000000,1000000], target = 1
Output: 999999
Explanation: Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999.
Example 3:

Input: arr = [1,2,4,8,16], target = 0
Output: 0
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 106
0 <= target <= 107

arr[i] & arr[i+1] <= arr[i]
arr[i] & arr[i+1] & arr[i+2] <= arr[i] & arr[i+1]
...
arr[i] & arr[i+1] ... arr[n-1] <= arr[i] & arr[i+1] ... arr[n-2]

st[i][j] 记录arr[i] & arr[i+1] ... arr[i+(2^j - 1)]的结果
st[i][j-1] = arr[i] & arr[i+1] ... arr[i+(2^(j-1) - 1)]
st[i+2^(j-1)][j-1] = arr[i+2^(j-1)] ... arr[i+(2^j - 1)]
st[i][j] = st[i][j-1] & st[i+2^(j-1)][j-1]

const int maxN = 100005, LOG = 20;
class sparseTable
{
    int st[maxN][LOG];
public:
    sparseTable(vector<int> arr)
    {
        int n = arr.size();
        for(int i = 0; i < n; i++)st[i][0] = arr[i];
        for(int j = 1; j < LOG; j++)
        {
            for(int i = 0; i + (1 << j) - 1 < n; i++)
            {
                st[i][j] = (st[i][j - 1] & st[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    int query(int l, int r)
    {
        int len = r - l + 1;
        int j = log2(len);
        return (st[l][j] & st[r - (1 << j) + 1][j]);
    }
};

class Solution
{
public:
    int closestToTarget(vector<int> &arr, int target)
    {
        sparseTable st(arr);
        int n = arr.size();
        int ans = INT_MAX;
        for(int i = 0; i < n; i++)
        {
            int l = i, r = n - 1;
            while(l <= r)
            {
                int m = l + (r - l) / 2;
                int x = st.query(i, m);
                ans = min(ans, abs(target - x));
                if(x <= target)r = m - 1;
                else l = m + 1;
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/

Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive).

 

Example 1:

Input: low = 3, high = 7
Output: 3
Explanation: The odd numbers between 3 and 7 are [3,5,7].
Example 2:

Input: low = 8, high = 10
Output: 1
Explanation: The odd numbers between 8 and 10 are [9].
 

Constraints:

0 <= low <= high <= 10^9

class Solution
{
public:
    int countOdds(int low, int high)
    {
        if(low % 2 == 0 && high % 2 == 0)  return (high - low) / 2;
        return  ((high - low) / 2) + 1;
    }
};


// Source https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/

Given an array of integers arr, return the number of subarrays with an odd sum.

Since the answer can be very large, return it modulo 109 + 7.

 

Example 1:

Input: arr = [1,3,5]
Output: 4
Explanation: All subarrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]
All sub-arrays sum are [1,4,9,3,8,5].
Odd sums are [1,9,3,5] so the answer is 4.
Example 2:

Input: arr = [2,4,6]
Output: 0
Explanation: All subarrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]
All sub-arrays sum are [2,6,12,4,10,6].
All sub-arrays have even sum and the answer is 0.
Example 3:

Input: arr = [1,2,3,4,5,6,7]
Output: 16
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 100

当前所有数之和为偶数，根据奇数+奇数=偶数，所以加上先前所有数之和为奇数的次数
当前所有数之和为奇数，根据偶数+奇数=奇数，所以加上先前所有数之和为偶数的次数，再加上1（当前所有数之和为奇数）


class Solution
{
public:
    const int mod = 1000000007;
    int numOfSubarrays(vector<int> &arr)
    {
        long long int odd = 0, sum = 0, ans = 0, even = 0;
        for(auto i : arr)
        {
            sum += i;
            if(sum % 2 == 0)
            {
                ans += odd;
                ans %= mod;
                even++;
            }
            else
            {
                ans += even;
                ans++;
                ans %= mod;
                odd++;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-good-ways-to-split-a-string/

You are given a string s, a split is called good if you can split s into 2 non-empty strings p and q 
where its concatenation is equal to s and the number of distinct letters in p and q are the same.

Return the number of good splits you can make in s.

 

Example 1:

Input: s = "aacaba"
Output: 2
Explanation: There are 5 ways to split "aacaba" and 2 of them are good. 
("a", "acaba") Left string and right string contains 1 and 3 different letters respectively.
("aa", "caba") Left string and right string contains 1 and 3 different letters respectively.
("aac", "aba") Left string and right string contains 2 and 2 different letters respectively (good split).
("aaca", "ba") Left string and right string contains 2 and 2 different letters respectively (good split).
("aacab", "a") Left string and right string contains 3 and 1 different letters respectively.
Example 2:

Input: s = "abcd"
Output: 1
Explanation: Split the string as follows ("ab", "cd").
Example 3:

Input: s = "aaaaa"
Output: 4
Explanation: All possible splits are good.
Example 4:

Input: s = "acbadbaada"
Output: 2
 

Constraints:

s contains only lowercase English letters.
1 <= s.length <= 10^5

class Solution
{
public:
    int numSplits(string s)
    {
        map<char, int>m1;
        map<char, int>m2;
        for(int i = 0; i < s.length(); i++)
        {
            m2[s[i]]++;
        }
        int ans = 0;
        for(int i = 0; i < s.length(); i++)
        {
            if(m1.size() == m2.size())
            {
                ans++;
            }
            m1[s[i]]++;
            m2[s[i]]--;
            if(m2[s[i]] == 0)
            {
                m2.erase(s[i]);
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/

Given an array of positive integers target and an array initial of same size with all zeros.

Return the minimum number of operations to form a target array from initial if you are allowed to do the following operation:

Choose any subarray from initial and increment each value by one.
The answer is guaranteed to fit within the range of a 32-bit signed integer.
 

Example 1:

Input: target = [1,2,3,2,1]
Output: 3
Explanation: We need at least 3 operations to form the target array from the initial array.
[0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).
[1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).
[1,2,2,2,1] increment 1 at index 2.
[1,2,3,2,1] target array is formed.
Example 2:

Input: target = [3,1,1,2]
Output: 4
Explanation: (initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target).
Example 3:

Input: target = [3,1,5,4,2]
Output: 7
Explanation: (initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] 
                                  -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target).
Example 4:

Input: target = [1,1,1,1]
Output: 1
 

Constraints:

1 <= target.length <= 10^5
1 <= target[i] <= 10^5

class Solution
{
public:
    int minNumberOperations(vector<int> &a)
    {
        int n = a.size();
        int answer = a[0];
        for(int i = 1; i < n; i++)
        {
            if(a[i] > a[i - 1])
            {
                answer += a[i] - a[i - 1];
            }
        }
        return answer;
    }
};


// Source https://leetcode.com/problems/shuffle-string/

Given a string s and an integer array indices of the same length.

The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.

Return the shuffled string.

 

Example 1:


Input: s = "codeleet", indices = [4,5,6,7,0,2,1,3]
Output: "leetcode"
Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.
Example 2:

Input: s = "abc", indices = [0,1,2]
Output: "abc"
Explanation: After shuffling, each character remains in its position.
Example 3:

Input: s = "aiohn", indices = [3,1,4,2,0]
Output: "nihao"
Example 4:

Input: s = "aaiougrt", indices = [4,0,2,6,7,3,1,5]
Output: "arigatou"
Example 5:

Input: s = "art", indices = [1,0,2]
Output: "rat"
 

Constraints:

s.length == indices.length == n
1 <= n <= 100
s contains only lower-case English letters.
0 <= indices[i] < n
All values of indices are unique (i.e. indices is a permutation of the integers from 0 to n - 1).

class Solution
{
public:
    string restoreString(string s, vector<int> &indices)
    {
        string ans = s;
        for(int i = 0; i < s.length(); i++)
        {
            ans[indices[i]] = s[i];
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/bulb-switcher-iv/

There is a room with n bulbs, numbered from 0 to n - 1, arranged in a row from left to right. Initially, all the bulbs are turned off.

Your task is to obtain the configuration represented by target where target[i] is '1' if the ith bulb is turned on and is '0' if it is turned off.

You have a switch to flip the state of the bulb, a flip operation is defined as follows:

Choose any bulb (index i) of your current configuration.
Flip each bulb from index i to index n - 1.
When any bulb is flipped it means that if it is '0' it changes to '1' and if it is '1' it changes to '0'.

Return the minimum number of flips required to form target.

 

Example 1:

Input: target = "10111"
Output: 3
Explanation: Initial configuration "00000".
flip from the third bulb:  "00000" -> "00111"
flip from the first bulb:  "00111" -> "11000"
flip from the second bulb:  "11000" -> "10111"
We need at least 3 flip operations to form target.
Example 2:

Input: target = "101"
Output: 3
Explanation: "000" -> "111" -> "100" -> "101".
Example 3:

Input: target = "00000"
Output: 0
Example 4:

Input: target = "001011101"
Output: 5
 

Constraints:

1 <= target.length <= 105
target[i] is either '0' or '1'.


class Solution
{
public:
    int minFlips(string target)
    {
        int idx = getFirstOne(target);
        if(idx == -1)
            return 0;
        int cnt = 0;
        for(int i = idx + 1; i < target.size(); i++)
        {
            if(target[i] != target[i - 1])
                cnt++;
        }
        return cnt + 1;
    }

    int getFirstOne(string str)
    {
        for(int i = 0; i < str.size(); i++)
        {
            if(str[i] == '1')
                return i;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/

Given the root of a binary tree and an integer distance. A pair of two different leaf nodes of a binary tree is said to be good 
if the length of the shortest path between them is less than or equal to distance.

Return the number of good leaf node pairs in the tree.

 

Example 1:


Input: root = [1,2,3,null,4], distance = 3
Output: 1
Explanation: The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.
Example 2:


Input: root = [1,2,3,4,5,6,7], distance = 3
Output: 2
Explanation: The good pairs are [4,5] and [6,7] with shortest path = 2. The pair [4,6] is not good because the length of ther shortest path between them is 4.
Example 3:

Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3
Output: 1
Explanation: The only good pair is [2,5].
Example 4:

Input: root = [100], distance = 1
Output: 0
Example 5:

Input: root = [1,1,1], distance = 2
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [1, 2^10].
Each node's value is between [1, 100].
1 <= distance <= 10

class Solution
{
public:
    int ans = 0;
    vector<int> count(TreeNode *root, int d)
    {
        if(!root) return{};
        if(!root->left && ! root->right) return {1};
        vector<int> lt = count(root->left, d);
        vector<int> rt = count(root->right, d);
        for(auto l : lt)
        {
            for(auto r : rt)
            {
                if(l + r <= d) ans++;
            }
        }
        vector<int> res;
        for(auto l : lt) if(l + 1 <= d) res.push_back(l + 1);
        for(auto r : rt) if(r + 1 <= d) res.push_back(r + 1);
        return res;
    }
    int countPairs(TreeNode *root, int distance)
    {
        count(root, distance);
        return ans;
    }
};


// Source https://leetcode.com/problems/string-compression-ii/

Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) 
with the concatenation of the character and the number marking the count of the characters (length of the run). 
For example, to compress the string "aabccc" we replace "aa" by "a2" and replace "ccc" by "c3". Thus the compressed string becomes "a2bc3".

Notice that in this problem, we are not adding '1' after single characters.

Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.

Find the minimum length of the run-length encoded version of s after deleting at most k characters.

 

Example 1:

Input: s = "aaabcccd", k = 2
Output: 4
Explanation: Compressing s without deleting anything will give us "a3bc3d" of length 6. 
Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, 
for instance delete 2 'a' then we will have s = "abcccd" which compressed is abc3d. 
Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be "a3c3" of length 4.
Example 2:

Input: s = "aabbaa", k = 2
Output: 2
Explanation: If we delete both 'b' characters, the resulting compressed string would be "a4" of length 2.
Example 3:

Input: s = "aaaaaaaaaaa", k = 0
Output: 3
Explanation: Since k is zero, we cannot delete anything. The compressed string is "a11" of length 3.
 

Constraints:

1 <= s.length <= 100
0 <= k <= s.length
s contains only lowercase English letters.

dp[i][j] 表示s[i ... n-1]删掉j个字符后对应的 the minimum length of the run-length encoded version 

class Solution
{
public:
    int getLengthOfOptimalCompression(string s, int k)
    {
        vector<vector<int>> dp(s.size(), vector<int>(k + 1, INT_MAX));
        for (int i = s.size() - 1; i >= 0; --i)
        {
            for (int j = 0; j <= k; ++j)
            {
                if (i == s.size() - 1)
                {
                    dp[i][j] = j == 0;
                    continue;
                }
                // 如果选择删掉s[i]
                if (j > 0)
                {
                    dp[i][j] = dp[i + 1][j - 1];
                }
                // 如果选择不删掉s[i]
                int count = 0, removed = 0;
                for (int iend = i; iend < s.size(); ++iend)
                {
                    if (s[iend] == s[i])
                    {
                        ++count;
                        int compress_length = GetCompressionLength(count);
                        compress_length += iend + 1 < s.size() ? dp[iend + 1][j - removed] : 0;
                        dp[i][j] = min(dp[i][j], compress_length);
                    }
                    else if (removed < j)
                    {
                        ++removed;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }
        return dp[0][k];
    }
    int GetCompressionLength(int count)
    {
        if (count == 0) return 0;
        if (count == 1) return 1;
        if (count < 10) return 2;
        if (count < 100) return 3;
        return 4;
    }
};


// Source https://leetcode.com/problems/count-good-triplets/

Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.

A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:

0 <= i < j < k < arr.length
|arr[i] - arr[j]| <= a
|arr[j] - arr[k]| <= b
|arr[i] - arr[k]| <= c
Where |x| denotes the absolute value of x.

Return the number of good triplets.

 

Example 1:

Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
Output: 4
Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].
Example 2:

Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1
Output: 0
Explanation: No triplet satisfies all conditions.
 

Constraints:

3 <= arr.length <= 100
0 <= arr[i] <= 1000
0 <= a, b, c <= 1000

class Solution
{
public:
    int countGoodTriplets(vector<int> &arr, int a, int b, int c)
    {
        int size = arr.size();
        int count = 0;
        for(int i = 0; i < size - 2; i++)
        {
            for(int j = i + 1; j < size - 1; j++)
            {
                for(int k = j + 1; k < size; k++)
                {
                    if(abs(arr[i] - arr[j]) <= a && abs(arr[j] - arr[k]) <= b && abs(arr[i] - arr[k]) <= c)
                    {
                        count++;
                    }
                }
            }
        }
        return count;
    }
};

// Source https://leetcode.com/problems/find-the-winner-of-an-array-game/

Given an integer array arr of distinct integers and an integer k.

A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). 
In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0 and the smaller integer moves to the end of the array. 
The game ends when an integer wins k consecutive rounds.

Return the integer which will win the game.

It is guaranteed that there will be a winner of the game.

 

Example 1:

Input: arr = [2,1,3,5,4,6,7], k = 2
Output: 5
Explanation: Let's see the rounds of the game:
Round	|       arr   	| winner | win_count
  1  	| [2,1,3,5,4,6,7] 	| 2      	| 1
  2   	| [2,3,5,4,6,7,1] 	| 3      	| 1
  3   	| [3,5,4,6,7,1,2] 	| 5      	| 1
  4   	| [5,4,6,7,1,2,3] 	| 5      	| 2
So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.
Example 2:

Input: arr = [3,2,1], k = 10
Output: 3
Explanation: 3 will win the first 10 rounds consecutively.
Example 3:

Input: arr = [1,9,8,2,3,7,6,4,5], k = 7
Output: 9
Example 4:

Input: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000
Output: 99
 

Constraints:

2 <= arr.length <= 105
1 <= arr[i] <= 106
arr contains distinct integers.
1 <= k <= 109

class Solution
{
public:
    int getWinner(vector<int> &arr, int k)
    {
        int streak = 0;
        int biggestSoFar = arr[0];
        for(int i = 1; i < arr.size(); ++i)
        {
            if(biggestSoFar > arr[i])
            {
                streak++;
            }
            else
            {
                biggestSoFar = arr[i];
                streak = 1;
            }
            if(streak == k) return biggestSoFar;
        }
        return biggestSoFar;
    }
};


// Source https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/

Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.

A grid is said to be valid if all the cells above the main diagonal are zeros.

Return the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.

The main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).

 

Example 1:


Input: grid = [[0,0,1],[1,1,0],[1,0,0]]
Output: 3
Example 2:


Input: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]
Output: -1
Explanation: All rows are similar, swaps have no effect on the grid.
Example 3:


Input: grid = [[1,0,0],[1,1,0],[1,1,1]]
Output: 0
 

Constraints:

n == grid.length == grid[i].length
1 <= n <= 200
grid[i][j] is either 0 or 1

class Solution
{
public:
    int minSwaps(vector<vector<int>> &grid)
    {
        int n = grid.size();
        vector<int> curr(n);
        for(int i = 0; i < n; i++)
        {
            int cnt = 0;
            for(int j = grid[i].size() - 1; j >= 0 && grid[i][j] == 0; j--, cnt++);
            grid[i].push_back(cnt);
            curr[i] = cnt;
        }
        sort(curr.begin(), curr.end());
        reverse(curr.begin(), curr.end());
        for(int i = 0; i < n; i++)
        {
            if (curr[i] < (n - 1 -i)) return -1;
        }
        int pos = n - 1, ans = 0;
        for(int i = 0; i < n; i++)
        {
            if(grid[i].back() < pos)
            {
                for(int r = i + 1; r < n; r++)
                {
                    if(grid[r].back() >= pos)
                    {
                        for(int k = r; k > i; k--)
                        {
                            swap(grid[k], grid[k - 1]);
                            ans++;
                        }
                        break;
                    }
                }
            }
            pos--;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/get-the-maximum-score/

You are given two sorted arrays of distinct integers nums1 and nums2.

A valid path is defined as follows:

Choose array nums1 or nums2 to traverse (from index-0).
Traverse the current array from left to right.
If you are reading any value that is present in nums1 and nums2 you are allowed to change your path to the other array. 
(Only one repeated value is considered in the valid path).
The score is defined as the sum of uniques values in a valid path.

Return the maximum score you can obtain of all possible valid paths. 
Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:



Input: nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]
Output: 30
Explanation: Valid paths:
[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)
[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)
The maximum is obtained with the path in green [2,4,6,8,10].
Example 2:

Input: nums1 = [1,3,5,7,9], nums2 = [3,5,100]
Output: 109
Explanation: Maximum sum is obtained with the path [1,3,5,100].
Example 3:

Input: nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]
Output: 40
Explanation: There are no common elements between nums1 and nums2.
Maximum sum is obtained with the path [6,7,8,9,10].
Example 4:

Input: nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]
Output: 61
 

Constraints:

1 <= nums1.length, nums2.length <= 105
1 <= nums1[i], nums2[i] <= 107
nums1 and nums2 are strictly increasing.

class Solution
{
public:
    int maxSum(vector<int> &nums1, vector<int> &nums2)
    {
        int len1 = nums1.size();
        int len2 = nums2.size();
        long int sum1 = 0, sum2 = 0, total = 0;
        int i = 0, j = 0;
        long int mod = pow(10, 9) + 7;
        while(i < len1 && j < len2)
        {
            if(nums1[i] == nums2[j])
            {
                if(sum1 > sum2)
                {
                    total = (total + sum1 + nums1[i]) % (mod);
                }
                else
                {
                    total = (total + sum2 + nums2[j]) % (mod);
                }
                i++;
                j++;
                sum1 = 0;
                sum2 = 0;
            }
            else
            {
                if(nums1[i] > nums2[j])
                {
                    sum2 += nums2[j];
                    j++;
                }
                else
                {
                    sum1 += nums1[i];
                    i++;
                }
            }
        }

        if(i != len1)
        {
            while(i < len1)
                sum1 += nums1[i++];
        }
        if(j != len2)
        {
            while(j < len2)
                sum2 += nums2[j++];
        }
        if(i == len1 && j == len2)
        {
            if(sum1 > sum2)
                total = (total + sum1) % (mod);
            else
                total = (total + sum2) % (mod);
        }
        return total;
    }
};


// Source https://leetcode.com/problems/kth-missing-positive-number/

Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.

Find the kth positive integer that is missing from this array.

 

Example 1:

Input: arr = [2,3,4,7,11], k = 5
Output: 9
Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.
Example 2:

Input: arr = [1,2,3,4], k = 2
Output: 6
Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6.
 

Constraints:

1 <= arr.length <= 1000
1 <= arr[i] <= 1000
1 <= k <= 1000
arr[i] < arr[j] for 1 <= i < j <= arr.length

class Solution
{
public:
    int findKthPositive(vector<int> &arr, int k)
    {
        for(int i = 0, num = 1; i < arr.size(); num++)
        {
            if(arr[i] != num)
            {
                k--;
                if(k == 0)
                {
                    return num;
                }
            }
            else
            {
                i++;
            }
        }
        return arr[arr.size() - 1] + k;
    }
};


// Source https://leetcode.com/problems/can-convert-string-in-k-moves/

Given two strings s and t, your goal is to convert s into t in k moves or less.

During the ith (1 <= i <= k) move you can:

Choose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.
Do nothing.
Shifting a character means replacing it by the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). 
Shifting a character by i means applying the shift operations i times.

Remember that any index j can be picked at most once.

Return true if it's possible to convert s into t in no more than k moves, otherwise return false.

 

Example 1:

Input: s = "input", t = "ouput", k = 9
Output: true
Explanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.
Example 2:

Input: s = "abc", t = "bcd", k = 10
Output: false
Explanation: We need to shift each character in s one time to convert it into t. 
We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.
Example 3:

Input: s = "aab", t = "bbb", k = 27
Output: true
Explanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.
 

Constraints:

1 <= s.length, t.length <= 10^5
0 <= k <= 10^9
s, t contain only lowercase English letters.

class Solution
{
public:
    bool canConvertString(string s, string t, int k)
    {
        map<int, int>mp;
        int n = s.length(), m = t.length();
        if(n != m)
            return false;
        for(int i = 0; i < n; i++)
        {
            int diff = int(t[i]) - int(s[i]);
            if(diff < 0)
                diff = 26 + diff;
            if(diff > 0)
                mp[diff] += 1;
        }
        bool ans = true;
        for(auto p : mp)
        {
            if(k < 26 * (p.second - 1) + p.first)
            {
                ans = false;
                break;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/

Given a parentheses string s containing only the characters '(' and ')'. A parentheses string is balanced if:

Any left parenthesis '(' must have a corresponding two consecutive right parenthesis '))'.
Left parenthesis '(' must go before the corresponding two consecutive right parenthesis '))'.
In other words, we treat '(' as openning parenthesis and '))' as closing parenthesis.

For example, "())", "())(())))" and "(())())))" are balanced, ")()", "()))" and "(()))" are not balanced.

You can insert the characters '(' and ')' at any position of the string to balance it if needed.

Return the minimum number of insertions needed to make s balanced.

 

Example 1:

Input: s = "(()))"
Output: 1
Explanation: The second '(' has two matching '))', but the first '(' has only ')' matching. We need to to add one more ')' at the end of the string to be "(())))" which is balanced.
Example 2:

Input: s = "())"
Output: 0
Explanation: The string is already balanced.
Example 3:

Input: s = "))())("
Output: 3
Explanation: Add '(' to match the first '))', Add '))' to match the last '('.
Example 4:

Input: s = "(((((("
Output: 12
Explanation: Add 12 ')' to balance the string.
Example 5:

Input: s = ")))))))"
Output: 5
Explanation: Add 4 '(' at the beginning of the string and one ')' at the end. The string becomes "(((())))))))".
 

Constraints:

1 <= s.length <= 10^5
s consists of '(' and ')' only.

class Solution
{
public:
    int minInsertions(string s)
    {
        int n = s.size();
        int open = 0;
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == '(')
            {
                open++;
            }
            else
            {
                if(open == 0)
                {
                    if(i + 1 < n && s[i + 1] == ')')
                    {
                        ans++;
                        i++;
                    }
                    else
                    {
                        ans += 2;
                    }
                }
                else
                {
                    open--;
                    if(i + 1 < n && s[i + 1] == ')')
                    {
                        i++;
                    }
                    else
                    {
                        ans++;
                    }
                }
            }
        }
        return ans + 2 * open;
    }
};

// Source https://leetcode.com/problems/find-longest-awesome-substring/

Given a string s. An awesome substring is a non-empty substring of s such that we can make any number of swaps in order to make it palindrome.

Return the length of the maximum length awesome substring of s.

 

Example 1:

Input: s = "3242415"
Output: 5
Explanation: "24241" is the longest awesome substring, we can form the palindrome "24142" with some swaps.
Example 2:

Input: s = "12345678"
Output: 1
Example 3:

Input: s = "213123"
Output: 6
Explanation: "213123" is the longest awesome substring, we can form the palindrome "231132" with some swaps.
Example 4:

Input: s = "00"
Output: 2
 

Constraints:

1 <= s.length <= 105
s consists only of digits.

pos[i] 表示满足s[0 ... k-1]数字统计状态为i，这样的最小的k

class Solution
{
public:
    int longestAwesome(string s)
    {
        vector<int> pos((1 << 10), -1);

        int curr = 0, ans = 1;
        pos[0] = 0;
        for(int i = 0; i < s.size(); i++)
        {
            char ch = s[i];

            curr ^= (1 << (ch - '0'));

            if(pos[curr] != -1)
            {
                ans = max(ans, i - pos[curr] + 1);
            }

            for(int d = 0; d < 10; d++)
            {
                int req = curr ^ (1 << d);
                if(pos[req] == -1) continue;
                ans = max(ans, i - pos[req] + 1);
            }
            if(pos[curr] == -1) pos[curr] = i + 1;
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/make-the-string-great/

Given a string s of lower and upper case English letters.

A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:

0 <= i <= s.length - 2
s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
To make the string good, you can choose two adjacent characters that make the string bad and remove them. 
You can keep doing this until the string becomes good.

Return the string after making it good. The answer is guaranteed to be unique under the given constraints.

Notice that an empty string is also good.

 

Example 1:

Input: s = "leEeetcode"
Output: "leetcode"
Explanation: In the first step, either you choose i = 1 or i = 2, both will result "leEeetcode" to be reduced to "leetcode".
Example 2:

Input: s = "abBAcC"
Output: ""
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""
Example 3:

Input: s = "s"
Output: "s"
 

Constraints:

1 <= s.length <= 100
s contains only lower and upper case English letters.

class Solution
{
public:
    string makeGood(string s)
    {
        if (s.length() == 0)
        {
            return "";
        }
        string result = "";
        result += s[0];

        for (int i = 1; i < s.length(); i++)
        {
            if (result.size() > 0 && abs(result.back() - s[i]) == 'a' - 'A')
            {
                result.pop_back();
            }
            else
            {
                result.push_back(s[i]);
            }
        }
        return result;
    }
};


// Source https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/

Given two positive integers n and k, the binary string Sn is formed as follows:

S1 = "0"
Si = Si-1 + "1" + reverse(invert(Si-1)) for i > 1
Where + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).

For example, the first 4 strings in the above sequence are:

S1 = "0"
S2 = "011"
S3 = "0111001"
S4 = "011100110110001"
Return the kth bit in Sn. It is guaranteed that k is valid for the given n.

 

Example 1:

Input: n = 3, k = 1
Output: "0"
Explanation: S3 is "0111001". The first bit is "0".
Example 2:

Input: n = 4, k = 11
Output: "1"
Explanation: S4 is "011100110110001". The 11th bit is "1".
Example 3:

Input: n = 1, k = 1
Output: "0"
Example 4:

Input: n = 2, k = 3
Output: "1"
 

Constraints:

1 <= n <= 20
1 <= k <= 2n - 1

class Solution
{
public:
    string helper(string s)
    {
        for (int i = 0; i < s.length(); i++)
        {
            s[i] = (s[i] == '0' ? '1' : '0');
        }
        reverse(s.begin(), s.end());
        return s;
    }
    void solve(string &s, int n)
    {
        if (n < 2)
        {
            return;
        }
        s = s + "1" + helper(s);
        solve(s, --n);
    }
    char findKthBit(int n, int k)
    {
        string s = "0";
        solve(s, n);
        return s[k - 1];
    }
};


// Source https://leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/

Given an array nums and an integer target.

Return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.

 

Example 1:

Input: nums = [1,1,1,1,1], target = 2
Output: 2
Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).
Example 2:

Input: nums = [-1,3,5,1,4,2,-9], target = 6
Output: 2
Explanation: There are 3 subarrays with sum equal to 6.
([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.
Example 3:

Input: nums = [-2,6,6,3,5,4,1,2,8], target = 10
Output: 3
Example 4:

Input: nums = [0,0,0], target = 0
Output: 3
 

Constraints:

1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
0 <= target <= 10^6

class Solution
{
public:
    int maxNonOverlapping(vector<int> &nums, int target)
    {
        vector<pair<int, int>> v;

        int sum = 0;
        unordered_map<int, int> mp;
        mp[0] = -1;

        for(int i = 0 ; i < nums.size() ; i++)
        {
            sum += nums[i];
            if(mp.count(sum - target)) v.push_back({mp[sum - target] + 1, i});
            mp[sum] = i;
        }

        int n = v.size();
        int end = INT_MIN;

        for(auto i : v)
        {
            if(i.first <= end) n--;
            else end = i.second;
        }

        return n;
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-cut-a-stick/

Given a wooden stick of length n units. The stick is labelled from 0 to n. 
For example, a stick of length 6 is labelled as follows:

____________________________________________________________
|	|	|	|	|	|	|
0	1	2	3	4	5	6

Given an integer array cuts where cuts[i] denotes a position you should perform a cut at.

You should perform the cuts in order, you can change the order of the cuts as you wish.

The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. 
When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). 
Please refer to the first example for a better explanation.

Return the minimum total cost of the cuts.

 

Example 1:


Input: n = 7, cuts = [1,3,4,5]
Output: 16
Explanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:

The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.
Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).
Example 2:

Input: n = 9, cuts = [5,6,1,4,2]
Output: 22
Explanation: If you try the given cuts ordering the cost will be 25.
There are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.
 

Constraints:

2 <= n <= 106
1 <= cuts.length <= min(n - 1, 100)
1 <= cuts[i] <= n - 1
All the integers in cuts array are distinct.

先对cuts进行排序
dp[i][j] 表示把startlen ... endlen按照cuts[i] ... cuts[j]切分，the minimum total cost

class Solution
{
public:
    int dp[101][101];
    int solve(int startlen, int endlen, vector<int> &cuts, int i, int j)
    {
        if(i > j) return 0;
        if(dp[i][j] != -1) return dp[i][j];
        int ans = INT_MAX;
        for(int k = i; k <= j; k++)
        {
            int tempans = solve(startlen, cuts[k], cuts, i, k - 1) +
                          solve(cuts[k], endlen, cuts, k + 1, j) + (endlen - startlen);
            ans = min(ans, tempans);
        }
        return dp[i][j] = ans;
    }
    int minCost(int n, vector<int> &cuts)
    {
        memset(dp, -1, sizeof(dp));
        sort(cuts.begin(), cuts.end());
        return solve(0, n, cuts, 0, cuts.size() - 1);
    }
};

// Source https://leetcode.com/problems/three-consecutive-odds/

Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.
 

Example 1:

Input: arr = [2,6,4,1]
Output: false
Explanation: There are no three consecutive odds.
Example 2:

Input: arr = [1,2,34,3,4,5,7,23,12]
Output: true
Explanation: [5,7,23] are three consecutive odds.
 

Constraints:

1 <= arr.length <= 1000
1 <= arr[i] <= 1000

class Solution
{
public:
    bool threeConsecutiveOdds(vector<int> &arr)
    {
        for(int i = 0; i + 2 < arr.size(); i++)
        {
            if(arr[i] & 1 && arr[i + 1] & 1 && arr[i + 2] & 1)
                return true;
        }
        return false;
    }
};

// Source https://leetcode.com/problems/minimum-operations-to-make-array-equal/

You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n).

In one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). 
The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.

Given an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.

 

Example 1:

Input: n = 3
Output: 2
Explanation: arr = [1, 3, 5]
First operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]
In the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].
Example 2:

Input: n = 6
Output: 9
 

Constraints:

1 <= n <= 104

class Solution
{
public:
    int minOperations(int n)
    {
        int ans = 0;
        if(n == 1)
            return 0;
        if(n % 2)
        {
            int mid = 2 * (n / 2) + 1;
            for(int i = 0; i < n / 2; i++)
            {
                ans += ((mid - (2 * i + 1)));
            }
        }
        else
        {
            for(int i = 0; i < n / 2; i++)
            {
                ans += (n - (2 * i + 1));
            }
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/magnetic-force-between-two-balls/

In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. 
Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets 
such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions x and y is |x - y|.

Given the integer array position and the integer m. Return the required force.

 

Example 1:


Input: position = [1,2,3,4,7], m = 3
Output: 3
Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. 
The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.
Example 2:

Input: position = [5,4,3,2,1,1000000000], m = 2
Output: 999999999
Explanation: We can use baskets 1 and 1000000000.
 

Constraints:

n == position.length
2 <= n <= 105
1 <= position[i] <= 109
All integers in position are distinct.
2 <= m <= position.length

class Solution
{
public:
    bool isundermagneticforce(vector<int> &position, int m, int dist)
    {
        int coordinate = position[0];
        int ball_count = 1;

        for(int i = 1; i < position.size(); i++)
        {
            if((position[i] - coordinate) >= dist)
            {
                ball_count += 1;
                coordinate = position[i];
            }
            if(ball_count >= m)
                return true;
        }
        return false;
    }
    int maxDistance(vector<int> &position, int m)
    {
        sort(position.begin(), position.end());
        int n = position.size();

        int low = 1;
        int high = position[n - 1] - position[0];
        int res = 0;

        while(low <= high)
        {
            int mid = low + (high - low) / 2;

            if(isundermagneticforce(position, m, mid))
            {
                res = mid;
                low = mid + 1;
            }
            else
                high = mid - 1;
        }
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/

There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows:

Eat one orange.
If the number of remaining oranges n is divisible by 2 then you can eat n / 2 oranges.
If the number of remaining oranges n is divisible by 3 then you can eat 2 * (n / 3) oranges.
You can only choose one of the actions per day.

Return the minimum number of days to eat n oranges.

 

Example 1:

Input: n = 10
Output: 4
Explanation: You have 10 oranges.
Day 1: Eat 1 orange,  10 - 1 = 9.  
Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)
Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. 
Day 4: Eat the last orange  1 - 1  = 0.
You need at least 4 days to eat the 10 oranges.
Example 2:

Input: n = 6
Output: 3
Explanation: You have 6 oranges.
Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).
Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)
Day 3: Eat the last orange  1 - 1  = 0.
You need at least 3 days to eat the 6 oranges.
Example 3:

Input: n = 1
Output: 1
Example 4:

Input: n = 56
Output: 6

56 - 56/2 = 28
28 -1 = 27
27 - (2/3)*27 = 9
9 - (2/3)*9 = 3
3 - (2/3)*3=1
1 - 1 = 0

Constraints:

1 <= n <= 2 * 109

class Solution
{
public:
    unordered_map<int, int> dp;
    int minDays(int n)
    {
        if (n <= 1)
            return n;
        if (dp.count(n) != 0) return dp[n];

        int a = INT_MAX;
        int b = INT_MAX;
        int c = INT_MAX;

        if(n % 2 == 0) b = 1 + minDays(n / 2);
        if(n % 3 == 0) c = 1 + minDays(n / 3);
        if((n % 2 != 0) || (n % 3 != 0)) a = 1 + minDays(n - 1);

        return dp[n] =  min(min(b, c), a)  ;
    }
};

// Source https://leetcode.com/problems/thousand-separator/

Given an integer n, add a dot (".") as the thousands separator and return it in string format.

 

Example 1:

Input: n = 987
Output: "987"
Example 2:

Input: n = 1234
Output: "1.234"
Example 3:

Input: n = 123456789
Output: "123.456.789"
Example 4:

Input: n = 0
Output: "0"
 

Constraints:

0 <= n < 231

class Solution
{
public:
    string thousandSeparator(int n)
    {
        string res = "";
        int count = 0;
        int len = 0;
        if(n == 0)
            return "0";
        while(n)
        {
            len++;
            int rem = n % 10;
            n /= 10;
            res.push_back(rem + '0');
            count++;
            if(count == 3)
            {
                res.push_back('.');
                count = 0;
            }
        }
        if(len % 3 == 0)
            res.pop_back();
        reverse(res.begin(), res.end());
        return res;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/

Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [fromi, toi] represents a directed edge from node fromi to node toi.

Find the smallest set of vertices from which all nodes in the graph are reachable. 
It's guaranteed that a unique solution exists.

Notice that you can return the vertices in any order.

 

Example 1:



Input: n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
Output: [0,3]
Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0,1,2,5]. From 3 we can reach [3,4,2,5]. So we output [0,3].
Example 2:



Input: n = 5, edges = [[0,1],[2,1],[3,1],[1,4],[2,4]]
Output: [0,2,3]
Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.
 

Constraints:

2 <= n <= 10^5
1 <= edges.length <= min(10^5, n * (n - 1) / 2)
edges[i].length == 2
0 <= fromi, toi < n
All pairs (fromi, toi) are distinct.

class Solution
{
public:
    vector<int> findSmallestSetOfVertices(int n, vector<vector<int>> &edges)
    {
        vector<int> ans;
        vector<int> indegree(n);
        for(int i = 0; i < edges.size(); i++)
        {
            indegree[edges[i][1]]++;
        }
        for(int i = 0; i < n; i++)
        {
            if(indegree[i] == 0)
                ans.push_back(i);
        }
        return ans;
    }
};

// Source https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/

You are given an integer array nums. You have an integer array arr of the same length with all values set to 0 initially. 
You also have the following modify function:

func modify(arr, op, idx)
{
    // add by 1 index idx
    if (op == 0)
    {
        arr[idx] = arr[idx] + 1
    }
    // multiply by 2 all elements
    if (op == 1)
    {
        for (i = 0; i < arr.length; i++)
        {
            arr[i] = arr[i] * 2
        }
    }
}

You want to use the modify function to covert arr to nums using the minimum number of calls.

Return the minimum number of function calls to make nums from arr.

The test cases are generated so that the answer fits in a 32-bit signed integer.

 

Example 1:

Input: nums = [1,5]
Output: 5
Explanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).
Double all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations).
Increment by 1 (both elements)  [0, 4] -> [1, 4] -> [1, 5] (2 operations).
Total of operations: 1 + 2 + 2 = 5.
Example 2:

Input: nums = [2,2]
Output: 3
Explanation: Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations).
Double all the elements: [1, 1] -> [2, 2] (1 operation).
Total of operations: 2 + 1 = 3.
Example 3:

Input: nums = [4,2,5]
Output: 6
Explanation: (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5](nums).
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109

find(num) 查找num的二进制最高位（通过数字1左移得到该最高位需要的次数）
f(num) 统计num的二进制中1的个数

class Solution
{
public:
    int find(int n)
    {
        for(int i = 31; i >= 0; i--)
        {
            if((1 << i)&n)
            {
                return i;
            }
        }
        return 0;
    }
    int f(int n)
    {
        int count = 0;
        while(n)
        {
            n = n & (n - 1);
            count++;
        }
        return count;
    }
    int minOperations(vector<int> &nums)
    {
        int len = 0;
        int n = nums.size();
        int count = 0;
        for(int i = 0; i < n; i++)
        {
            len = max(len, find(nums[i]));
            count += f(nums[i]);
        }
        return len + count;
    }
};

// Source https://leetcode.com/problems/detect-cycles-in-2d-grid/

Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.

A cycle is a path of length 4 or more in the grid that starts and ends at the same cell. 
From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.

Also, you cannot move to the cell that you visited in your last move. 
For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.

Return true if any cycle of the same value exists in grid, otherwise, return false.

 

Example 1:



Input: grid = [["a","a","a","a"],["a","b","b","a"],["a","b","b","a"],["a","a","a","a"]]
Output: true
Explanation: There are two valid cycles shown in different colors in the image below:

Example 2:



Input: grid = [["c","c","c","a"],["c","d","c","c"],["c","c","e","c"],["f","c","c","c"]]
Output: true
Explanation: There is only one valid cycle highlighted in the image below:

Example 3:



Input: grid = [["a","b","b"],["b","z","b"],["b","b","a"]]
Output: false
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 500
grid consists only of lowercase English letters.

class Solution
{
public:
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};
    bool dfs(vector<vector<char>> &grid, vector<vector<bool>> &vis, int x, int y, int par_x, int par_y, char cur)
    {
        vis[x][y] = true;
        for(int i = 0; i < 4; ++i)
        {
            int x1 = x + dx[i], y1 = y + dy[i];
            if(x1 < 0 || x1 >= grid.size() || y1 < 0 || y1 >= grid[0].size() || grid[x1][y1] != cur) continue;
            if(vis[x1][y1] && (x1 != par_x || y1 != par_y)) return true;
            if(vis[x1][y1]) continue;
            if(dfs(grid, vis, x1, y1, x, y, cur)) return true;
        }
        return false;
    }

    bool containsCycle(vector<vector<char>> &grid)
    {
        int r = grid.size(), c = grid[0].size();
        vector<vector<bool>> vis(r, vector<bool>(c, false));
        for(int i = 0; i < r; ++i)
        {
            for(int j = 0; j < c; ++j)
            {
                if(!vis[i][j])
                {
                    if(dfs(grid, vis, i, j, -1, -1, grid[i][j])) return true;
                }
            }
        }
        return false;
    }
};

// Source https://leetcode.com/problems/most-visited-sector-in-a-circular-track/

Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. 
A marathon will be held on this track, the marathon consists of m rounds. 
The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. 
For example, round 1 starts at sector rounds[0] and ends at sector rounds[1]

Return an array of the most visited sectors sorted in ascending order.

Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).

 

Example 1:


Input: n = 4, rounds = [1,3,1,2]
Output: [1,2]
Explanation: The marathon starts at sector 1. The order of the visited sectors is as follows:
1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)
We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.
Example 2:

Input: n = 2, rounds = [2,1,2,1,2,1,2,1,2]
Output: [2]
Example 3:

Input: n = 7, rounds = [1,3,5,7]
Output: [1,2,3,4,5,6,7]
 

Constraints:

2 <= n <= 100
1 <= m <= 100
rounds.length == m + 1
1 <= rounds[i] <= n
rounds[i] != rounds[i + 1] for 0 <= i < m

rounds.length == m + 1
rounds[0]和rounds[m] 分别对应开始位置和结束位置
从rounds[0]到rounds[m] 中间可能会环绕若干圈，每环绕一圈，每个sector的访问次数都加1

class Solution
{
public:
    vector<int> mostVisited(int n, vector<int> &rounds)
    {
        int sz = rounds.size();
        int startSector = rounds[0];
        int endSector = rounds[sz - 1];
        vector<int> res;
        if(startSector == endSector)res.push_back(startSector);
        else if(startSector < endSector)for(int i = startSector; i <= endSector; i++) res.push_back(i);
        else
        {
            for(int i = 1; i <= endSector; i++) res.push_back(i);
            for(int i = startSector; i <= n; i++) res.push_back(i);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/maximum-number-of-coins-you-can-get/

There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:

In each step, you will choose any 3 piles of coins (not necessarily consecutive).
Of your choice, Alice will pick the pile with the maximum number of coins.
You will pick the next pile with the maximum number of coins.
Your friend Bob will pick the last pile.
Repeat until there are no more piles of coins.
Given an array of integers piles where piles[i] is the number of coins in the ith pile.

Return the maximum number of coins that you can have.

 

Example 1:

Input: piles = [2,4,1,2,7,8]
Output: 9
Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.
Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.
The maximum number of coins which you can have are: 7 + 2 = 9.
On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.
Example 2:

Input: piles = [2,4,5]
Output: 4
Example 3:

Input: piles = [9,8,7,6,5,1,2,3,4]
Output: 18
 

Constraints:

3 <= piles.length <= 105
piles.length % 3 == 0
1 <= piles[i] <= 104

先对piles排序，再按照最小给Bob，最大给Alice，第二大给自己，不断pick

class Solution
{
public:
    int maxCoins(vector<int> &piles)
    {
        sort(piles.begin(), piles.end());
        int i = 0, j = piles.size() - 2;
        int coins = 0;
        while(i < j)
        {
            coins += piles[j];
            j -= 2;
            i++;
        }
        return coins;
    }
};


// Source https://leetcode.com/problems/find-latest-group-of-size-m/

Given an array arr that represents a permutation of numbers from 1 to n.

You have a binary string of size n that initially has all its bits set to zero. 
At each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1.

You are also given an integer m. Find the latest step at which there exists a group of ones of length m. 
A group of ones is a contiguous substring of 1's such that it cannot be extended in either direction.

Return the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1.

 

Example 1:

Input: arr = [3,5,1,2,4], m = 1
Output: 4
Explanation:
Step 1: "00100", groups: ["1"]
Step 2: "00101", groups: ["1", "1"]
Step 3: "10101", groups: ["1", "1", "1"]
Step 4: "11101", groups: ["111", "1"]
Step 5: "11111", groups: ["11111"]
The latest step at which there exists a group of size 1 is step 4.
Example 2:

Input: arr = [3,1,5,4,2], m = 2
Output: -1
Explanation:
Step 1: "00100", groups: ["1"]
Step 2: "10100", groups: ["1", "1"]
Step 3: "10101", groups: ["1", "1", "1"]
Step 4: "10111", groups: ["1", "111"]
Step 5: "11111", groups: ["11111"]
No group of size 2 exists during any step.
Example 3:

Input: arr = [1], m = 1
Output: 1
Example 4:

Input: arr = [2,1], m = 2
Output: 2
 

Constraints:

n == arr.length
1 <= m <= n <= 105
1 <= arr[i] <= n
All integers in arr are distinct.

class Solution
{
    int find( int p, vector<int> &ids )
    {
        while( ids[p] != 0 ) p = ids[p];
        return p;
    }

public:
    int findLatestStep(vector<int> &A, int m)
    {
        int res = -1, n = A.size();
        if( m == n )
            return n;

        vector<int> ids(n + 2), sz(n + 2);
        for( int i = 0; i < n; i++ )
        {
            int a = A[i], pid = find(a - 1, ids), qid = find(a + 1, ids);
            if( sz[pid] != 0 )
                ids[pid] = a;
            if( sz[qid] != 0 )
                ids[qid] = a;
            sz[a] += sz[pid] + sz[qid] + 1;
            if( sz[pid] == m || sz[qid] == m )
                res = i;
        }

        return res;
    }
};

// Source https://leetcode.com/problems/stone-game-v/

There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.

In each round of the game, Alice divides the row into two non-empty rows (i.e. left row and right row), 
then Bob calculates the value of each row which is the sum of the values of all the stones in this row. 
Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. 
If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.

The game ends when there is only one stone remaining. Alice's is initially zero.

Return the maximum score that Alice can obtain.

 

Example 1:

Input: stoneValue = [6,2,3,4,5,5]
Output: 18
Explanation: In the first round, Alice divides the row to [6,2,3], [4,5,5]. The left row has the value 11 and the right row has value 14. 
Bob throws away the right row and Alice's score is now 11.
In the second round Alice divides the row to [6], [2,3]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).
The last round Alice has only one choice to divide the row which is [2], [3]. Bob throws away the right row and Alice's score is now 18 (16 + 2). 
The game ends because only one stone is remaining in the row.
Example 2:

Input: stoneValue = [7,7,7,7,7,7,7]
Output: 28
Example 3:

Input: stoneValue = [4]
Output: 0
 

Constraints:

1 <= stoneValue.length <= 500
1 <= stoneValue[i] <= 106

dp[i][j] 表示对stoneValue[i] ... stoneValue[j]进行划分，Alice可以获得的最大score

class Solution
{
public:
    int dp[505][505];

    int fun(vector<int> &stoneValue, int i, int j)
    {
        if(i == j)
        {
            return 0;
        }

        if(dp[i][j] != -1)
        {
            return dp[i][j];
        }

        int sum = 0, curr = 0, ans = 0;

        for(int k = i; k <= j; k++)
        {
            sum += stoneValue[k];
        }

        for(int k = i; k < j; k++)
        {
            curr += stoneValue[k];

            if(curr < (sum - curr))
            {
                ans = max(ans, fun(stoneValue, i, k) + curr);
            }
            else if(curr > (sum - curr))
            {
                ans = max(ans, fun(stoneValue, k + 1, j) + (sum - curr));
            }
            else
            {
                ans = max(ans, curr + max(fun(stoneValue, i, k), fun(stoneValue, k + 1, j)));
            }
        }

        dp[i][j] = ans;

        return ans;
    }

    int stoneGameV(vector<int> &stoneValue)
    {
        int size = stoneValue.size();
        memset(dp, -1, sizeof(dp));

        return fun(stoneValue, 0, size - 1);
    }
};

// Source https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/

Given an array of positive integers arr, find a pattern of length m that is repeated k or more times.

A pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. 
A pattern is defined by its length and the number of repetitions.

Return true if there exists a pattern of length m that is repeated k or more times, otherwise return false.

 

Example 1:

Input: arr = [1,2,4,4,4,4], m = 1, k = 3
Output: true
Explanation: The pattern (4) of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less.
Example 2:

Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2
Output: true
Explanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times.
Example 3:

Input: arr = [1,2,1,2,1,3], m = 2, k = 3
Output: false
Explanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.
 

Constraints:

2 <= arr.length <= 100
1 <= arr[i] <= 100
1 <= m <= 100
2 <= k <= 100

class Solution
{
public:
    bool containsPattern(vector<int> &arr, int m, int k)
    {
        int count = 0;
        int res = 1;
        for(int i = 0; i < arr.size() - m;)
        {
            if(arr[i] == arr[i + m])
            {
                while(i < arr.size() - m && arr[i] == arr[i + m])
                {
                    count++;
                    if(count == m)
                    {
                        count = 0;
                        res++;
                        if(res == k)
                        {
                            return true;
                        }
                    }
                    i++;
                }
            }
            else
            {
                count = 0;
                res = 1;
                i++;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/

Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive.

A subarray of an array is a consecutive sequence of zero or more values taken out of that array.

Return the maximum length of a subarray with positive product.

 

Example 1:

Input: nums = [1,-2,-3,4]
Output: 4
Explanation: The array nums already has a positive product of 24.
Example 2:

Input: nums = [0,1,-2,-3,-4]
Output: 3
Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.
Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.
Example 3:

Input: nums = [-1,-2,-3,0,1]
Output: 2
Explanation: The longest subarray with positive product is [-1,-2] or [-2,-3].
 

Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109

pos_dp[i] 表示满足nums[k] * ... * nums[i]结果为正，the maximum length of a subarray
neg_dp[i] 表示满足nums[k] * ... * nums[i]结果为负，the maximum length of a subarray

class Solution
{
public:
    int getMaxLen(vector<int> &nums)
    {
        vector<int> pos_dp(nums.size(), 0);
        vector<int> neg_dp(nums.size(), 0);
        if(nums[0] > 0) pos_dp[0] = 1;
        if(nums[0] < 0) neg_dp[0] = 1;
        int maxlen = pos_dp[0];
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] == 0) continue;
            else if(nums[i] > 0)
            {
                pos_dp[i] = 1 + pos_dp[i - 1];
                neg_dp[i] = (neg_dp[i - 1] == 0) ? 0 : 1 + neg_dp[i - 1];
            }
            else
            {
                pos_dp[i] = (neg_dp[i - 1] == 0) ? 0 : 1 + neg_dp[i - 1];
                neg_dp[i] = 1 + pos_dp[i - 1];
            }

            maxlen = maxlen > pos_dp[i] ? maxlen : pos_dp[i];
        }
        return maxlen;
    }
};

// Source https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/

You are given an m x n binary grid grid consisting where 1 represents land and 0 represents water. 
An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.

The grid is said to be connected if we have exactly one island, otherwise is said disconnected.

In one day, we are allowed to change any single land cell (1) into a water cell (0).

Return the minimum number of days to disconnect the grid.

 

Example 1:


Input: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
Output: 2
Explanation: We need at least 2 days to get a disconnected grid.
Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island.
Example 2:

Input: grid = [[1,1]]
Output: 2
Explanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 30
grid[i][j] is either 0 or 1.

// Convert the grid into a graph.
// If there is only one 1, then you need to remove it (because connected definition says only 1 island)
// Find number of connected components
// If connected components>1 return 0
// Find articulation point
// If articulation point is present, then return 1, else return 2

子节点(至少要有一个) <- 关键节点 <- 父节点(至少要有一个)
删掉关键节点会把子节点和父节点之间断开，形成2个connected components

子节点(至少要有一个) <- 关键节点 -> 子节点(至少要有一个)
删掉关键节点会把子节点和子节点之间断开，形成2个connected components

如果不存在关键节点，则只要同时把对角线上的2个cell (1) 变成2个cell (0)，就会形成2个connected components

class Solution
{
public:
    vector<int> adj[910];
    vector<int> v;
    vector<int> vis;
    vector<int> in, low;
    int n, m;
    int timer;

    void dfsArticulation(int node, int par)
    {
        vis[node] = true;
        in[node] = low[node] = timer++;
        int children = 0;
        for (int it : adj[node])
        {
            if (it == par) continue;
            if (vis[it])
            {
                low[node] = min(low[node], in[it]);
            }
            else
            {
                dfsArticulation(it, node);
                low[node] = min(low[node], low[it]);
                if (low[it] >= in[node] && par != -1)
                    v.push_back(node);
                ++children;
            }
        }
        if(par == -1 && children > 1)
            v.push_back(node);
    }

    void dfs(int i)
    {
        vis[i] = true;
        for(auto it : adj[i])
        {
            if(!vis[it]) dfs(it);
        }
    }
    int minDays(vector<vector<int>> &grid)
    {
        n = grid.size();
        m = grid[0].size();
        int dx[] = {1, 0, -1, 0};
        int dy[] = {0, 1, 0, -1};
        int l = 1;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(grid[i][j] == 1)
                {
                    grid[i][j] = l, l++;
                }
            }
        }
        if(l == 2) return 1;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                for(int k = 0; k < 4; k++)
                {
                    int nx = i + dx[k];
                    int ny = j + dy[k];
                    if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                    if(grid[i][j] && grid[nx][ny])
                    {
                        adj[grid[i][j]].push_back(grid[nx][ny]);
                    }
                }
            }
        }

        vis.resize(l, false);
        int c = 0;
        for(int i = 1; i < l; i++)
        {
            if(vis[i] == false)
            {
                dfs(i);
                c++;
            }
        }
        if(c > 1 || c == 0) return 0;

        for(int i = 0; i < l; i++)
        {
            vis[i] = false;
        }
        in.resize(l, -1);
        low.resize(l, -1);

        for (int i = 1; i < l; ++i)
        {
            if (!vis[i])
                dfsArticulation (i, -1);
        }

        if(v.size() > 0) return 1;
        return 2;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/

Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) 
by inserting the elements of nums in order into an initially empty BST. 
Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.

For example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. 
The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.
Return the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.

Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:


Input: nums = [2,1,3]
Output: 1
Explanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.
Example 2:


Input: nums = [3,4,5,1,2]
Output: 5
Explanation: The following 5 arrays will yield the same BST: 
[3,1,2,4,5]
[3,1,4,2,5]
[3,1,4,5,2]
[3,4,1,2,5]
[3,4,1,5,2]
Example 3:


Input: nums = [1,2,3]
Output: 0
Explanation: There are no other orderings of nums that will yield the same BST.
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= nums.length
All integers in nums are distinct.

Input: nums = [3,4,5,1,2]
[3,4,5,1,2]
[3,4,1,5,2]
[3,4,1,2,5]
[3,1,4,5,2]
[3,1,4,2,5]
[3,1,2,4,5]

C(4,2) = 6

Input: nums = [3,4,5,6,1,2]
[3,4,5,6,1,2]
[3,4,5,1,6,2]
[3,4,5,1,2,6]
[3,4,1,5,6,2]
[3,4,1,5,2,6]
[3,4,1,2,5,6]
[3,1,4,5,6,2]
[3,1,4,5,2,6]
[3,1,4,2,5,6]
[3,1,2,4,5,6]

C(5,2) = 10


// no matter how to reorder the tree, the left hand size of the root have to stay at left hand side,
// while the right hand size have to stay at right hand side.
// Assume there a A nodes smaller than root and B nodes bigger than root,
// and there are X ways to reorder left hand side and Y ways to right hand side,
// then we have in totoal X * Y * C(A+B, A) ways.

C(A+B, A) 表示从A+B个位置中随机挑出A个位置，按照顺序把左边子树的数字依次放入A个位置，再按照顺序把右边子树的数字依次放入剩余的B个位置

class Solution
{
    long long big;
    vector<vector<long long>> dp;
public:
    int numOfWays(vector<int> &nums)
    {
        big = 1e9 + 7;
        dp.resize(nums.size(), vector<long long>(nums.size(), 0));
        return helper(nums) - 1;
    }

    long long helper(vector<int> &nums)
    {
        if(nums.size() <= 2) return 1;

        int root = nums[0];
        vector<int> smaller, bigger;
        for(int i = 1; i < nums.size(); ++i)
        {
            if(nums[i] < root)
            {
                smaller.push_back(nums[i]);
            }
            else
            {
                bigger.push_back(nums[i]);
            }
        }

        long long left = helper(smaller);
        long long right = helper(bigger);
        int m = smaller.size() + bigger.size();
        int n = smaller.size() < bigger.size() ? smaller.size() : bigger.size();

        long long c = combination(m, n);

        long long res = (left * right) % big;
        res = (res * c) % big;
        return res;
    }

    long long combination(long long m, long long n)
    {
        if(n == m) return 1;
        else if(n == 0) return 1;
        if(dp[m][n] != 0) return dp[m][n];

        long long res = (combination(m - 1, n) + combination(m - 1, n - 1)) % big;
        dp[m][n] = res;
        return res;
    }
};

// Source https://leetcode.com/problems/matrix-diagonal-sum/

Given a square matrix mat, return the sum of the matrix diagonals.

Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.

 

Example 1:


Input: mat = [[1,2,3],
              [4,5,6],
              [7,8,9]]
Output: 25
Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
Notice that element mat[1][1] = 5 is counted only once.
Example 2:

Input: mat = [[1,1,1,1],
              [1,1,1,1],
              [1,1,1,1],
              [1,1,1,1]]
Output: 8
Example 3:

Input: mat = [[5]]
Output: 5
 

Constraints:

n == mat.length == mat[i].length
1 <= n <= 100
1 <= mat[i][j] <= 100

class Solution
{
public:
    int diagonalSum(vector<vector<int>> &mat)
    {
        int n = mat.size();
        int sum = 0;

        for(int r = 0, c = 0; r < n; r++, c++)
        {
            sum += mat[r][c] ;
        }

        for(int r = 0, c = n - 1; r < n; r++, c--)
        {
            sum += mat[r][c] ;
        }

        if(n & 1) sum -= mat[n / 2][n / 2];

        return sum;
    }
};

// Source https://leetcode.com/problems/number-of-ways-to-split-a-string/

Given a binary string s (a string consisting only of '0's and '1's), we can split s into 3 non-empty strings s1, s2, s3 (s1+ s2+ s3 = s).

Return the number of ways s can be split such that the number of characters '1' is the same in s1, s2, and s3.

Since the answer may be too large, return it modulo 10^9 + 7.

 

Example 1:

Input: s = "10101"
Output: 4
Explanation: There are four ways to split s in 3 parts where each part contain the same number of letters '1'.
"1|010|1"
"1|01|01"
"10|10|1"
"10|1|01"
Example 2:

Input: s = "1001"
Output: 0
Example 3:

Input: s = "0000"
Output: 3
Explanation: There are three ways to split s in 3 parts.
"0|0|00"
"0|00|0"
"00|0|0"
Example 4:

Input: s = "100100010100110"
Output: 12
 

Constraints:

3 <= s.length <= 10^5
s[i] is '0' or '1'.

0000000|0|0
000000|00|0
000000|0|00
00000|000|0
00000|00|00
00000|0|000

等差数列求和
1 + 2 + 3 + ... + n - 2 = (n -2) * (n - 1) / 2 

class Solution
{
public:
    int numWays(string s)
    {
        long ones = 0, z1 = 1, z2 = 1;

        for(auto ch : s) if(ch == '1') ones++;
        if(ones % 3 != 0) return 0;
        if(ones == 0) return (long(s.size() - 2) * long(s.size() - 1) / 2) % 1000000007;
        ones /= 3;

        int i = 0, j = ones;
        while(j) if(s[i++] == '1') j--;
        while(s[i] == '0') i++, z1++;

        j = ones;
        while(j) if(s[i++] == '1') j--;
        while(s[i] == '0') i++, z2++;

        return z1 * z2 % 1000000007;
    }
};

// Source https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/

Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.

Return the length of the shortest subarray to remove.

A subarray is a contiguous subsequence of the array.

 

Example 1:

Input: arr = [1,2,3,10,4,2,3,5]
Output: 3
Explanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.
Another correct solution is to remove the subarray [3,10,4].
Example 2:

Input: arr = [5,4,3,2,1]
Output: 4
Explanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].
Example 3:

Input: arr = [1,2,3]
Output: 0
Explanation: The array is already non-decreasing. We do not need to remove any elements.
Example 4:

Input: arr = [1]
Output: 0
 

Constraints:

1 <= arr.length <= 105
0 <= arr[i] <= 109

left 保存的是从开头递增的
right 保存的是从结尾递减的

class Solution
{
public:
    int findLengthOfShortestSubarray(vector<int> &arr)
    {
        vector<int> right;
        vector<int> left;
        int sz = arr.size();
        int prev = 0;
        int l = 0;
        int ans = 0;
        while(l<sz and arr[l] >= prev)
        {
            left.push_back(arr[l]);
            prev = arr[l];
            l++;
        }
        l = sz - 1;
        prev = INT_MAX;
        while(l >= 0 and arr[l] <= prev)
        {
            right.push_back(arr[l]);
            prev = arr[l];
            l--;
        }
        if(left.size() == sz) return 0;
        int lsz = left.size(), rsz = right.size();
        ans = max(lsz, rsz);

        for(int i = 0; i < right.size(); i++)
        {
            int pos = upper_bound(left.begin(), left.end(), right[i]) - left.begin();

            ans = max(ans, pos + i + 1);
        }
        return sz - ans;
    }
};


// Source https://leetcode.com/problems/count-all-possible-routes/

You are given an array of distinct positive integers locations where locations[i] represents the position of city i. 
You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.

At each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. 
Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.

Notice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).

Return the count of all possible routes from start to finish. Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5
Output: 4
Explanation: The following are all possible routes, each uses 5 units of fuel:
1 -> 3		[3]->[8]
1 -> 2 -> 3	[3]->[6]->[8]
1 -> 4 -> 3	[3]->[4]->[8]
1 -> 4 -> 2 -> 3	[3]->[4]->[6]->[8]
Example 2:

Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6
Output: 5
Explanation: The following are all possible routes:
1 -> 0, used fuel = 1			[3]->[4]
1 -> 2 -> 0, used fuel = 5			[3]->[1]->[4]
1 -> 2 -> 1 -> 0, used fuel = 5		[3]->[1]->[3]->[4]
1 -> 0 -> 1 -> 0, used fuel = 3		[3]->[4]->[3]->[4]
1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5	[3]->[4]->[3]->[4]->[3]->[4]
Example 3:

Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3
Output: 0
Explanation: It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.
 

Constraints:

2 <= locations.length <= 100
1 <= locations[i] <= 109
All integers in locations are distinct.
0 <= start, finish < locations.length
1 <= fuel <= 200

start和finish都是locations的下标
dp[start][fuel] 表示以locations[start]为起点，当前可用燃料为fuel，能够到达locations[finish]的路线数

class Solution
{
public:
    int dp[205][205];
    int solve(vector<int> &locations, int start, int finish, int fuel)
    {
        if(dp[start][fuel] != -1)
            return dp[start][fuel];

        int n = locations.size();
        int ans = 0;
        if(start == finish)
            ans++;

        for(int i = 0; i < n; i++)
        {
            if(i != start && abs(locations[i] - locations[start]) <= fuel)
            {
                ans += solve(locations, i, finish, fuel - abs(locations[i] - locations[start]));
                ans %= 1000000007;
            }
        }
        return dp[start][fuel] = ans;
    }

    int countRoutes(vector<int> &locations, int start, int finish, int fuel)
    {
        memset(dp, -1, sizeof(dp));
        return solve(locations, start, finish, fuel);
    }
};


// Source https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/

Given a string s containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters 
such that the final string does not contain any consecutive repeating characters. You cannot modify the non '?' characters.

It is guaranteed that there are no consecutive repeating characters in the given string except for '?'.

Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them. 
It can be shown that an answer is always possible with the given constraints.

 

Example 1:

Input: s = "?zs"
Output: "azs"
Explanation: There are 25 solutions for this problem. From "azs" to "yzs", all are valid. Only "z" is an invalid modification as the string will consist of consecutive repeating characters in "zzs".
Example 2:

Input: s = "ubv?w"
Output: "ubvaw"
Explanation: There are 24 solutions for this problem. Only "v" and "w" are invalid modifications as the strings will consist of consecutive repeating characters in "ubvvw" and "ubvww".
Example 3:

Input: s = "j?qg??b"
Output: "jaqgacb"
Example 4:

Input: s = "??yw?ipkj?"
Output: "acywaipkja"
 

Constraints:

1 <= s.length <= 100
s consist of lowercase English letters and '?'.

class Solution
{
public:
    string modifyString(string s)
    {
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == '?')
            {
                char x = 'a';
                if(i == 0)
                {
                    while(x == s[i + 1])
                    {
                        x++;
                    }
                }
                else if(i == s.size() - 1)
                {
                    while(x == s[i - 1])
                    {
                        x++;
                    }
                }
                else
                {
                    while(x == s[i - 1] || x == s[i + 1])
                    {
                        x++;
                    }
                }

                s[i] = x;
            }
        }

        return s;
    }
};

// Source https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/

Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules:

Type 1: Triplet (i, j, k) if nums1[i]^2 == nums2[j] * nums2[k] where 0 <= i < nums1.length and 0 <= j < k < nums2.length.
Type 2: Triplet (i, j, k) if nums2[i]^2 == nums1[j] * nums1[k] where 0 <= i < nums2.length and 0 <= j < k < nums1.length.
 

Example 1:

Input: nums1 = [7,4], nums2 = [5,2,8,9]
Output: 1
Explanation: Type 1: (1,1,2), nums1[1]^2 = nums2[1] * nums2[2]. (4^2 = 2 * 8). 
Example 2:

Input: nums1 = [1,1], nums2 = [1,1,1]
Output: 9
Explanation: All Triplets are valid, because 1^2 = 1 * 1.
Type 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i]^2 = nums2[j] * nums2[k].
Type 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]^2 = nums1[j] * nums1[k].
Example 3:

Input: nums1 = [7,7,8,3], nums2 = [1,2,9,7]
Output: 2
Explanation: There are 2 valid triplets.
Type 1: (3,0,2).  nums1[3]^2 = nums2[0] * nums2[2].
Type 2: (3,0,1).  nums2[3]^2 = nums1[0] * nums1[1].
Example 4:

Input: nums1 = [4,7,9,11,23], nums2 = [3,5,1024,12,18]
Output: 0
Explanation: There are no valid triplets.
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
1 <= nums1[i], nums2[i] <= 10^5

class Solution
{
public:
    int numTriplets(vector<int> &nums1, vector<int> &nums2)
    {
        unordered_map<long long int, int> squares1;
        unordered_map<long long int, int> squares2;
        for(long long int i : nums1)
            ++squares1[i * i];
        for(long long int i : nums2)
            ++squares2[i * i];
        auto N1 = nums1.size();
        auto N2 = nums2.size();
        int ret = 0;
        for(int i = 0; i < N1; ++i)
        {
            for(int j = i + 1; j < N1; ++j)
            {
                long long int n = nums1[i];
                auto it = squares2.find(n * nums1[j]);
                if(it != squares2.end())
                    ret += it->second;
            }
        }
        for(int i = 0; i < N2; ++i)
        {
            for(int j = i + 1; j < N2; ++j)
            {
                long long int n = nums2[i];
                auto it = squares1.find(n * nums2[j]);
                if(it != squares1.end())
                    ret += it->second;
            }
        }
        return ret;
    }
};

// Source https://leetcode.com/problems/minimum-time-to-make-rope-colorful/

Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.

Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. 
Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime 
where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.

Return the minimum time Bob needs to make the rope colorful.

 

Example 1:


Input: colors = "abaac", neededTime = [1,2,3,4,5]
Output: 3
Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.
Bob can remove the blue balloon at index 2. This takes 3 seconds.
There are no longer two consecutive balloons of the same color. Total time = 3.
Example 2:


Input: colors = "abc", neededTime = [1,2,3]
Output: 0
Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.
Example 3:


Input: colors = "aabaa", neededTime = [1,2,3,4,1]
Output: 2
Explanation: Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.
There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.
 

Constraints:

n == colors.length == neededTime.length
1 <= n <= 105
1 <= neededTime[i] <= 104
colors contains only lowercase English letters.

class Solution
{
public:
    int minCost(string s, vector<int> &cost)
    {
        int cur = 0, n = s.size(), res = 0;
        for (int i = 1; i < n; i++)
        {
            if (s[cur] == s[i])
            {
                if (cost[cur] > cost[i])
                {
                    res += cost[i];
                }
                else
                {
                    res += cost[cur];
                    cur = i;
                }
            }
            else
                cur = i;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/

Alice and Bob have an undirected graph of n nodes and 3 types of edges:

Type 1: Can be traversed by Alice only.
Type 2: Can be traversed by Bob only.
Type 3: Can by traversed by both Alice and Bob.
Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, 
find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. 
The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return -1 if it's impossible for the graph to be fully traversed by Alice and Bob.

 

Example 1:



Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2
Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.
Example 2:



Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0
Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.
Example 3:



Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
Output: -1
Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.
 

 

Constraints:

1 <= n <= 10^5
1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)
edges[i].length == 3
1 <= edges[i][0] <= 3
1 <= edges[i][1] < edges[i][2] <= n
All tuples (typei, ui, vi) are distinct.

class Solution
{
public:
    int find(int a, vector<int> &parent)
    {
        if(a != parent[a]) parent[a] = find(parent[a], parent);
        return parent[a];
    }

    bool isSame(int a, int b, vector<int> &parent)
    {
        return find(a, parent) == find(b, parent);
    }

    void Union(int a, int b, vector<int> &parent, vector<int> &rank)
    {
        if(isSame(a, b, parent)) return;
        a = find(a, parent);
        b = find(b, parent);

        if(rank[a] > rank[b]) parent[b] = a;
        else if(rank[b] > rank[a]) parent[a] = b;
        else
        {
            parent[b] = a;
            rank[a]++;
        }
    }

    int maxNumEdgesToRemove(int n, vector<vector<int>> &edges)
    {
        vector<int> parenta(n), ranka(n, 1), parentb(n), rankb(n, 1);

        for(int i = 0; i < n; i++) parenta[i] = i, parentb[i] = i;
        int remove = 0;

        for(int i = 0; i < edges.size(); i++)
        {
            int t = edges[i][0], a = edges[i][1], b = edges[i][2];
            if(t == 3)
            {
                if(isSame(a - 1, b - 1, parenta)) remove++;
                else Union(a - 1, b - 1, parenta, ranka), Union(a - 1, b - 1, parentb, rankb);
            }
        }

        for(int i = 0; i < edges.size(); i++)
        {
            int t = edges[i][0], a = edges[i][1], b = edges[i][2];
            if(t == 1)
            {
                if(isSame(a - 1, b - 1, parenta)) remove++;
                else Union(a - 1, b - 1, parenta, ranka);
            }
            else if(t == 2)
            {
                if(isSame(a - 1, b - 1, parentb)) remove++;
                else Union(a - 1, b - 1, parentb, rankb);
            }
        }

        for(int i = 0; i < n - 1; i++)
        {
            if(!isSame(i, i + 1, parenta) || !isSame(i, i + 1, parentb)) return -1;
        }
        return remove;
    }
};


// Source https://leetcode.com/problems/special-positions-in-a-binary-matrix/

Given a rows x cols matrix mat, where mat[i][j] is either 0 or 1, return the number of special positions in mat.

A position (i,j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).

 

Example 1:

Input: mat = [[1,0,0],
              [0,0,1],
              [1,0,0]]
Output: 1
Explanation: (1,2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.
Example 2:

Input: mat = [[1,0,0],
              [0,1,0],
              [0,0,1]]
Output: 3
Explanation: (0,0), (1,1) and (2,2) are special positions. 
Example 3:

Input: mat = [[0,0,0,1],
              [1,0,0,0],
              [0,1,1,0],
              [0,0,0,0]]
Output: 2
Example 4:

Input: mat = [[0,0,0,0,0],
              [1,0,0,0,0],
              [0,1,0,0,0],
              [0,0,1,0,0],
              [0,0,0,1,1]]
Output: 3
 

Constraints:

rows == mat.length
cols == mat[i].length
1 <= rows, cols <= 100
mat[i][j] is 0 or 1.

class Solution
{
public:
    int numSpecial(vector<vector<int>> &mat)
    {
        int n = mat.size();
        int m = mat[0].size();
        vector<int> row(n, 0);
        vector<int> col(m, 0);
        int ret = 0;
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (mat[i][j] == 1)
                {
                    row[i]++;
                    col[j]++;
                }
            }
        }
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (mat[i][j] == 1 && row[i] == 1 && col[j] == 1) ret++;
            }
        }
        return ret;
    }
};

// Source https://leetcode.com/problems/count-unhappy-friends/

You are given a list of preferences for n friends, where n is always even.

For each person i, preferences[i] contains a list of friends sorted in the order of preference. 
In other words, a friend earlier in the list is more preferred than a friend later in the list. Friends in each list are denoted by integers from 0 to n-1.

All the friends are divided into pairs. The pairings are given in a list pairs, where pairs[i] = [xi, yi] denotes xi is paired with yi and yi is paired with xi.

However, this pairing may cause some of the friends to be unhappy. A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:

x prefers u over y, and
u prefers x over v.
Return the number of unhappy friends.

 

Example 1:

Input: n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]
Output: 2
Explanation:
Friend 1 is unhappy because:
- 1 is paired with 0 but prefers 3 over 0, and
- 3 prefers 1 over 2.
Friend 3 is unhappy because:
- 3 is paired with 2 but prefers 1 over 2, and
- 1 prefers 3 over 0.
Friends 0 and 2 are happy.
Example 2:

Input: n = 2, preferences = [[1], [0]], pairs = [[1, 0]]
Output: 0
Explanation: Both friends 0 and 1 are happy.
Example 3:

Input: n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]
Output: 4
 

Constraints:

2 <= n <= 500
n is even.
preferences.length == n
preferences[i].length == n - 1
0 <= preferences[i][j] <= n - 1
preferences[i] does not contain i.
All values in preferences[i] are unique.
pairs.length == n/2
pairs[i].length == 2
xi != yi
0 <= xi, yi <= n - 1
Each person is contained in exactly one pair.

在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心：

x 与 u 的亲近程度胜过 x 与 y，且
u 与 x 的亲近程度胜过 u 与 v

实际上u也会不开心

u 与 x 的亲近程度胜过 u 与 v，且
x 与 u 的亲近程度胜过 x 与 y

// match[x][y] : the matching perferences/points between friend x and friend y
// for any two pairs x1->x2, y1->y2. if match[x1][y1] > match[x1][x2] && match[y1][x1] > match[y1][y2],
// then x1 and y1 are unhappy friends. Use hashtable to store the friends, since there can be duplicate.

class Solution
{
public:
    int unhappyFriends(int n, vector<vector<int>> &preferences, vector<vector<int>> &pairs)
    {
        int match[n][n];
        memset(match, 0, sizeof(match));

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < preferences[i].size(); j++)
            {
                match[i][preferences[i][j]] = n - 1 - j;
            }
        }

        unordered_set<int> st;

        int len = pairs.size(), res = 0;
        for (int i = 1; i < len; i++)
        {
            for (int j = 0; j < i; j++)
            {
                int x = pairs[i][0], x_cur = pairs[i][1];
                int y = pairs[j][0], y_cur = pairs[j][1];

                if (match[x][y] > match[x][x_cur] && match[y][x] > match[y][y_cur])
                    st.insert(x), st.insert(y);
                if (match[x][y_cur] > match[x][x_cur] && match[y_cur][x] > match[y_cur][y])
                    st.insert(x), st.insert(y_cur);
                if (match[x_cur][y_cur] > match[x_cur][x] && match[y_cur][x_cur] > match[y_cur][y])
                    st.insert(x_cur), st.insert(y_cur);
                if (match[x_cur][y] > match[x_cur][x] && match[y][x_cur] > match[y][y_cur])
                    st.insert(x_cur), st.insert(y);
            }
        }

        return st.size();
    }
};


// Source https://leetcode.com/problems/min-cost-to-connect-all-points/

You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].

The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.

Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.

 

Example 1:


Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
Explanation: 

We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.
Example 2:

Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18
 

Constraints:

1 <= points.length <= 1000
-106 <= xi, yi <= 106
All pairs (xi, yi) are distinct.

class DSU
{
private:
    int *parent;
    int *rank;
    int n;
public:
    DSU(int n)
    {
        this->n = n;
        parent = new int[n];
        rank = new int[n];
        for(int i = 0; i < n; i++)
        {
            parent[i] = -1;
            rank[i] = 1;
        }
    }
    ~DSU()
    {
        delete [] parent;
        delete [] rank;
    }
    int find(int a)
    {
        if(parent[a] == -1)
            return a;
        return parent[a] = find(parent[a]);
    }
    void unionSet(int a, int b)
    {
        int s1 = find(a);
        int s2 = find(b);

        if(s1 == s2)
            return ;

        if(rank[s1] > rank[s2])
        {
            parent[s2] = s1;
            rank[s1] += rank[s2];
        }
        else
        {
            parent[s1] = s2;
            rank[s2] += rank[s1];
        }
        return ;
    }
};

class Solution
{
public:
    int manhattanDist(vector<int> &a, vector<int> &b)
    {
        return (abs(a[0] - b[0]) + abs(a[1] - b[1]));
    }

    int minCostConnectPoints(vector<vector<int>> &points)
    {
        vector<pair<int,pair<int,int>>> edgeList;
        int n = points.size();
        for(int i = 0; i < n; i++)
        {
            for(int j = i + 1; j < n; j++)
            {
                int dist = manhattanDist(points[i], points[j]);
                edgeList.push_back(make_pair(dist, make_pair(i, j)));
            }
        }
        sort(edgeList.begin(), edgeList.end());

        DSU dset(n);

        int minCost = 0;
        for(auto &edge : edgeList)
        {
            int dist = edge.first;
            int s = edge.second.first;
            int d = edge.second.second;

            if(dset.find(s) != dset.find(d))
            {
                dset.unionSet(s, d);
                minCost += dist;
            }
        }

        return minCost;
    }
};

// Source https://leetcode.com/problems/check-if-string-is-transformable-with-substring-sort-operations/

Given two strings s and t, you want to transform string s into string t using the following operation any number of times:

Choose a non-empty substring in s and sort it in-place so the characters are in ascending order.
For example, applying the operation on the underlined substring in "14234" results in "12344".
                                                                                                                     ――
Return true if it is possible to transform string s into string t. Otherwise, return false.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "84532", t = "34852"
Output: true
Explanation: You can transform s into t using the following sort operations:
"84532" (from index 2 to 3) -> "84352"
"84352" (from index 0 to 2) -> "34852"
Example 2:

Input: s = "34521", t = "23415"
Output: true
Explanation: You can transform s into t using the following sort operations:
"34521" -> "23451"
"23451" -> "23415"
Example 3:

Input: s = "12345", t = "12435"
Output: false
Example 4:

Input: s = "1", t = "2"
Output: false
 

Constraints:

s.length == t.length
1 <= s.length <= 105
s and t only contain digits from '0' to '9'.

Choose a non-empty substring in s and sort it in-place so the characters are in ascending order.
排序后，数字小的字符会向左移动（不会向右移动），数字大的字符会向右移动（不会向左移动）

数字j小 ... 数字k大 不可能变成 数字k大 ... 数字j小

class Solution
{
public:
    bool isTransformable(string s, string t)
    {
        int n = s.size();
        vector<queue<int>> v(10);

        for(int i = 0; i < n; i++)
        {
            v[s[i] - '0'].push(i);
        }

        for(int i = 0; i < n; i++)
        {
            int k = t[i] - '0';
            if(!v[k].size()) return false;

            for(int j = 0; j < k; j++)
            {
                if(v[j].size() && v[j].front() < v[k].front())
                    return false;
            }
            v[k].pop();
        }

        return true;
    }
};


// Source https://leetcode.com/problems/sum-of-all-odd-length-subarrays/

Given an array of positive integers arr, calculate the sum of all possible odd-length subarrays.

A subarray is a contiguous subsequence of the array.

Return the sum of all odd-length subarrays of arr.

 

Example 1:

Input: arr = [1,4,2,5,3]
Output: 58
Explanation: The odd-length subarrays of arr and their sums are:
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
Example 2:

Input: arr = [1,2]
Output: 3
Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.
Example 3:

Input: arr = [10,11,12]
Output: 66
 

Constraints:

1 <= arr.length <= 100
1 <= arr[i] <= 1000

dp[i] 表示以arr[i]为右边界，the sum of all possible odd-length subarrays.
有2种情况
只有1个元素arr[i]的子数组
至少有3个元素的子数组
... + arr[i-1] + arr[i]
dp[i] = dp[i-2] + (i /2) * (arr[i-1] + arr[i]) + arr[i]

class Solution
{
public:
    int sumOddLengthSubarrays(vector<int> &arr)
    {
        int n = arr.size();
        int res = arr[0];
        if (n >= 2)
        {
            res += arr[1];
            vector<int> dp(n);
            dp[0] = arr[0];
            dp[1] = arr[1];
            for (int i = 2; i < n; ++i)
            {
                dp[i] = dp[i - 2] + (arr[i] + arr[i - 1]) * (i / 2) + arr[i];
                res += dp[i];
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/

We have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. 
The ith request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. 
Both starti and endi are 0-indexed.

Return the maximum total sum of all requests among all permutations of nums.

Since the answer may be too large, return it modulo 109 + 7.

 

Example 1:

Input: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]
Output: 19
Explanation: One permutation of nums is [2,1,3,4,5] with the following result: 
requests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8
requests[1] -> nums[0] + nums[1] = 2 + 1 = 3
Total sum: 8 + 3 = 11.
A permutation with a higher total sum is [3,5,4,2,1] with the following result:
requests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11
requests[1] -> nums[0] + nums[1] = 3 + 5  = 8
Total sum: 11 + 8 = 19, which is the best that you can do.
Example 2:

Input: nums = [1,2,3,4,5,6], requests = [[0,1]]
Output: 11
Explanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].
Example 3:

Input: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]
Output: 47
Explanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].
 

Constraints:

n == nums.length
1 <= n <= 105
0 <= nums[i] <= 105
1 <= requests.length <= 105
requests[i].length == 2
0 <= starti <= endi < n

最大的num放到请求次数最多的下标

class Solution
{
public:
    int maxSumRangeQuery(vector<int> &nums, vector<vector<int>> &requests)
    {
        int n = nums.size();
        vector<int> difference(n + 1, 0);

        for ( auto &request : requests )
        {
            int start = request[0];
            int end = request[1];

            difference[start]++;
            difference[end + 1]--;
        }

        for ( size_t i = 1; i <= n; ++i )
            difference[i] += difference[i - 1];

        sort( nums.begin(), nums.end(), greater<int>() );
        sort( difference.begin(), difference.end(), greater<int>() );

        int64_t res = 0;
        int MOD = 1e9 + 7;

        for ( int i = 0; i < n; ++i )
            res = ( res + ( (int64_t)nums[i] * difference[i] ) % MOD ) % MOD;

        return res;
    }
};

// Source https://leetcode.com/problems/make-sum-divisible-by-p/

Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. 
It is not allowed to remove the whole array.

Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.

A subarray is defined as a contiguous block of elements in the array.

 

Example 1:

Input: nums = [3,1,4,2], p = 6
Output: 1
Explanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.
Example 2:

Input: nums = [6,3,5,2], p = 9
Output: 2
Explanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.
Example 3:

Input: nums = [1,2,3], p = 3
Output: 0
Explanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= p <= 109

the sum of the subarray that you need to remove 除以p的余数 必须等于 the sum of the whole array 除以p的余数
such that the sum of the remaining elements is divisible by p

class Solution
{
public:
    int minSubarray(vector<int> &nums, int p)
    {
        long long total_sum = 0;

        for (long long num : nums)
        {
            total_sum += num % p;
        }

        if (total_sum % p == 0)
        {
            return 0;
        }

        long long rest = total_sum % p;

        int ans = INT32_MAX;

        int N = nums.size();
        long long sum = 0;

        map<long long, int> m;
        m[0] = -1;
        for (int i = 0; i < N; ++i)
        {
            sum += nums[i];

            long long subtracted = sum - rest;
            long long r = subtracted % p;

            if (m.count(r))
            {
                ans = std::min(ans, i - m[r]);
            }

            m[ sum % p ] = i;
        }

        if (ans == INT32_MAX || ans == nums.size())
        {
            return -1;
        }

        return ans;
    }
};

// Source https://leetcode.com/problems/strange-printer-ii/

There is a strange printer with the following two special requirements:

On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.
Once the printer has used a color for the above operation, the same color cannot be used again.
You are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid.

Return true if it is possible to print the matrix targetGrid, otherwise, return false.

 

Example 1:



Input: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
Output: true
Example 2:



Input: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]
Output: true
Example 3:

Input: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]
Output: false
Explanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns.
Example 4:

Input: targetGrid = [[1,1,1],[3,1,3]]
Output: false

Constraints:

m == targetGrid.length
n == targetGrid[i].length
1 <= m, n <= 60
1 <= targetGrid[row][col] <= 60

如果某个颜色点 B 存在于颜色矩形 A 中，则颜色矩形 A 应该先被打印，后打印 B ，即存在一条 A->B 的有向边。
采用邻接表，其中每个顶点 color 表示一种颜色矩形，它的有向邻接边表示 color 先被打印，邻接点的颜色矩形后被打印。
对邻接表进行拓扑排序，判断这张有向图是否是有向无环图，就可以判断是否可以从初始矩阵打印出目标矩阵。

Input: targetGrid = [[1,1,1],[3,1,3]]
Output: false

颜色1 -> 颜色3
颜色3 -> 颜色1
有环

class Solution {
public:
    vector<int> g[65];
    bool isPrintable(vector<vector<int>>& targetGrid) {
        int n  = targetGrid.size();
        int m = targetGrid[0].size();
        int in[65];
        memset(in,0,sizeof(in));
        for(int i=1;i<=60;i++)g[i].clear();
        for(int color=1;color<=60;color++)
        {
            int ur=1000,uc=1000;
            int lr=-1,lc=-1;
            int flag = 0;
            for(int i=1;i<=n;i++)
            {
                for(int j=1;j<=m;j++)
                {
                    if(targetGrid[i-1][j-1] == color)
                    {
                        flag = 1;
                        ur = min(ur,i);
                        uc = min(uc,j);
                        lr = max(lr,i);
                        lc = max(lc,j);
                    }
                }
            }

            if(!flag)continue;
            for(int i=ur;i<=lr;i++)
            {
                for(int j=uc;j<=lc;j++)
                {
                    if(targetGrid[i-1][j-1] != color)
                    {
                        in[targetGrid[i-1][j-1]]++;
                        g[color].push_back(targetGrid[i-1][j-1]);
                    }
                }
            }

        }

        queue<int> q;
        for(int i=1;i<=60;i++)
        {
            if(in[i] == 0)q.push(i);
        }

        while(!q.empty())
        {
            int f = q.front();q.pop();
            for(auto v:g[f])
            {
                in[v]--;
                if(in[v] == 0)q.push(v);
            }
        }

        for(int i=1;i<=60;i++)
        {
            if(in[i]!=0)return 0;
        }
        return 1;
    }
};

// Source https://leetcode.com/problems/rearrange-spaces-between-words/

You are given a string text of words that are placed among some number of spaces. 
Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word.

Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. 
If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text.

Return the string after rearranging the spaces.

 

Example 1:

Input: text = "  this   is  a sentence "
Output: "this   is   a   sentence"
Explanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.
Example 2:

Input: text = " practice   makes   perfect"
Output: "practice   makes   perfect "
Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string.
 

Constraints:

1 <= text.length <= 100
text consists of lowercase English letters and ' '.
text contains at least one word.

class Solution
{
public:
    string reorderSpaces(string text)
    {
        int n = text.size(), blank = 0, word = 0;
        vector<string> v;
        istringstream in(text);
        string t, res = "";
        while (in >> t)
        {
            ++word;
            v.push_back(t);
        }
        for (int i = 0; i < n; ++i)
        {
            if (text[i] == ' ')
                ++blank;
        }
        if (word == 1)
        {
            res += v[0];
            while (blank-- > 0) res += " ";
            return res;
        }
        int r = blank % (word - 1);
        blank /= (word - 1);
        for (int i = 0; i < v.size(); ++i)
        {
            res += v[i];
            if (i == v.size() - 1) break;
            int tmp = blank;
            while (tmp-- > 0) res += " ";
        }
        while (r-- > 0) res += " ";
        return res;
    }
};

// Source https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/

Given a string s, return the maximum number of unique substrings that the given string can be split into.

You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. 
However, you must split the substrings such that all of them are unique.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: s = "ababccc"
Output: 5
Explanation: One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times.
Example 2:

Input: s = "aba"
Output: 2
Explanation: One way to split maximally is ['a', 'ba'].
Example 3:

Input: s = "aa"
Output: 1
Explanation: It is impossible to split the string any further.
 

Constraints:

1 <= s.length <= 16

s contains only lower case English letters.

class Solution
{
private:
    int max_cnt = 0;
    unordered_set<string>st;
    void dfs(string s, int idx)
    {
        if(idx == s.size())
        {
            max_cnt = max(max_cnt, (int)st.size());
            return;
        }

        for(int i = idx; i < s.size(); i++)
        {
            string temp = s.substr(idx, i - idx + 1);
            if(st.count(temp) != 0) continue;
            st.insert(temp);
            dfs(s, i + 1);
            st.erase(temp);
        }
        return;
    }
public:
    int maxUniqueSplit(string s)
    {
        dfs(s, 0);
        return max_cnt;
    }
};

// Source https://leetcode.com/problems/maximum-non-negative-product-in-a-matrix/

You are given a rows x cols matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.

Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (rows - 1, cols - 1), 
find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path.

Return the maximum non-negative product modulo 109 + 7. If the maximum product is negative return -1.

Notice that the modulo is performed after getting the maximum product.

 

Example 1:

Input: grid = [[-1,-2,-3],
               [-2,-3,-3],
               [-3,-3,-2]]
Output: -1
Explanation: It's not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1.
Example 2:

Input: grid = [[1,-2,1],
               [1,-2,1],
               [3,-4,1]]
Output: 8
Explanation: Maximum non-negative product is in bold (1 * 1 * -2 * -4 * 1 = 8).
Example 3:

Input: grid = [[1, 3],
               [0,-4]]
Output: 0
Explanation: Maximum non-negative product is in bold (1 * 0 * -4 = 0).
Example 4:

Input: grid = [[ 1, 4,4,0],
               [-2, 0,0,1],
               [ 1,-1,1,1]]
Output: 2
Explanation: Maximum non-negative product is in bold (1 * -2 * 1 * -1 * 1 * 1 = 2).
 

Constraints:

1 <= rows, cols <= 15
-4 <= grid[i][j] <= 4

dp_max[i][j] 表示从[0,0]到[i,j]，the maximum product
dp_min[i][j] 表示从[0,0]到[i,j]，the minimum product

class Solution
{
public:
    int mod = 1000000007, m, n;
    int maxProductPath(vector<vector<int>> &grid)
    {
        m = grid.size(), n = grid[0].size();
        long long dp_max[m][n], dp_min[m][n];
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(i == 0 && j == 0)
                    dp_max[i][j] = dp_min[i][j] = grid[i][j];
                else
                {
                    long long up_min = i > 0 ? dp_min[i - 1][j] : dp_min[i][j - 1];
                    long long left_min = j > 0 ? dp_min[i][j - 1] : dp_min[i - 1][j];

                    long long up_max = i > 0 ? dp_max[i - 1][j] : dp_max[i][j - 1];
                    long long left_max = j > 0 ? dp_max[i][j - 1] : dp_max[i - 1][j];

                    long long a = max(up_max, left_max);
                    long long b = min(up_min, left_min);

                    dp_max[i][j] = max(a * grid[i][j], b * grid[i][j]);
                    dp_min[i][j] = min(a * grid[i][j], b * grid[i][j]);
                }
            }
        }
        return dp_max[m - 1][n - 1] < 0 ? -1 : dp_max[m - 1][n - 1] % mod;
    }
};

// Source https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/

You are given two groups of points where the first group has size1 points, the second group has size2 points, and size1 >= size2.

The cost of the connection between any two points are given in an size1 x size2 matrix 
where cost[i][j] is the cost of connecting point i of the first group and point j of the second group. 
The groups are connected if each point in both groups is connected to one or more points in the opposite group. 
In other words, each point in the first group must be connected to at least one point in the second group, 
and each point in the second group must be connected to at least one point in the first group.

Return the minimum cost it takes to connect the two groups.

 

Example 1:


Input: cost = [[15, 96], [36, 2]]
Output: 17
Explanation: The optimal way of connecting the groups is:
1--A
2--B
This results in a total cost of 17.
Example 2:


Input: cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
Output: 4
Explanation: The optimal way of connecting the groups is:
1--A
2--B
2--C
3--A
This results in a total cost of 4.
Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.
Example 3:

Input: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
Output: 10
 

Constraints:

size1 == cost.length
size2 == cost[i].length
1 <= size1, size2 <= 12
size1 >= size2
0 <= cost[i][j] <= 100

dp[i][s] 表示the first group的前i个point连接the second group，the second group被连接的point对应的状态为s，the minimum cost it takes to connect the two groups

class Solution
{
public:
    int connectTwoGroups(vector<vector<int>> &cost)
    {
        int n = cost.size(), m = cost[0].size();
        int lim = 1 << m;
        long dp[n + 1][lim];
        for (int i = 0; i <= n; i++)
        {
            for (int s = 0; s < lim; ++s)
            {
                dp[i][s] = INT_MAX;
            }
        }
        dp[0][0] = 0;
        for (int i = 1; i <= n; i++)
       {
            for (int s = 0; s < lim; s++)
            {
                for (int j = 0; j < m; j++)
                {
                    dp[i][s | (1 << j)] = min( { dp[i][s | (1 << j)], dp[i - 1][s] + cost[i - 1][j], dp[i][s] + cost[i - 1][j] } );
               }
           }
       }

        return dp[n][lim - 1];
    }
};

dp[i][s] 表示the first group的前i+1个point连接the second group，the second group被连接的point对应的状态为s，the minimum cost it takes to connect the two groups

class Solution
{
public:
    int dp[12][4096];
    int connectTwoGroups(vector<vector<int>> &cost)
    {
        int n = cost.size();
        int m = cost[0].size();
        int lim = 1 << m;

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < lim; j++)
            {
                dp[i][j] = INT32_MAX;
                for (int k = 0; k < m; k++)
                {
                    if (j & (1 << k))
                    {
                        if (i != 0 && dp[i - 1][j ^ (1 << k)] != INT32_MAX )
                        {
                            dp[i][j] = min(dp[i][j], dp[i - 1][j ^ (1 << k)] + cost[i][k]);
                        }

                        if (i != 0 && (dp[i - 1][j] != INT32_MAX))
                        {
                            dp[i][j] = min(dp[i][j], dp[i - 1][j] + cost[i][k]);
                        }

                        if (i == 0 && (j ^ (1 << k)) == 0)
                        {
                            dp[i][j] = cost[i][k];
                        }
                        else
                        {
                            if (dp[i][j ^ (1 << k)] != INT32_MAX)
                            {
                                dp[i][j] = min(dp[i][j], dp[i][j ^ (1 << k)] + cost[i][k]);
                            }
                        }
                    }
                }
            }
        }

        return dp[n - 1][lim - 1];
    }
};


// Source https://leetcode.com/problems/crawler-log-folder/

The Leetcode file system keeps a log each time some user performs a change folder operation.

The operations are described below:

"../" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).
"./" : Remain in the same folder.
"x/" : Move to the child folder named x (This folder is guaranteed to always exist).
You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.

The file system starts in the main folder, then the operations in logs are performed.

Return the minimum number of operations needed to go back to the main folder after the change folder operations.

 

Example 1:



Input: logs = ["d1/","d2/","../","d21/","./"]
Output: 2
Explanation: Use this change folder operation "../" 2 times and go back to the main folder.
Example 2:



Input: logs = ["d1/","d2/","./","d3/","../","d31/"]
Output: 3
Example 3:

Input: logs = ["d1/","../","../","../"]
Output: 0
 

Constraints:

1 <= logs.length <= 103
2 <= logs[i].length <= 10
logs[i] contains lowercase English letters, digits, '.', and '/'.
logs[i] follows the format described in the statement.
Folder names consist of lowercase English letters and digits.

class Solution
{
public:
    int minOperations(vector<string> &logs)
    {
        int count = 0;
        for(int i = 0; i < logs.size(); i++)
        {
            if(logs[i] == "../")
            {
                if(count > 0) count--;
            }
            else if(logs[i] == "./") continue;
            else count++;
        }

        return count;
    }
};

// Source https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/

You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. 
You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.

You are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). 
This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. 
Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.

You can stop the wheel at any time, including before serving all customers. 
If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. 
Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.

Return the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.

你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。
你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。
给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。
这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。
你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。
注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。
返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。

Example 1:


Input: customers = [8,3], boardingCost = 5, runningCost = 6
Output: 3
Explanation: The numbers written on the gondolas are the number of people currently there.
1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.
2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.
3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.
The highest profit was $37 after rotating the wheel 3 times.
Example 2:

Input: customers = [10,9,6], boardingCost = 6, runningCost = 4
Output: 7
Explanation:
1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.
2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.
3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.
4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.
5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.
6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.
7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.
The highest profit was $122 after rotating the wheel 7 times.

Example 3:

Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92
Output: -1
Explanation:
1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.
2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.
3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.
4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.
5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.
The profit was never positive, so return -1.
Example 4:

Input: customers = [10,10,6,4,7], boardingCost = 3, runningCost = 8
Output: 9
Explanation:
1. 10 customers arrive, 4 board and 6 wait, the wheel rotates. Current profit is 4 * $3 - 1 * $8 = $4.
2. 10 customers arrive, 4 board and 12 wait, the wheel rotates. Current profit is 8 * $3 - 2 * $8 = $8.
3. 6 customers arrive, 4 board and 14 wait, the wheel rotates. Current profit is 12 * $3 - 3 * $8 = $12.
4. 4 customers arrive, 4 board and 14 wait, the wheel rotates. Current profit is 16 * $3 - 4 * $8 = $16.
5. 7 customers arrive, 4 board and 17 wait, the wheel rotates. Current profit is 20 * $3 - 5 * $8 = $20.
6. 4 board and 13 wait, the wheel rotates. Current profit is 24 * $3 - 6 * $8 = $24.
7. 4 board and 9 wait, the wheel rotates. Current profit is 28 * $3 - 7 * $8 = $28.
8. 4 board and 5 wait, the wheel rotates. Current profit is 32 * $3 - 8 * $8 = $32.
9. 4 board and 1 waits, the wheel rotates. Current profit is 36 * $3 - 9 * $8 = $36.
10. 1 board and 0 wait, the wheel rotates. Current profit is 37 * $3 - 10 * $8 = $31.
The highest profit was $36 after rotating the wheel 9 times.
 

Constraints:

n == customers.length
1 <= n <= 105
0 <= customers[i] <= 50
1 <= boardingCost, runningCost <= 100

class Solution
{
public:
    int minOperationsMaxProfit(vector<int> &customers, int boardingCost, int runningCost)
    {
        int x = runningCost / boardingCost;
        if(x >= 4) return -1;

        int wait = 0, profit = 0, maxProfit = INT_MIN, ans = -1;
        int r = 0;
        while(true)
        {
            if(r < customers.size()) wait += customers[r];
            int board = min(wait, 4);
            wait -= board;

            profit += board * boardingCost - runningCost;

            if(profit > 0 && profit > maxProfit)
            {
                ans = r + 1;
                maxProfit = profit;
            }

            if(r >= customers.size() && wait == 0) break;
            r++;
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/throne-inheritance/

A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born.

The kingdom has a well-defined order of inheritance that consists of the king as the first member. 
Let's define the recursive function Successor(x, curOrder), which given a person x and the inheritance order so far, 
returns who should be the next person after x in the order of inheritance.

Successor(x, curOrder):
    if x has no children or all of x's children are in curOrder:
        if x is the king return null
        else return Successor(x's parent, curOrder)
    else return x's oldest child who's not in curOrder
For example, assume we have a kingdom that consists of the king, his children Alice and Bob (Alice is older than Bob), and finally Alice's son Jack.

In the beginning, curOrder will be ["king"].
Calling Successor(king, curOrder) will return Alice, so we append to curOrder to get ["king", "Alice"].
Calling Successor(Alice, curOrder) will return Jack, so we append to curOrder to get ["king", "Alice", "Jack"].
Calling Successor(Jack, curOrder) will return Bob, so we append to curOrder to get ["king", "Alice", "Jack", "Bob"].
Calling Successor(Bob, curOrder) will return null. Thus the order of inheritance will be ["king", "Alice", "Jack", "Bob"].
Using the above function, we can always obtain a unique order of inheritance.

Implement the ThroneInheritance class:

ThroneInheritance(string kingName) Initializes an object of the ThroneInheritance class. The name of the king is given as part of the constructor.
void birth(string parentName, string childName) Indicates that parentName gave birth to childName.
void death(string name) Indicates the death of name. The death of the person doesn't affect the Successor function nor the current inheritance order. You can treat it as just marking the person as dead.
string[] getInheritanceOrder() Returns a list representing the current order of inheritance excluding dead people.

一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。

这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。

Successor(x, curOrder):
    如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：
        如果 x 是国王，那么返回 null
        否则，返回 Successor(x 的父亲, curOrder)
    否则，返回 x 不在 curOrder 中最年长的孩子

比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。

一开始， curOrder 为 [“king”].
调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [“king”, “Alice”] 。
调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”] 。
调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”, “Bob”] 。
调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [“king”, “Alice”, “Jack”, “Bob”] 。
通过以上的函数，我们总是能得到一个唯一的继承顺序。

请你实现 ThroneInheritance 类：

ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。
void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。
void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。
string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。

Example 1:

Input
["ThroneInheritance", "birth", "birth", "birth", "birth", "birth", "birth", "getInheritanceOrder", "death", "getInheritanceOrder"]
[["king"], ["king", "andy"], ["king", "bob"], ["king", "catherine"], ["andy", "matthew"], ["bob", "alex"], ["bob", "asha"], [null], ["bob"], [null]]
Output
[null, null, null, null, null, null, null, ["king", "andy", "matthew", "bob", "alex", "asha", "catherine"], null, ["king", "andy", "matthew", "alex", "asha", "catherine"]]

Explanation
ThroneInheritance t= new ThroneInheritance("king"); // order: king
t.birth("king", "andy"); // order: king > andy
t.birth("king", "bob"); // order: king > andy > bob
t.birth("king", "catherine"); // order: king > andy > bob > catherine
t.birth("andy", "matthew"); // order: king > andy > matthew > bob > catherine
t.birth("bob", "alex"); // order: king > andy > matthew > bob > alex > catherine
t.birth("bob", "asha"); // order: king > andy > matthew > bob > alex > asha > catherine
t.getInheritanceOrder(); // return ["king", "andy", "matthew", "bob", "alex", "asha", "catherine"]
t.death("bob"); // order: king > andy > matthew > bob > alex > asha > catherine
t.getInheritanceOrder(); // return ["king", "andy", "matthew", "alex", "asha", "catherine"]
 

Constraints:

1 <= kingName.length, parentName.length, childName.length, name.length <= 15
kingName, parentName, childName, and name consist of lowercase English letters only.
All arguments childName and kingName are distinct.
All name arguments of death will be passed to either the constructor or as childName to birth first.
For each call to birth(parentName, childName), it is guaranteed that parentName is alive.
At most 105 calls will be made to birth and death.
At most 10 calls will be made to getInheritanceOrder.

class ThroneInheritance
{
    unordered_set<string> dead;
    unordered_map<string, vector<string>> children;
    string king;
public:
    ThroneInheritance(string kingName)
    {
        king = kingName;
    }

    void birth(string parentName, string childName)
    {
        children[parentName].push_back(childName);
    }

    void death(string name)
    {
        dead.insert(name);
    }

    void dfs(string &s, vector<string> &v)
    {
        if(dead.find(s) == dead.end()) v.push_back(s);
        for(auto c : children[s]) dfs(c, v);
    }

    vector<string> getInheritanceOrder()
    {
        vector<string> v;
        dfs(king, v);
        return v;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/

We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.

You are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.

All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. 
This means the number of employees leaving is equal to the number of employees moving in. 
For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, 
there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.

Return the maximum number of achievable requests.

我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。

给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。

一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。
意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。
比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。

请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。

Example 1:


Input: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
Output: 5
Explantion: Let's see the requests:
From building 0 we have employees x and y and both want to move to building 1.
From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.
From building 2 we have employee z and they want to move to building 0.
From building 3 we have employee c and they want to move to building 4.
From building 4 we don't have any requests.
We can achieve the requests of users x and b by swapping their places.
We can achieve the requests of users y, a and z by swapping the places in the 3 buildings.
Example 2:


Input: n = 3, requests = [[0,0],[1,2],[2,1]]
Output: 3
Explantion: Let's see the requests:
From building 0 we have employee x and they want to stay in the same building 0.
From building 1 we have employee y and they want to move to building 2.
From building 2 we have employee z and they want to move to building 1.
We can achieve all the requests. 
Example 3:

Input: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]
Output: 4
 

Constraints:

1 <= n <= 20
1 <= requests.length <= 16
requests[i].length == 2
0 <= fromi, toi < n

class Solution
{
public:
    int vis[21];
    int sol(vector<vector<int>> &req, int i, int c)
    {
        if(i == req.size())
        {
            for(auto x : vis)
            {
                if(x != 0) return 0;
            }
            return c;
        }
        int ans = 0;
        vis[req[i][0]]--;
        vis[req[i][1]]++;
        ans = max(ans, sol(req, i + 1, c + 1));
        vis[req[i][0]]++;
        vis[req[i][1]]--;
        ans = max(ans, sol(req, i + 1, c));
        return ans;
    }
    int maximumRequests(int n, vector<vector<int>> &req)
    {
        memset(vis, 0, sizeof vis);
        return sol(req, 0, 0);
    }
};


// Source https://leetcode.com/problems/design-parking-system/

Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.

Implement the ParkingSystem class:

ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. 
The number of slots for each parking space are given as part of the constructor.
bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. 
carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. 
A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.
 

Example 1:

Input
["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]
[[1, 1, 0], [1], [2], [3], [1]]
Output
[null, true, true, false, false]

Explanation
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // return true because there is 1 available slot for a big car
parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car
parkingSystem.addCar(3); // return false because there is no available slot for a small car
parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.
 

Constraints:

0 <= big, medium, small <= 1000
carType is 1, 2, or 3
At most 1000 calls will be made to addCar

class ParkingSystem
{
public:
    unordered_map<int, int >slot;
    ParkingSystem(int big, int medium, int small)
    {
        slot[1] = big;
        slot[2] = medium;
        slot[3] = small;
    }

    bool addCar(int carType)
    {
        if(slot.find(carType) != slot.end() && slot[carType] > 0)
        {
            slot[carType]--;
            return true;
        }
        return false;
    }
};

// Source https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/

LeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, 
the security system saves the worker's name and the time when it was used. 
The system emits an alert if any worker uses the key-card three or more times in a one-hour period.

You are given a list of strings keyName and keyTime where [keyName[i], keyTime[i]] corresponds to a person's name and the time when their key-card was used in a single day.

Access times are given in the 24-hour time format "HH:MM", such as "23:51" and "09:49".

Return a list of unique worker names who received an alert for frequent keycard use. Sort the names in ascending order alphabetically.

Notice that "10:00" - "11:00" is considered to be within a one-hour period, while "22:51" - "23:52" is not considered to be within a one-hour period.

 

Example 1:

Input: keyName = ["daniel","daniel","daniel","luis","luis","luis","luis"], keyTime = ["10:00","10:40","11:00","09:00","11:00","13:00","15:00"]
Output: ["daniel"]
Explanation: "daniel" used the keycard 3 times in a one-hour period ("10:00","10:40", "11:00").
Example 2:

Input: keyName = ["alice","alice","alice","bob","bob","bob","bob"], keyTime = ["12:01","12:00","18:00","21:00","21:20","21:30","23:00"]
Output: ["bob"]
Explanation: "bob" used the keycard 3 times in a one-hour period ("21:00","21:20", "21:30").
Example 3:

Input: keyName = ["john","john","john"], keyTime = ["23:58","23:59","00:01"]
Output: []
Example 4:

Input: keyName = ["leslie","leslie","leslie","clare","clare","clare","clare"], keyTime = ["13:00","13:20","14:00","18:00","18:51","19:30","19:49"]
Output: ["clare","leslie"]
 

Constraints:

1 <= keyName.length, keyTime.length <= 105
keyName.length == keyTime.length
keyTime[i] is in the format "HH:MM".
[keyName[i], keyTime[i]] is unique.
1 <= keyName[i].length <= 10
keyName[i] contains only lowercase English letters.

class Solution
{
public:
    vector<string> alertNames(vector<string> &keyName, vector<string> &keyTime)
    {
        int n = keyTime.size();
        vector<pair<string, int>> accesses;
        accesses.reserve(n);
        for (int i = 0; i < n; ++i)
        {
            accesses.push_back({keyName[i], convertToMinutes(keyTime[i])});
        }
        sort(accesses.begin(), accesses.end(), [](auto & p1, auto & p2)
        {
            return p1.second < p2.second;
        });
        deque<pair<string, int>> window;
        unordered_map<string, int> userInWindow; // (name, occurrence in window)
        set<string> ans;
        for (auto &access : accesses)
        {
            while (!window.empty() && access.second - window[0].second > 60)
            {
                --userInWindow[window[0].first];
                window.pop_front();
            }
            window.push_back(access);
            ++userInWindow[access.first];
            if (userInWindow[access.first] >= 3)
            {
                ans.insert(access.first);
            }
        }
        return vector<string>(ans.begin(), ans.end());
    }

private:
    int convertToMinutes(string &s)
    {
        return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(3));
    }
};

// Source https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/

You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row 
and colSum[j] is the sum of the elements of the jth column of a 2D matrix. 
In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.

Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.

Return a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.

 

Example 1:

Input: rowSum = [3,8], colSum = [4,7]
Output: [[3,0],
         [1,7]]
Explanation: 
0th row: 3 + 0 = 3 == rowSum[0]
1st row: 1 + 7 = 8 == rowSum[1]
0th column: 3 + 1 = 4 == colSum[0]
1st column: 0 + 7 = 7 == colSum[1]
The row and column sums match, and all matrix elements are non-negative.
Another possible matrix is: [[1,2],
                             [3,5]]
Example 2:

Input: rowSum = [5,7,10], colSum = [8,6,8]
Output: [[0,5,0],
         [6,1,0],
         [2,0,8]]
 

Constraints:

1 <= rowSum.length, colSum.length <= 500
0 <= rowSum[i], colSum[i] <= 108
sum(rows) == sum(columns)

class Solution
{
public:
    vector<vector<int>> restoreMatrix(vector<int> &rowSum, vector<int> &colSum)
    {
        vector<vector<int>> result(rowSum.size(), vector<int>(colSum.size(), 0));

        int r = rowSum.size(), c = colSum.size();

        for(int i = 0; i < r; i++)
        {
            for(int j = 0; j < c; j++)
            {
                if(rowSum[i] == 0 || colSum[j] == 0)
                    continue;

                result[i][j] = min(rowSum[i], colSum[j]);

                rowSum[i] -= result[i][j];
                colSum[j] -= result[i][j];
            }
        }

        return result;
    }
};
