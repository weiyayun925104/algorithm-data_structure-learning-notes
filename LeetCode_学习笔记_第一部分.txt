// Source : https://leetcode.com/problems/two-sum/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        for(int i = 0 ; i < nums.size() ; i ++)
            for(int j = i + 1 ; j < nums.size() ; j ++)
                if(nums[i] + nums[j] == target)
                    return {i, j};

        throw invalid_argument("the input has no solution");
    }
};


void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<int> nums = {0,4,3,5};
    int target = 10;
    print_vec(Solution().twoSum(nums, target));

    return 0;
}

// Source : https://leetcode.com/problems/two-sum/description/

#include <iostream>
#include <vector>
#include <cassert>
#include <unordered_map>

using namespace std;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        unordered_map<int,int> record;
        for(int i = 0 ; i < nums.size() ; i ++){

            int complement = target - nums[i];
            if(record.find(complement) != record.end()){
                return {i, record[complement]};
            }

            record[nums[i]] = i;
        }

        throw invalid_argument("the input has no solution");
    }
};


void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    const int nums[] = {0,4,3,0};
    vector<int> nums_vec( nums, nums + sizeof(nums)/sizeof(int) );
    int target = 0;
    print_vec(Solution().twoSum(nums_vec, target));

    return 0;
}

// Source : https://leetcode.com/problems/two-sum/description/

import java.util.HashMap;

public class Solution {

    public int[] twoSum(int[] nums, int target) {

        HashMap<Integer, Integer> record = new HashMap<Integer, Integer>();
        for(int i = 0 ; i < nums.length; i ++){

            int complement = target - nums[i];
            if(record.containsKey(complement)){
                int[] res = {i, record.get(complement)};
                return res;
            }

            record.put(nums[i], i);
        }

        throw new IllegalStateException("the input has no solution");
    }

    private static void printArr(int[] nums){
        for(int num: nums)
            System.out.print(num + " ");
        System.out.println();
    }

    public static void main(String[] args) {

        int[] nums = {0, 4, 3, 0};
        int target = 0;
        printArr((new Solution()).twoSum(nums, target));
    }
}

// Source : https://leetcode.com/problems/add-two-numbers/description/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        ListNode *p1 = l1, *p2 = l2;
        ListNode *dummyHead = new ListNode(-1);
        ListNode* cur = dummyHead;
        int carried = 0;
        while(p1 || p2 ){
            int a = p1 ? p1->val : 0;
            int b = p2 ? p2->val : 0;
            cur->next = new ListNode((a + b + carried) % 10);
            carried = (a + b + carried) / 10;

            cur = cur->next;
            p1 = p1 ? p1->next : NULL;
            p2 = p2 ? p2->next : NULL;
        }

        cur->next = carried ? new ListNode(1) : NULL;
        ListNode* ret = dummyHead->next;
        delete dummyHead;
        return ret;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

#include <iostream>
#include <string>
#include <cassert>

using namespace std;

class Solution {
public:
    int lengthOfLongestSubstring(string s) {

        int freq[256] = {0};

        int l = 0, r = -1; // sliding window: s[l...r]
        int res = 0;

        while(r + 1 < s.size()){

            while(r + 1 < s.size() && freq[s[r + 1]] == 0)
                freq[s[++r]] ++;

            res = max(res, r - l + 1);

            if(r + 1 < s.size()){
                freq[s[++r]] ++;
                while(l <= r && freq[s[r]] == 2)
                    freq[s[l++]] --;
            }
        }

        return res;
    }
};

int main() {

    cout << Solution().lengthOfLongestSubstring( "abcabcbb" )<<endl; //3
    cout << Solution().lengthOfLongestSubstring( "bbbbb" )<<endl;    //1
    cout << Solution().lengthOfLongestSubstring( "pwwkew" )<<endl;   //3
    cout << Solution().lengthOfLongestSubstring( "c" )<<endl;        //1
    cout << Solution().lengthOfLongestSubstring( "" )<<endl;         //0

    return 0;
}

// Source : https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

public class Solution {
    public int lengthOfLongestSubstring(String s) {

        int[] freq = new int[256];

        int l = 0, r = -1; // sliding window: s[l...r]
        int res = 0;

        while(r + 1 < s.length()){

            while(r + 1 < s.length() && freq[s.charAt(r+1)] == 0)
                freq[s.charAt(++r)] ++;

            res = Math.max(res, r - l + 1);

            if(r + 1 < s.length()){
                freq[s.charAt(++r)] ++;
                while(l <= r && freq[s.charAt(r)] == 2)
                    freq[s.charAt(l++)] --;
            }
        }

        return res;
    }

    public static void main(String[] args) {

        System.out.println((new Solution()).lengthOfLongestSubstring( "abcabcbb" ));
        System.out.println((new Solution()).lengthOfLongestSubstring( "bbbbb" ));
        System.out.println((new Solution()).lengthOfLongestSubstring( "pwwkew" ));
        System.out.println((new Solution()).lengthOfLongestSubstring( "" ));
    }
}

// Source : https://leetcode.com/problems/median-of-two-sorted-arrays/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {

        int len = nums1.size() + nums2.size();

        int a = select(nums1, 0, (int)nums1.size() - 1,
                       nums2, 0, (int)nums2.size() - 1, len / 2);
        if(len % 2) return a;

        int b = select(nums1, 0, (int)nums1.size() - 1,
                       nums2, 0, (int)nums2.size() - 1, len / 2 - 1);
        return (a + b) / 2.0;
    }

private:
    int select(const vector<int>& nums1, int l1, int r1,
               const vector<int>& nums2, int l2, int r2, int k){

        if(l1 > r1) return nums2[l2 + k];
        if(l2 > r2) return nums1[l1 + k];

        int len1 = r1 - l1 + 1, len2 = r2 - l2 + 1;
        int mid1 = len1 / 2, mid2 = len2 / 2;
        int e1 = nums1[l1 + mid1], e2 = nums2[l2 + mid2];
        if(mid1 + mid2 < k){
            if(e1 > e2)
                return select(nums1, l1, r1, nums2, l2 + mid2 + 1, r2, k - mid2 - 1);
            else
                return select(nums1, l1 + mid1 + 1, r1, nums2, l2, r2, k - mid1 - 1);
        }
        else{
            if(e1 > e2)
                return select(nums1, l1, l1 + mid1 - 1, nums2, l2, r2, k);
            else
                return select(nums1, l1, r1, nums2, l2, l2 + mid2 - 1, k);
        }
    }
};


int main() {

    vector<int> nums11 = {1, 3};
    vector<int> nums12 = {2};
    cout << Solution().findMedianSortedArrays(nums11, nums12) << endl;
    // 2

    vector<int> nums21 = {1, 2};
    vector<int> nums22 = {3, 4};
    cout << Solution().findMedianSortedArrays(nums21, nums22) << endl;
    // 2.5

    vector<int> nums31 = {};
    vector<int> nums32 = {1};
    cout << Solution().findMedianSortedArrays(nums31, nums32) << endl;
    // 1

    vector<int> nums41 = {1, 2, 2};
    vector<int> nums42 = {1, 2, 3};
    cout << Solution().findMedianSortedArrays(nums41, nums42) << endl;
    // 2

    return 0;
}

// Source : https://leetcode.com/problems/longest-palindromic-substring/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {

        if(s == "") return s;

        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, -1)); // s[a...b]
        for(int len = n; len >= 1; len --)
            for(int start = 0; start + len - 1 < n; start ++)
                if(dfs(s, start, start + len - 1, dp))
                    return s.substr(start, len);
        return "";
    }

private:
    int dfs(const string& s, int a, int b,
             vector<vector<int>>& dp){

        if(a > b) return dp[a][b] = 0;
        if(a == b || (a + 1 == b && s[a] == s[b])) return dp[a][b] = 1;
        if(dp[a][b] != -1) return dp[a][b];

        if(s[a] != s[b]) return dp[a][b] = 0;
        return dp[a][b] = dfs(s, a + 1, b - 1, dp);
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/reverse-integer/description/

#include <iostream>

using namespace std;

class Solution {
public:
    int reverse(int x) {

        if(x == 0)
            return x;

        int sign = x > 0 ? 1 : -1;

        long long num = abs((long long)x);
        long long reverseNum = 0;
        while(num){
            reverseNum = reverseNum * 10 + num % 10;
            num /= 10;
        }

        reverseNum *= sign;
        if(reverseNum > INT_MAX || reverseNum < INT_MIN)
            return 0;
        return reverseNum;
    }
};


int main() {

    cout << Solution().reverse(123) << endl;
    cout << Solution().reverse(-123) << endl;
    cout << Solution().reverse(12) << endl;
    cout << Solution().reverse(INT_MAX) << endl;
    cout << Solution().reverse(INT_MIN) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/regular-expression-matching/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    bool isMatch(const string& s, const string& p) {

        vector<vector<int>> dp(s.size(), vector<int>(p.size(), -1));
        return match(s, 0, p, 0, dp);
    }

private:
    bool match(const string& s, int sl, const string& p, int pl,
               vector<vector<int>>& dp){

        if(sl == s.size()) return no_more_match(p, pl);
        if(pl == p.size()) return false;

        if(dp[sl][pl] != -1) return dp[sl][pl];

        if(pl + 1 < p.size() && p[pl + 1] == '*'){
            if(s[sl] == p[pl] || p[pl] == '.')
                return dp[sl][pl] = (match(s, sl + 1, p, pl, dp) || match(s, sl, p, pl + 2, dp));
            else
                return dp[sl][pl] = match(s, sl, p, pl + 2, dp);
        }
        else if(s[sl] == p[pl] || p[pl] == '.')
            return dp[sl][pl] = match(s, sl + 1, p, pl + 1, dp);
        return dp[sl][pl] = false;
    }

    bool no_more_match(const string& p, int pl){
        int i;
        for(i = pl; i < p.size(); i += 2)
            if(i + 1 < p.size() && p[i + 1] != '*') return false;
        return i == p.size();
    }
};


int main() {

    cout << Solution().isMatch("aa", "a") << endl; // false
    cout << Solution().isMatch("aa", "a*") << endl; // true
    cout << Solution().isMatch("ab", ".*") << endl; // true
    cout << Solution().isMatch("aab", "c*a*b") << endl; // true
    cout << Solution().isMatch("mississippi", "mis*is*p*") << endl; // false
    cout << Solution().isMatch("ab", ".*c") << endl; // false
    cout << Solution().isMatch("a", ".*..a") << endl; // false
    cout << Solution().isMatch("", ".*") << endl; // true

    return 0;
}

// Source : https://leetcode.com/problems/container-with-most-water/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
public:
    int maxArea(vector<int>& height) {

        assert(height.size() >= 2);

        int l = 0, r = height.size() - 1;
        int area = 0;
        while(l < r){
            area = max(area , min(height[l], height[r]) * (r - l));
            if(height[l] < height[r])
                l ++;
            else
                r --;
        }
        return area;
    }
};


int main() {

    vector<int> nums1 = {1, 1};
    cout << Solution().maxArea(nums1) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/integer-to-roman/description/

#include <iostream>
#include <cmath>

using namespace std;

class Solution {
public:
    string intToRoman(int num) {

        string res = "";
        string one[] = {"I", "X", "C", "M", ""}, five[] = {"V", "L", "D", ""};
        for(int k = 3; k >= 0; k --){
            int b = (int)pow(10, k);
            if(num >= b){
                int x = num / b;
                res += rome(x, one[k], five[k], one[k + 1]);
                num %= b;
            }
        }
        return res;
    }

private:
    string rome(int x, string one, string five, string ten){
        if(x <= 3)
            return string(x, one[0]);
        else if(x == 4)
            return one + five;
        else if(x <= 8)
            return five + string(x - 5, one[0]);
        // x == 9
        return one + ten;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/roman-to-integer/description/

#include <iostream>
#include <unordered_map>

using namespace std;

class Solution {
public:
    int romanToInt(string s) {

        unordered_map<char, int> map = {
                {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};

        int res = 0;
        for(int i = 0; i < s.size(); i ++)
            if(i + 1 < s.size() && map[s[i]] < map[s[i + 1]]){
                res += map[s[i + 1]] - map[s[i]];
                i ++;
            }
            else
                res += map[s[i]];

        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/longest-common-prefix/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {

        if(strs.size() == 0)
            return "";

        string res = strs[0];

        for(int i = 1 ; i < strs.size() ; i ++){
            for(int j = 0 ; j < res.size() ; j ++)
                if(j >= strs[i].size() || res[j] != strs[i][j]){
                    res = res.substr(0, j);
                    break;
                }
        }

        return res;
    }
};


int main() {

    vector<string> strs1 = {"flower","flow","flight"};
    cout << Solution().longestCommonPrefix(strs1) << endl;

    vector<string> strs2 = {"dog","racecar","car"};
    cout << Solution().longestCommonPrefix(strs2) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/3sum/

#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

class Solution {

public:
    vector<vector<int>> threeSum(vector<int>& nums) {

        unordered_map<int, int> counter;
        for(int i = 0 ; i < nums.size() ; i ++)
            counter[nums[i]] ++;

        vector<vector<int>> res;

        if(counter[0] >= 3)
            res.push_back({0, 0, 0});

        // Remove duplication
        sort(nums.begin(), nums.end());
        vector<int>::iterator iter = unique(nums.begin(), nums.end());
        nums.erase(iter, nums.end());

        for(int i = 0 ; i < nums.size() ; i ++)
            for(int j = i + 1 ; j < nums.size() ; j ++){

                if(nums[i] * 2 + nums[j] == 0 && counter[nums[i]] >= 2)
                    res.push_back({nums[i], nums[i], nums[j]});

                if(nums[i] + nums[j] * 2 == 0 && counter[nums[j]] >= 2)
                    res.push_back({nums[i], nums[j], nums[j]});

                int c = 0 - nums[i] - nums[j];
                if(c > nums[j] && counter[c] != 0)
                    res.push_back({nums[i], nums[j], c});
            }

        return res;
    }
};

int main() {

    vector<int> nums1 = {-1, 0, 1, 2, -1, -4};
    vector<vector<int>> res = Solution().threeSum(nums1);
    for( int i = 0 ; i < res.size() ; i ++ ){
        for( int j = 0 ; j < res[i].size() ; j ++ )
            cout<<res[i][j]<<" ";
        cout<<endl;
    }

    return 0;
}

// Source : https://leetcode.com/problems/3sum-closest/

#include <iostream>
#include <vector>
#include <cassert>
#include <stdexcept>

using namespace std;

class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {

        assert(nums.size() >= 3);

        sort(nums.begin(), nums.end());

        int diff = abs(nums[0] + nums[1] + nums[2] - target);
        int res = nums[0] + nums[1] + nums[2];

        for(int i = 0 ; i < nums.size() ; i ++){

            int l = i + 1, r = nums.size() - 1;
            int t = target - nums[i];
            while(l < r){
                if(nums[l] + nums[r] == t)
                    return nums[i] + nums[l] + nums[r];
                else{

                    if(abs(nums[l] + nums[r] - t) < diff){
                        diff = abs(nums[l] + nums[r] - t);
                        res = nums[i] + nums[l] + nums[r];
                    }

                    if( nums[l] + nums[r] < t )
                        l ++;
                    else   // nums[l] + nums[r] > t
                        r --;
                }
            }
        }

        return res;
    }
};


int main() {

    vector<int> nums1 = {0, 0, 0};
    int target1 = 1;
    cout << Solution().threeSumClosest(nums1, target ) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/

#include <iostream>
#include <vector>
#include <string>
#include <cassert>

using namespace std;

class Solution {

private:
    const string letterMap[10] = {
            " ",    //0
            "",     //1
            "abc",  //2
            "def",  //3
            "ghi",  //4
            "jkl",  //5
            "mno",  //6
            "pqrs", //7
            "tuv",  //8
            "wxyz"  //9
    };

    vector<string> res;

    void findCombination(const string &digits, int index, const string &s){

        if(index == digits.size()){
            res.push_back(s);
            return;
        }

        char c = digits[index];
        assert(c >= '0' && c <= '9' && c != '1');
        string letters = letterMap[c - '0'];
        for(int i = 0 ; i < letters.size() ; i ++)
            findCombination(digits, index+1, s + letters[i]);

        return;
    }

public:
    vector<string> letterCombinations(string digits) {

        res.clear();
        if(digits == "")
            return res;

        findCombination(digits, 0, "");

        return res;
    }
};


void printVec(const vector<string>& vec){
    for(string s: vec)
        cout << s << endl;
}

int main() {

    printVec(Solution().letterCombinations("234"));

    return 0;
}

// Source : https://leetcode.com/problems/4sum/

#include <iostream>
#include <vector>
#include <cassert>
#include <stdexcept>

using namespace std;

class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {

        int n = nums.size();

        vector<vector<int>> res;
        if(n < 4)
            return res;

        sort(nums.begin(), nums.end());
        for(int i = 0 ; i <= n - 4 ; i = nextNumberIndex(nums, i))
            for (int j = i + 1; j <= n - 3; j = nextNumberIndex(nums, j)) {

                int t = target - nums[i] - nums[j];

                if(nums[j+1] + nums[j+2] > t || nums[n-1] + nums[n-2] < t)
                    continue;

                int p1 = j + 1;
                int p2 = nums.size() - 1;
                if (p1 >= p2)
                    break;

                while (p1 < p2) {
                    if (nums[p1] + nums[p2] == t) {
                        res.push_back({nums[i], nums[j], nums[p1], nums[p2]});

                        p1 = nextNumberIndex(nums, p1);
                        p2 = preNumberIndex(nums, p2);
                    }
                    else if (nums[p1] + nums[p2] < t)
                        p1 = nextNumberIndex(nums, p1);
                    else // nums[p1] + nums[p2] > t
                        p2 = preNumberIndex(nums, p2);
                }
            }

        return res;
    }

private:
    int nextNumberIndex( const vector<int> &nums , int index ){
        for( int i = index + 1 ; i < nums.size() ; i ++ )
            if( nums[i] != nums[index] )
                return i;
        return nums.size();
    }

    int preNumberIndex( const vector<int> &nums , int index ){
        for( int i = index-1 ; i >= 0 ; i -- )
            if( nums[i] != nums[index] )
                return i;
        return -1;
    }
};


void print_vec(const vector<vector<int>>& vec){
    for(const vector<int>& v: vec){
        for(int e: v)
            cout << e << " ";
        cout << endl;
    }
}

int main() {

    vector<int> nums1 = {1, 0, -1, 0, -2, 2};
    int target1 = 0;
    print_vec(Solution().fourSum(nums1, target1));

    return 0;
}

// Source : https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/

#include <iostream>
#include <cassert>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* createLinkedList(int arr[], int n){

    if(n == 0)
        return NULL;

    ListNode* head = new ListNode(arr[0]);
    ListNode* curNode = head;
    for(int i = 1 ; i < n ; i ++){
        curNode->next = new ListNode(arr[i]);
        curNode = curNode->next;
    }

    return head;
}

void printLinkedList(ListNode* head){

    if(head == NULL){
        cout<<"NULL"<<endl;
        return;
    }

    ListNode* curNode = head;
    while(curNode != NULL){
        cout << curNode->val;
        if(curNode->next != NULL)
            cout << " -> ";
        curNode = curNode->next;
    }

    cout << endl;

    return;
}

void deleteLinkedList(ListNode* head){

    ListNode* curNode = head;
    while(curNode != NULL){
        ListNode* delNode = curNode;
        curNode = curNode->next;
        delete delNode;
    }

    return;
}

class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {

        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        int length = 0;
        for(ListNode* cur = dummyHead->next ; cur != NULL ; cur = cur->next)
            length ++;

        int k = length - n;
        assert(k >= 0);
        ListNode* cur = dummyHead;
        for(int i = 0 ; i < k ; i ++)
            cur = cur->next;

        ListNode* delNode = cur->next;
        cur->next = delNode->next;
        delete delNode;

        ListNode* retNode = dummyHead->next;
        delete dummyHead;
        return retNode;
    }
};

int main() {

    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(int);

    ListNode* head = createLinkedList(arr, n);
    printLinkedList(head);

    head = Solution().removeNthFromEnd(head, 2);
    printLinkedList(head);

    deleteLinkedList(head);

    return 0;
}

// Source : https://leetcode.com/problems/valid-parentheses/description/

#include <iostream>
#include <stack>
#include <cassert>

using namespace std;

class Solution {
public:
    bool isValid(string s) {

        stack<char> stack;
        for( int i = 0 ; i < s.size() ; i ++ )
            if( s[i] == '(' || s[i] == '{' || s[i] == '[')
                stack.push(s[i]);
            else{

                if( stack.size() == 0 )
                    return false;

                char c = stack.top();
                stack.pop();

                char match;
                if( s[i] == ')' )
                    match = '(';
                else if( s[i] == ']' )
                    match = '[';
                else{
                    assert( s[i] == '}' );
                    match = '{';
                }

                if(c != match)
                    return false;
            }

        if( stack.size() != 0 )
            return false;

        return true;
    }
};


void printBool(bool res){
    cout << (res ? "True" : "False") << endl;
}

int main() {

    printBool(Solution().isValid("()"));
    printBool(Solution().isValid("()[]{}"));
    printBool(Solution().isValid("(]"));
    printBool(Solution().isValid("([)]"));

    return 0;
}

// Source : https://leetcode.com/problems/merge-two-sorted-lists/description/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

        ListNode* dummyHead = new ListNode(-1);
        ListNode* p = dummyHead;
        ListNode* l1p = l1;
        ListNode* l2p = l2;
        while(l1p != NULL && l2p != NULL){
            if(l1p->val < l2p->val){
                p->next = l1p;
                l1p = l1p->next;
            }
            else{
                p->next = l2p;
                l2p = l2p->next;
            }

            p = p->next;
        }

        if(l1p != NULL)
            p->next = l1p;
        else
            p->next = l2p;

        ListNode* ret = dummyHead->next;
        dummyHead->next = NULL;
        delete dummyHead;

        return ret;
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/generate-parentheses/description/

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>

using namespace std;

class Solution {

public:
    vector<string> generateParenthesis(int n) {

        vector<string> res;
        generate(n, n, "", res);
        return res;
    }

private:
    void generate(int left, int right, const string& cur, vector<string>& res){

        if(left == 0 && right == 0){
            res.push_back(cur);
            return;
        }

        if(left)
            generate(left - 1, right, cur + '(', res);

        if(right && left < right)
            generate(left, right - 1, cur + ')', res);
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/merge-k-sorted-lists/description/

#include <iostream>
#include <vector>
#include <cassert>
#include <queue>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class CompareListNode{
public:
    bool operator()(ListNode* node1, ListNode* node2){
        return node1->val > node2->val;
    }
};

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        if(lists.size() == 0)
            return NULL;

        ListNode* dummyHead = new ListNode(-1);
        ListNode* curNode = dummyHead;

        priority_queue<ListNode*, vector<ListNode*>, CompareListNode> q;
        for(ListNode* node: lists)
            if(node != NULL)
                q.push(node);

        while(!q.empty()){

            ListNode* nextNode = q.top();
            q.pop();


            curNode->next = nextNode;
            if(nextNode->next != NULL)
                q.push(nextNode->next);

            nextNode->next = NULL;
            curNode = curNode->next;
        }

        ListNode* ret = dummyHead->next;
        delete dummyHead;
        return ret;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/swap-nodes-in-pairs/description/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* createLinkedList(int arr[], int n){

    if(n == 0)
        return NULL;

    ListNode* head = new ListNode(arr[0]);
    ListNode* curNode = head;
    for(int i = 1 ; i < n ; i ++){
        curNode->next = new ListNode(arr[i]);
        curNode = curNode->next;
    }

    return head;
}

void printLinkedList(ListNode* head){

    if(head == NULL){
        cout<<"NULL"<<endl;
        return;
    }

    ListNode* curNode = head;
    while(curNode != NULL){
        cout << curNode->val;
        if(curNode->next != NULL)
            cout << " -> ";
        curNode = curNode->next;
    }

    cout << endl;

    return;
}

void deleteLinkedList(ListNode* head){

    ListNode* curNode = head;
    while(curNode != NULL){
        ListNode* delNode = curNode;
        curNode = curNode->next;
        delete delNode;
    }

    return;
}

class Solution {
public:
    ListNode* swapPairs(ListNode* head) {

        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* p = dummyHead;
        while(p->next && p->next->next){
            ListNode* node1 = p->next;
            ListNode* node2 = node1->next;
            ListNode* next = node2->next;
            node2->next = node1;
            node1->next = next;
            p->next = node2;
            p = node1;
        }

        ListNode* retHead = dummyHead->next;
        delete dummyHead;

        return retHead;
    }
};

int main() {

    int arr[] = {1, 2, 3, 4};
    int n = sizeof(arr) / sizeof(int);

    ListNode* head = createLinkedList(arr, n);
    printLinkedList(head);

    head = Solution().swapPairs(head);
    printLinkedList(head);

    deleteLinkedList(head);

    return 0;
}

// Source : https://leetcode.com/problems/reverse-nodes-in-k-group/description/

#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* createLinkedList(const vector<int>& arr){

    if(arr.size() == 0)
        return NULL;

    ListNode* head = new ListNode(arr[0]);
    ListNode* curNode = head;
    for(int i = 1 ; i < arr.size() ; i ++){
        curNode->next = new ListNode(arr[i]);
        curNode = curNode->next;
    }

    return head;
}

void printLinkedList(ListNode* head){

    ListNode* curNode = head;
    while(curNode != NULL){
        cout << curNode->val << " -> ";
        curNode = curNode->next;
    }

    cout << "NULL" << endl;

    return;
}

void deleteLinkedList(ListNode* head){

    ListNode* curNode = head;
    while(curNode != NULL){
        ListNode* delNode = curNode;
        curNode = curNode->next;
        delete delNode;
    }

    return;
}

class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {

        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = head;

        ListNode* pre = dummyHead;
        while(pre && pre->next){

            ListNode* end = pre;
            int i;
            for(i = 0; i < k && end->next; i ++)
                end = end->next;

            if(i != k) break;

            ListNode* next = end->next;

            // reverse from pre->next to end
            ListNode* rhead = reverse(pre->next, end);

            ListNode* tail = pre->next;
            pre->next = rhead;
            tail->next = next;
            pre = tail;
        }

        ListNode* ret = dummyHead->next;
        delete dummyHead;
        return ret;
    }

private:
    ListNode* reverse(ListNode* head, ListNode* end){

        if(head == end) return head;

        ListNode* rhead = reverse(head->next, end);
        head->next->next = head;
        return rhead;
    }
};




int main() {

    vector<int> arr1 = {1, 2, 3, 4, 5};
    ListNode* res1 = Solution().reverseKGroup(createLinkedList(arr1), 3);
    printLinkedList(res1);
    deleteLinkedList(res1);

    return 0;
}

// Source : https://leetcode.com/problems/remove-duplicates-from-sorted-array/


#include <iostream>
#include <vector>
#include <cassert>
#include <stdexcept>

using namespace std;

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {

        if(nums.size() == 0)
            return 0;

        int res = 1;
        int index = nextDifferentCharacterIndex(nums, 1);
        int i = 1;
        while(index < nums.size()){
            res ++;
            nums[i++] = nums[index];
            index = nextDifferentCharacterIndex(nums, index + 1);
        }

        return res;
    }

private:
    int nextDifferentCharacterIndex(const vector<int> &nums, int p){
        for( ; p < nums.size() ; p ++ )
            if( nums[p] != nums[p - 1] )
                break;
        return p;
    }
};


int main() {

    vector<int> nums1 = {1, 1, 2};
    cout << Solution().removeDuplicates(nums1) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/remove-element/

#include <iostream>
#include <vector>
#include <cassert>
#include <stdexcept>

using namespace std;

class Solution {

public:
    int removeElement(vector<int>& nums, int val) {

        int newl = nums.size();
        int i = 0;
        while( i < newl )
            if( nums[i] == val )
                nums[i] = nums[--newl];
            else
                i ++;

        return newl;
    }
};


int main() {

    vector<int> nums = {3, 2, 2, 3};
    int val = 3;

    cout << Solution().removeElement(nums, val) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/implement-strstr/

#include <iostream>

using namespace std;

class Solution {
public:
    int strStr(string haystack, string needle) {

        int n = haystack.size(), m = needle.size();
        if(m > n){return -1;}

        char one = 0;
        int index = 0;
        vector<int> table(256);
        horspool_makeTable(needle, m, table);

        while (index <= (n - m)){
            one = haystack[index+m-1];
            if(one == needle[m-1] && memcmp(haystack.c_str()+index, needle.c_str(), m) == 0)
            {
                return index;
            }
            index += table[(uint8_t)one];
        }
        return -1;
    }

private:
    void horspool_makeTable(const string &pattern, uint32_t m, vector<int> &table)
    {
        uint32_t i;for(i = 0;i < 256;i++){table[i] = m;}for(i = 0;i < m-1;i++){table[(uint8_t)(pattern[i])] = ((m-1)-i);}
    }
};


int main() {

    cout << Solution().strStr("hello", "ll") << endl;
    cout << Solution().strStr("aaaaa", "bba") << endl;

    return 0;
}

// Source : https://leetcode.com/problems/divide-two-integers/

#include <iostream>

using namespace std;

class Solution {
public:
    int divide(int dividend, int divisor) {

        long long res = (long long)dividend / divisor;
        return (res > INT_MAX || res < INT_MIN) ? INT_MAX : res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/next-permutation/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    void nextPermutation(vector<int>& nums) {

        int i;
        for(i = nums.size() - 1; i >= 1; i --)
            if(nums[i - 1] < nums[i]) break;

        if(i == 0){
            reverse(nums.begin(), nums.end());
            return;
        }

        int j;
        for(j = nums.size() - 1; j > i; j --)
            if(nums[j] > nums[i - 1]) break;

        swap(nums[i - 1], nums[j]);
        reverse(nums.begin() + i, nums.end());
    }
};


bool is_sorted(const vector<int>& v){
    for(int i = 1; i < v.size(); i ++)
        if(v[i - 1] > v[i]) return false;
    return true;
}

void print_vec(const vector<int>& v){
    for(int e: v) cout << e << " "; cout << endl;
}

int main() {

    vector<int> nums1 = {1, 2, 3};
    Solution().nextPermutation(nums1);
    print_vec(nums1);
    // 1 3 2

    vector<int> nums2 = {1, 2, 2};
    do{
        Solution().nextPermutation(nums2);
        print_vec(nums2);
    }while(!is_sorted(nums2));

    return 0;
}

// Source : https://leetcode.com/problems/search-in-rotated-sorted-array/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int search(vector<int>& nums, int target) {

        if(nums.size() == 0) return -1;
        int max_index = max_element(nums.begin(), nums.end()) - nums.begin();

        int l = 0, r = max_index;
        while(l <= r){
            int mid = l + (r - l) / 2;
            if(nums[mid] == target) return mid;
            if(target < nums[mid]) r = mid - 1;
            else l = mid + 1;
        }

        l = max_index + 1, r = nums.size() - 1;
        while(l <= r){
            int mid = l + (r - l) / 2;
            if(nums[mid] == target) return mid;
            if(target < nums[mid]) r = mid - 1;
            else l = mid + 1;
        }

        return -1;
    }
};


int main() {

    vector<int> nums1 = {4, 5, 6, 7, 0, 1, 2};
    int target1 = 0;
    cout << Solution().search(nums1, target1) << endl;
    // 4

    vector<int> nums2 = {4, 5, 6, 7, 0, 1, 2};
    int target2 = 3;
    cout << Solution().search(nums2, target2) << endl;
    // -1

    vector<int> nums3 = {1, 3};
    int target3 = 3;
    cout << Solution().search(nums3, target3) << endl;
    // 1

    vector<int> nums4 = {5, 1, 3};
    int target4 = 5;
    cout << Solution().search(nums4, target4) << endl;
    // 0

    vector<int> nums5 = {4, 5, 6, 7, 8, 1, 2, 3};
    int target5 = 8;
    cout << Solution().search(nums5, target5) << endl;
    // 4

    return 0;
}

// Source : https://leetcode.com/problems/search-for-a-range/description/

#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {

        vector<int>::iterator lowerIter = lower_bound(nums.begin(), nums.end(), target);
        int first = -1;
        if(lowerIter != nums.end() && *lowerIter == target)
            first = lowerIter - nums.begin();
        else return {-1, -1};

        vector<int>::iterator upperIter = upper_bound(nums.begin(), nums.end(), target);
        int last = -1;
        if(upperIter != nums.begin()){
            upperIter --;
            last = upperIter - nums.begin();
        }
        else return {-1, -1};

        return {first, last};
    }
};


void printVec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    int nums1[6] = {5, 7, 7, 8, 8, 10};
    int target1 = 8;
    vector<int> vec1(nums1, nums1 + sizeof(nums1) / sizeof(int));

    printVec(Solution().searchRange(vec1, target1));
    // 3, 4

    // ---

    int nums2[1] = {1};
    int target2 = 0;
    vector<int> vec2(nums2, nums2 + sizeof(nums2) / sizeof(int));

    printVec(Solution().searchRange(vec2, target2));
    // -1, -1

    // ---

    int nums3[1] = {1};
    int target3 = 1;
    vector<int> vec3(nums3, nums3 + sizeof(nums3) / sizeof(int));

    printVec(Solution().searchRange(vec3, target3));
    // 0, 0

    // ---
    vector<int> vec4;
    printVec(Solution().searchRange(vec4, 0));
    // -1, -1

    return 0;
}

// Source : https://leetcode.com/problems/search-insert-position/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        return lower_bound(nums.begin(), nums.end(), target) - nums.begin();
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/valid-sudoku/

#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
#include <stdexcept>

using namespace std;

class Solution {
 public:
  bool isValidSudoku(vector<vector<char>>& board) {
    for (auto& x : board) {
      unordered_map<char, int> m;
      for (auto& y : x) {
        if (y != '.') {
          if (m.count(y)) {
            return false;
          }
          ++m[y];
        }
      }
    }
    for (int i = 0; i < 9; ++i) {
      unordered_map<char, int> m;
      for (int j = 0; j < 9; ++j) {
        char c = board[j][i];
        if (c != '.') {
          if (m.count(c)) {
            return false;
          }
          ++m[c];
        }
      }
    }
    for (int i = 0; i < 9; i += 3) {
      for (int j = 0; j < 9; j += 3) {
        unordered_map<char, int> m;
        for (int k = 0; k < 3; ++k) {
          for (int n = 0; n < 3; ++n) {
            char c = board[i + k][j + n];
            if (c != '.') {
              if (m.count(c)) {
                return false;
              }
              ++m[c];
            }
          }
        }
      }
    }
    return true;
  }
};

int main() {

    vector<string> input = {
        "53..7....",
        "6..195...",
        ".98....6.",
        "8...6...3",
        "4..8.3..1",
        "7...2...6",
        ".6....28.",
        "...419..5",
        "....8..79"
    };

    vector<vector<char>> board;
    for(const string& row: input){
        vector<char> r;
        for(char c: row)
            r.push_back(c);
        board.push_back(r);
    }

    cout << Solution().isValidSudoku(board) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/count-and-say/description/

#include <iostream>

using namespace std;

class Solution {
public:
    string countAndSay(int n) {

        string s = "1";
        if(n == 1)
            return s;

        for(int i = 2; i <= n; i ++)
            s = next(s);
        return s;
    }

private:
    string next(const string& s){

        string ret = "";
        int start = 0;
        for(int i = start + 1; i <= s.size(); i ++)
            if(i == s.size() || s[i] != s[start]){
                ret += to_string(i - start) + s[start];
                start = i;
            }
        return ret;
    }
};


int main() {

    cout << Solution().countAndSay(1) << endl;
    cout << Solution().countAndSay(2) << endl;
    cout << Solution().countAndSay(3) << endl;
    cout << Solution().countAndSay(4) << endl;
    cout << Solution().countAndSay(5) << endl;
    cout << Solution().countAndSay(30) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/combination-sum/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

public:
    vector<vector<int>> combinationSum(vector<int> &candidates, int target) {

        vector<vector<int>> res;
        vector<int> cur_res;
        solve(candidates, 0, target, cur_res, res);
        return res;
    }

private:
    void solve(const vector<int> &candidates, int index, int target,
                vector<int>& cur_res, vector<vector<int>>& res){

        if(target == 0){
            res.push_back(cur_res);
            return;
        }

        for(int i = index ; i < candidates.size() ; i ++)
            if(target >= candidates[i]){
                cur_res.push_back(candidates[i]);
                solve(candidates, i, target - candidates[i], cur_res, res);
                cur_res.pop_back();
            }

        return;
    }
};

void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<int> candidates = {2, 3, 6, 7};
    vector<vector<int>> res = Solution().combinationSum(candidates, 7);
    for(const vector<int>& a_res: res)
        print_vec(a_res);

    return 0;
}

// Source : https://leetcode.com/problems/combination-sum-ii/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {

        sort(candidates.begin(), candidates.end());

        vector<vector<int>> res;
        vector<int> cur_res;
        solve(candidates, 0, target, cur_res, res);
        return res;
    }

private:
    void solve(const vector<int> &candidates, int index, int target,
               vector<int>& cur_res, vector<vector<int>>& res){

        if(target == 0){
            res.push_back(cur_res);
            return;
        }

        for(int i = index ; i < candidates.size() ; i ++){
            if(i > index && candidates[i] == candidates[i-1])
                continue;
            if(target >= candidates[i]){
                cur_res.push_back(candidates[i]);
                solve(candidates, i + 1, target - candidates[i], cur_res, res);
                cur_res.pop_back();
            }
        }

        return;
    }
};


void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<int> candidates = {10, 1, 2, 7, 6, 1, 5};
    vector<vector<int>> res = Solution().combinationSum2(candidates, 8);
    for(const vector<int>& a_res: res)
        print_vec(a_res);

    return 0;
}

// Source : https://leetcode.com/problems/first-missing-positive/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {

        int n = nums.size(), cur = 0;
        for(int i = 0; i < n; i ++)
            if(nums[i] <= 0)
                swap(nums[i--], nums[--n]);

        for(int i = 0; i < n; i ++)
            if(abs(nums[i]) - 1 < n && nums[abs(nums[i]) - 1] > 0)
                nums[abs(nums[i]) - 1] *= -1;

        for(int i = 0; i < n; i ++)
            if(nums[i] > 0)
                return i + 1;
        return n + 1;
    }
};


int main() {

    vector<int> nums = {3, 4, -1, 1};
    cout << Solution().firstMissingPositive(nums) << endl;
    // 2

    return 0;
}

// Source : https://leetcode.com/problems/trapping-rain-water/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int trap(vector<int>& height) {

        if(height.size() <= 2)
            return 0;

        vector<int> rdp(height.size(), height.back());
        for(int i = height.size() - 2; i >= 0; i --)
            rdp[i] = max(height[i], rdp[i + 1]);

        vector<int> ldp(height.size(), height[0]);
        for(int i = 1; i < height.size(); i ++)
            ldp[i] = max(height[i], ldp[i - 1]);

        int res = 0;
        for(int i = 0; i < height.size(); i ++)
            res += min(ldp[i], rdp[i]) - height[i];
        return res;
    }
};


int main() {

    vector<int> height1 = {0,1,0,2,1,0,1,3,2,1,2,1};
    cout << Solution().trap(height1) << endl;
    // 6

    vector<int> height2 = {4,2,3};
    cout << Solution().trap(height2) << endl;
    // 1

    vector<int> height3 = {4, 2, 0, 3, 2, 5};
    cout << Solution().trap(height3) << endl;
    // 9

    return 0;
}

// Source : https://leetcode.com/problems/jump-game-ii/

#include <iostream>
#include <vector>
#include <queue>

using namespace std;

class Solution {
public:
    int jump(vector<int>& nums) {

        int n = nums.size();
        int s = 0, t = n - 1;
        vector<int> dis(n, -1);

        queue<int> q;
        q.push(0);
        dis[0] = 0;
        while(!q.empty()){
            int u = q.front(); q.pop();
            if(u == t) break;

            for(int i = 1; i <= nums[u] && u + i < n; i ++)
                if(dis[u + i] == -1){
                    dis[u + i] = dis[u] + 1;
                    q.push(u + i);
                }
        }
        return dis.back();
    }
};


int main() {

    vector<int> nums1 = {2, 3, 1, 1, 4};
    cout << Solution().jump(nums1) << endl;
    // 2

    return 0;
}

// Source : https://leetcode.com/problems/permutations/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

private:

    vector<vector<int>> res;
    vector<bool> used;

    void generatePermutation(const vector<int>& nums, int index, vector<int>& p){

        if(index == nums.size()){
            res.push_back(p);
            return;
        }

        for(int i = 0 ; i < nums.size() ; i ++)
            if(!used[i]){
                used[i] = true;
                p.push_back(nums[i]);
                generatePermutation(nums, index + 1, p );
                p.pop_back();
                used[i] = false;
            }

        return;
    }

public:
    vector<vector<int>> permute(vector<int>& nums) {

        res.clear();
        if(nums.size() == 0)
            return res;

        used = vector<bool>(nums.size(), false);
        vector<int> p;
        generatePermutation(nums, 0, p);

        return res;
    }
};


void printVec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    int nums[] = {1, 2, 3};
    vector<int> vec(nums, nums + sizeof(nums)/sizeof(int) );

    vector<vector<int>> res = Solution().permute(vec);
    for(int i = 0 ; i < res.size() ; i ++)
        printVec(res[i]);

    return 0;
}

// Source : https://leetcode.com/problems/permutations-ii/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

private:
    vector<vector<int>> res;
    vector<bool> used;

public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {

        res.clear();
        if(nums.size() == 0)
            return res;

        used = vector<bool>(nums.size(), false);
        sort(nums.begin(), nums.end());
        vector<int> p;

        generatePermutation(nums, 0, p);

        return res;
    }

private:
    void generatePermutation(const vector<int>& nums, int index, vector<int> &p){

        if(index == nums.size()){
            res.push_back(p);
            return;
        }

        for(int i = 0 ; i < nums.size() ; i ++)
            if(!used[i]){
                if(i > 0 && nums[i] == nums[i-1] && !used[i-1])
                    continue;
                p.push_back(nums[i]);
                used[i] = true;

                generatePermutation(nums, index + 1, p);

                p.pop_back();
                used[i] = false;
            }

    }
};


void printVec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<int> nums1 = {1, 1, 2};
    vector<vector<int>> res1 = Solution().permuteUnique(nums1);
    for(const vector<int>& tres: res1)
        printVec(tres);

    vector<int> nums2 = {2, 2, 1, 1};
    vector<vector<int>> res2 = Solution().permuteUnique(nums2);
    for(const vector<int>& tres: res2)
        printVec(tres);

    return 0;
}

// Source : https://leetcode.com/problems/rotate-image/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {

        int n = matrix.size();
        for(int i = 0; i < n; i ++)
            for(int j = 0; j < n - i; j ++)
                swap(matrix[i][j], matrix[n - j - 1][n - i - 1]);

        for(int i = 0; i < n / 2; i ++)
            for(int j = 0; j < n; j ++)
                swap(matrix[i][j], matrix[n - i - 1][j]);
    }
};


void print_matrix(const vector<vector<int>>& m){
    for(int i = 0; i < m.size(); i ++){
        for(int j = 0; j < m[i].size(); j ++)
            cout << m[i][j] << " ";
        cout << endl;
    }
    cout << endl;
}

int main() {

    vector<vector<int>> matrix1 = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
    };
    Solution().rotate(matrix1);
    print_matrix(matrix1);

    vector<vector<int>> matrix2 = {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12},
            {13, 14, 15, 16}
    };
    Solution().rotate(matrix2);
    print_matrix(matrix2);

    return 0;
}

// Source : https://leetcode.com/problems/group-anagrams/description/

#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

        unordered_map<string, vector<string>> map;
        for(const string& s: strs){
            string key = s;
            sort(key.begin(), key.end());
            map[key].push_back(s);
        }

        vector<vector<string>> res;
        for(const auto& p: map)
            res.push_back(p.second);
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/powx-n/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
public:
    double myPow(double x, int n) {

        if(n == 0) return 1.0;

        double res = myPositivePow(x, abs((long long)n));
        if(n < 0) res = 1.0 / res;
        return res;
    }

private:
    double myPositivePow(double x, long long n){

        assert(n >= 0);
        if(!n) return 1.0;

        double t = myPositivePow(x, n / 2);
        double res = t * t;
        if(n % 2) res *= x;
        return res;
    }
};


int main() {

    cout << Solution().myPow(2.0, -2) << endl;
    // 0.25

    cout << Solution().myPow(-2.0, 2) << endl;
    // 4.0

    cout << Solution().myPow(34.00515, -3) << endl;
    // 3e-05

    cout << Solution().myPow(1.0, -2147483648) << endl;
    // 3e-05

    return 0;
}

// Source : https://leetcode.com/problems/n-queens/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
 public:
  vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> res;
    vector<string> v(n, string(n, '.'));
    dfs(res, v, n, 0);
    return res;
  }

  void dfs(vector<vector<string>>& res, vector<string>& v, int n, int row) {
    if (n == row) {
      res.emplace_back(v);
      return;
    }
    for (int col = 0; col < size(v[0]); ++col) {
      if (isValid(v, row, col)) {
        v[row][col] = 'Q';
        dfs(res, v, n, row + 1);
        v[row][col] = '.';
      }
    }
  }

  bool isValid(const vector<string>& v, int row, int col) {
    for (int i = row - 1; i >= 0; --i) {
      if (v[i][col] == 'Q') {
        return false;
      }
    }
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {
      if (v[i][j] == 'Q') {
        return false;
      }
    }
    for (int i = row - 1, j = col + 1; i >= 0 && j < size(v[0]); --i, ++j) {
      if (v[i][j] == 'Q') {
        return false;
      }
    }
    return true;
  }
};


void printBoard(const vector<string>& board){
    for(string row: board)
        cout << row << endl;
    cout << endl;
}

int main() {

    int n = 4;
    vector<vector<string>> res = Solution().solveNQueens(n);
    for(const vector<string> &board: res)
        printBoard(board);

    return 0;
}

// Source : https://leetcode.com/problems/maximum-subarray/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int maxSubArray(vector<int>& nums) {

        int res = nums[0], sum = nums[0];
        for(int i = 1; i < nums.size(); i ++){
            if(sum + nums[i] < nums[i]) sum = nums[i];
            else sum += nums[i];
            res = max(res, sum);
        }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/spiral-matrix/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

private:
    int d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int N, M;

public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {

        N = matrix.size();
        if(N == 0)
            return {};

        M = matrix[0].size();
        if(M == 0)
            return {};

        vector<vector<bool>> visited(N, vector<bool>(M, false));
        int curd = 0, curx = 0, cury = 0;
        vector<int> res;
        while(res.size() < N * M){

            if(!visited[curx][cury]) {
                res.push_back(matrix[curx][cury]);
                visited[curx][cury] = true;
            }

            int nextx = curx + d[curd][0];
            int nexty = cury + d[curd][1];
            if(inArea(nextx, nexty) && !visited[nextx][nexty]){
                curx = nextx;
                cury = nexty;
            }
            else
                curd = (curd + 1) % 4;
        }
        return res;
    }

private:
    bool inArea(int x, int y){
        return x >= 0 && x < N && y >= 0 && y < M;
    }
};


void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<vector<int>> matrix1 = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
    };
    print_vec(Solution().spiralOrder(matrix1));

    return 0;
}

// Source : https://leetcode.com/problems/jump-game/

#include <iostream>
#include <vector>
#include <queue>

using namespace std;

class Solution {
public:
    bool canJump(vector<int>& nums) {

        int n = nums.size();
        int s = 0, t = n - 1;
        vector<int> dis(n, -1);
        dis[0] = 0;

        queue<int> q;
        q.push(0);
        while(!q.empty()){
            int u = q.front(); q.pop();
            if(u == t) break;

            for(int i = 1; i <= nums[u] && u + i < n; i ++)
                if(dis[u + i] == -1){
                    dis[u + i] = dis[u] + 1;
                    q.push(u + i);
                }
        }
        return dis.back() >= 0;
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/merge-intervals/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {

        if(intervals.size() <= 1)
            return intervals;

        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){
            if(a[0] != b[0])
                return a[0] < b[0];
            return a[1] < b[1];
        });

        vector<vector<int>> res;
        res.push_back(intervals[0]);
        for(int i = 1 ; i < intervals.size() ; i ++){
            if(cross(res.back(), intervals[i])){
                vector<int> newInterval = mergeInterval(res.back(), intervals[i]);
                res.pop_back();
                res.push_back(newInterval);
            }
            else
                res.push_back(intervals[i]);
        }

        return res;
    }

private:
    bool cross(const vector<int>& interval1, const vector<int>& interval2){
        return interval2[0] <= interval1[1];
    }

    vector<int> mergeInterval(const vector<int>& interval1, const vector<int>& interval2){
        return {min(interval1[0], interval2[0]), max(interval1[1], interval2[1])};
    }
};


void printIntervals(const vector<vector<int>>& vec){
    for(const vector<int>& interval: vec)
        cout << interval[0] << " " << interval[1] << endl;
    cout << endl;
}

int main() {

    vector<vector<int>> vec1 = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
    printIntervals(Solution().merge(vec1));
    // [1,6] [8,10] [15,18]

    // ---

    vector<vector<int>> vec2 = {{1, 4}, {0, 0}};
    printIntervals(Solution().merge(vec2));
    // [0,0] [1,4]

    return 0;
}

// Source : https://leetcode.com/problems/spiral-matrix-ii/description/

#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

class Solution {

private:
    int d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int N;

public:
    vector<vector<int>> generateMatrix(int n) {

        if(n == 0)
            return {};

        N = n;
        int maxnum = n * n;

        vector<vector<int>> res(N, vector<int>(N, 0));
        int curx = 0, cury = 0, curd = 0, num = 1;
        while(num <= maxnum){
            if(res[curx][cury] == 0){
                res[curx][cury] = num;
                num ++;
            }

            int nextx = curx + d[curd][0];
            int nexty = cury + d[curd][1];
            if(inArea(nextx, nexty) && res[nextx][nexty] == 0){
                curx = nextx;
                cury = nexty;
            }
            else
                curd = (curd + 1) % 4;
        }

        return res;
    }

private:
    bool inArea(int x, int y){
        return x >= 0 && x < N && y >= 0 && y < N;
    }
};


void print_matrix(const vector<vector<int>>& matrix){
    for(const vector<int>& vec: matrix){
        for(int e: vec)
            cout << e << " ";
        cout << endl;
    }
}

int main() {

    vector<vector<int>> res = Solution().generateMatrix(3);
    print_matrix(res);

    return 0;
}

// Source : https://leetcode.com/problems/rotate-list/description/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {

        if(head == NULL)
            return NULL;

        int len = get_len(head);
        k = k % len;
        if (k == 0) { return head; }
    
        ListNode* end = head;
        for(int i = 0 ; i < k ; i ++)
            end = end->next;

        ListNode* start = head;
        while(end->next != NULL){
            start = start->next;
            end = end->next;
        }

        end->next = head;
        head = start->next;
        start->next = NULL;

        return head;
    }

private:
    int get_len(ListNode* head){
        int res = 0;
        while(head){
            res ++;
            head = head->next;
        }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/unique-paths/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

public:
    int uniquePaths(int m, int n) {

        vector<vector<int>> dp(m, vector<int>(n, 0));
        return dfs(m - 1, n - 1, dp);
    }

private:
    int dfs(int x, int y, vector<vector<int>>& dp){

        if(x == 0 || y == 0) return 1;
        if(dp[x][y]) return dp[x][y];

        int res = dfs(x - 1, y, dp) + dfs(x, y - 1, dp);
        return dp[x][y] = res;
    }
};

// Source : https://leetcode.com/problems/unique-paths-ii/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {

        int m = obstacleGrid.size();
        if(!m) return 0;

        int n = obstacleGrid[0].size();
        if(!n || obstacleGrid[0][0])
            return 0;

        vector<vector<long long>> dp(m, vector<long long>(n, 1ll));
        dp[0][0] = 1;
        for(int j = 1; j < n; j ++)
            if(obstacleGrid[0][j])
                dp[0][j] = 0;
            else
                dp[0][j] = dp[0][j - 1];

        for(int i = 1; i < m; i ++)
            if(obstacleGrid[i][0])
                dp[i][0] = 0;
            else
                dp[i][0] = dp[i - 1][0];

        for(int i = 1; i < m; i ++)
            for(int j = 1; j < n; j ++)
                if(obstacleGrid[i][j])
                    dp[i][j] = 0;
                else
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        return dp[m - 1][n - 1];
    }
};


int main() {

    return 0;
}

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/minimum-path-sum/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {

        int n = grid.size();
        assert(n > 0);

        int m = grid[0].size();
        assert(m > 0);

        vector<vector<int>> res = grid;

        for(int j = 1 ; j < m ; j ++)
            res[0][j] += res[0][j-1];

        for(int i = 1 ; i < n ; i ++)
            res[i][0] += res[i-1][0];

        for(int i = 1 ; i < n ; i ++)
            for(int j = 1 ; j < m ; j ++)
                res[i][j] += min(res[i-1][j], res[i][j-1]);

        return res[n-1][m-1];
    }
};

int main() {

    vector<vector<int>> grid = {{1, 3, 1},
                                {1, 5, 1},
                                {4, 2, 1}};
    cout << Solution().minPathSum(grid) << endl;
    return 0;
}

// Source : https://leetcode.com/problems/valid-number/

#include <iostream>

using namespace std;

class Solution {
public:
    bool isNumber(string s) {

        if(s.size() == 0) return false;

        if(isInteger(s))
            return true;
        return isEDecimal(s);
    }

private:
    bool isEDecimal(const string& s){

        int epos = s.find('e');
        if(epos == string::npos) epos = s.find('E');
        if(epos != string::npos){
            string a = s.substr(0, epos), b = s.substr(epos + 1);
            return isDecimal(a) && isInteger(b);
        }
        return isDecimal(s);
    }

    bool isDecimal(const string& s){

        if(s.size() == 0) return false;

        if(s[0] == '+' || s[0] == '-')
            return isNonSignedDecimal(s.substr(1));
        return isNonSignedDecimal(s);
    }

    bool isNonSignedDecimal(const string& s){

        int dotpos = s.find('.');
        if(dotpos == string::npos) return isInteger(s);

        string a = s.substr(0, dotpos), b = s.substr(dotpos + 1);
        if(a.size() == 0) return isNonSignedInteger(b);
        else if(b.size() == 0) return isInteger(a);
        return isInteger(a) && isNonSignedInteger(b);
    }

    bool isInteger(const string& s){

        if(s.size() == 0) return false;
        if(s[0] == '+' || s[0] == '-')
            return isNonSignedInteger(s.substr(1));
        return isNonSignedInteger(s);
    }

    bool isNonSignedInteger(const string& s){

        if(s.size() == 0) return false;
        for(char c: s)
            if(!isdigit(c)) return false;
        return true;
    }
};


int main() {

    cout << Solution().isNumber(".1") << endl;
    // 1

    cout << Solution().isNumber("005047e+6") << endl;
    // 1

    cout << Solution().isNumber(".-4") << endl;
    // 0

    return 0;
}

// Source : https://leetcode.com/problems/plus-one/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {

        digits[digits.size() - 1] ++;
        for(int i = digits.size() - 1 ; i >= 1 ; i --)
            if(digits[i] == 10){
                digits[i] = 0;
                digits[i - 1] ++;
            }

        if(digits[0] == 10){
            digits[0] = 0;
            digits.insert(digits.begin(), 1);
        }

        return digits;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/add-binary/description/

#include <iostream>

using namespace std;

class Solution {
public:
    string addBinary(string a, string b) {

        string res = a.size() > b.size() ? a : b;
        string adder = a.size() > b.size() ? b : a;

        int index = res.size() - 1;
        for(int i = adder.size() - 1 ; i >= 0 ; i --){
            res[index] += adder[i] - '0';
            index --;
        }

        for(int i = res.size() - 1 ; i > 0 ; i --)
            if(res[i] > '1'){
                res[i - 1] += 1;
                res[i] = '0' + (res[i] - '0') % 2;
            }

        if(res[0] > '1'){
            res[0] = '0' + (res[0] - '0') % 2;
            res = '1' + res;
        }
        return res;
    }
};


int main() {

    cout << Solution().addBinary("11", "1") << endl;
    cout << Solution().addBinary("1010", "1011") << endl;

    return 0;
}

// Source : https://leetcode.com/problems/sqrtx/description/

#include <iostream>

using namespace std;

class Solution {

private:
    double e = 1e-6;

public:
    int mySqrt(int x) {

        double l = 0.0, r = INT_MAX;
        while(r - l >= e){
            double mid = (l + r) / 2;
            if(mid * mid <= x)
                l = mid;
            else
                r = mid;
        }
        return (int)r;
    }
};


int main() {

    cout << Solution().mySqrt(4) << endl;
    cout << Solution().mySqrt(8) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/climbing-stairs/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {

public:
    int climbStairs(int n) {

        assert(n > 0);

        vector<int> memo(n + 1, -1);
        memo[0] = 1;
        memo[1] = 1;
        for(int i = 2 ; i <= n ; i ++)
            memo[i] = memo[i - 1] + memo[i - 2];
        return memo[n];
    }
};

int main() {

    cout << Solution().climbStairs(10) << endl;
    return 0;
}


// Source : https://leetcode.com/problems/simplify-path/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    string simplifyPath(string path) {

        vector<string> stack;
        for(int start = 1, i = 1; i <= path.size(); i ++)
            if(i == path.size() || path[i] == '/'){
                string f = path.substr(start, i - start);
                if(f.size()){
                    if(f == ".."){
                        if(stack.size()) stack.pop_back();
                    }
                    else if(f != ".") stack.push_back(f);
                }
                start = i + 1;
            }

        string res = "";
        for(string e: stack)
            res += "/" + e;
        return res == "" ? "/" : res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/edit-distance/

#include <iostream>
#include <vector>
#include <map>

using namespace std;

class Solution {

public:
    int minDistance(string word1, string word2) {

        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));

        for(int i = 0; i <= m; i ++)
            dp[i][0] = i;
        for(int j = 0; j <= n; j ++)
            dp[0][j] = j;

        // get dp[i][j], check word[i - 1], word[j - 1]
        for(int i = 1; i <= m; i ++)
            for(int j = 1; j <= n; j ++){
                if(word1[i - 1] == word2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                dp[i][j] = min(dp[i][j], 1 + dp[i - 1][j - 1]);
                dp[i][j] = min(dp[i][j], 1 + dp[i - 1][j]);
                dp[i][j] = min(dp[i][j], 1 + dp[i][j - 1]);
            }

        return dp[m][n];
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/set-matrix-zeroes/description/

#include <iostream>
#include <vector>
#include <set>

using namespace std;

class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {

        int m = matrix.size();
        if(!m) return;

        int n = matrix[0].size();
        if(!n) return;

        set<int> zeroRows, zeroCols;
        for(int i = 0; i < m; i ++)
            for(int j = 0; j < n; j ++)
                if(!matrix[i][j]){
                    zeroRows.insert(i);
                    zeroCols.insert(j);
                }

        for(int r: zeroRows)
            for(int j = 0; j < n; j ++)
                matrix[r][j] = 0;

        for(int c: zeroCols)
            for(int i = 0; i < m; i ++)
                matrix[i][c] = 0;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/search-a-2d-matrix/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {

        if(!matrix.size() || !matrix[0].size()) return false;
        if(target < matrix[0][0]) return false;

        vector<int> row;
        for(int i = 0; i < matrix.size(); i ++)
            row.push_back(matrix[i][0]);

        int row_index = lower_bound(row.begin(), row.end(), target) - row.begin();
        if(row_index == matrix.size() || matrix[row_index][0] != target)
            row_index --;

        vector<int>::iterator iter = lower_bound(matrix[row_index].begin(), matrix[row_index].end(), target);
        return iter != matrix[row_index].end() && *iter == target;
    }
};


int main() {

    vector<vector<int>> matrix1 = {
            {1, 3, 5, 7},
            {10, 11, 16, 20},
            {23, 30, 34, 50}
    };
    cout << Solution().searchMatrix(matrix1, 3) << endl;
    // true

    vector<vector<int>> matrix2 = {
            {1}
    };
    cout << Solution().searchMatrix(matrix2, 2) << endl;
    // false

    return 0;
}

// Source : https://leetcode.com/problems/sort-colors/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
public:
    void sortColors(vector<int> &nums) {

        const int MAX = 3;
        vector<int> count(MAX+1, 0);
        for(int i = 0 ; i < nums.size() ; i ++){
            count[nums[i]+1] ++;
        }

        for (int i = 0; i < MAX; i++)
            count[i+1] += count[i];

        vector<int> aux(nums.size());
        for (int i = 0; i < nums.size(); i++) {
            aux[count[nums[i]]++] = nums[i];
        }

        nums = std::move(aux);
    }
};


void print_arr(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<int> vec1 = {2, 2, 2, 1, 1, 0};
    Solution().sortColors(vec1);
    print_arr(vec1);

    vector<int> vec2 = {2};
    Solution().sortColors(vec2);
    print_arr(vec2);

    return 0;
}

// Source : https://leetcode.com/problems/minimum-window-substring/

#include <iostream>
#include <cassert>
#include <unordered_set>
#include <vector>

using namespace std;

class Solution {
public:
    string minWindow(string s, string t) {

        unordered_set<char> t_set;
        int tFreq[256] = {0};
        for(char c: t){
            t_set.insert(c);
            tFreq[c] ++;
        }

        string filtered_s = "";
        vector<int> pos;
        for(int i = 0; i < s.size() ; i ++)
            if(t_set.find(s[i]) != t_set.end()){
                filtered_s += s[i];
                pos.push_back(i);
            }


        int sFreq[256] = {0};
        int sCnt = 0;

        int minLength = s.size() + 1;
        int startIndex = -1;

        int l = 0, r = -1;
        while(l < filtered_s.size()){

            if(r + 1 < filtered_s.size() && sCnt < t.size()){

                sFreq[filtered_s[r+1]] ++;
                if(sFreq[filtered_s[r+1]] <= tFreq[filtered_s[r+1]])
                    sCnt ++;
                r ++;
            }
            else{
                assert(sCnt <= t.size());
                if(sCnt == t.size() && pos[r] - pos[l] + 1 < minLength){
                    minLength = pos[r] - pos[l] + 1;
                    startIndex = pos[l];
                }

                sFreq[filtered_s[l]] --;
                if(sFreq[filtered_s[l]] < tFreq[filtered_s[l]])
                    sCnt --;
                l ++;
            }
        }

        if( startIndex != -1 )
            return s.substr(startIndex, minLength);

        return "";
    }
};


int main() {

    cout << Solution().minWindow("ADOBECODEBANC", "ABC") << endl;
    // BANC

    cout << Solution().minWindow("a", "aa") << endl;
    // empty

    cout << Solution().minWindow("aa", "aa") << endl;
    // aa

    cout << Solution().minWindow("bba", "ab") << endl;
    // ba

    return 0;
}

// Source : https://leetcode.com/problems/combinations/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

private:
    vector<vector<int>> res;

    void generateCombinations(int n, int k, int start, vector<int> &c){

        if(c.size() == k){
            res.push_back(c);
            return;
        }

        for(int i = start ; i <= n ; i ++){
            c.push_back( i );
            generateCombinations(n, k, i + 1, c);
            c.pop_back();
        }

        return;
    }

public:
    vector<vector<int>> combine(int n, int k) {

        res.clear();
        if( n <= 0 || k <= 0 || k > n )
            return res;

        vector<int> c;
        generateCombinations(n, k, 1, c);

        return res;
    }
};


void print_vec(const vector<int>& vec){

    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<vector<int>> res = Solution().combine(4,2);
    for( int i = 0 ; i < res.size() ; i ++ )
        print_vec(res[i]);
    return 0;
}

// Source : https://leetcode.com/problems/subsets/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {

        vector<vector<int>> res;

        int n = nums.size();
        for(int state = 0; state < (1 << n); state ++)
            res.push_back(get_subsets(state, nums));
        return res;
    }

private:
    vector<int> get_subsets(int state, const vector<int>& nums){

        vector<int> res;
        int k = 0;
        while(state){
            if(state & 1) res.push_back(nums[k]);
            state >>= 1, k ++;
        }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/word-search/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {

private:
    int d[4][2] = {{-1, 0}, {0,1}, {1, 0}, {0, -1}};
    int m, n;
    vector<vector<bool>> visited;

    bool inArea( int x , int y ){
        return x >= 0 && x < m && y >= 0 && y < n;
    }

    bool searchWord( const vector<vector<char>> &board, const string& word, int index,
                    int startx, int starty ){

        if( index == word.size() - 1 )
            return board[startx][starty] == word[index];

        if( board[startx][starty] == word[index] ){
            visited[startx][starty] = true;
            for( int i = 0 ; i < 4 ; i ++ ){
                int newx = startx + d[i][0];
                int newy = starty + d[i][1];
                if( inArea(newx, newy) && !visited[newx][newy] &&
                    searchWord(board, word, index + 1, newx, newy))
                    return true;
            }
            visited[startx][starty] = false;
        }
        return false;
    }

public:
    bool exist(vector<vector<char>>& board, string word) {

        m = board.size();
        assert( m > 0 );
        n = board[0].size();
        visited = vector<vector<bool>>(m, vector<bool>(n, false));
        for( int i = 0 ; i < board.size() ; i ++ )
            for( int j = 0 ; j < board[i].size() ; j ++ )
                if( searchWord( board, word, 0 , i, j) )
                    return true;

        return false;
    }
};

int main() {

    char b1[3][4] = {{'A','B','C','E'},{'S','F','C','S'},{'A','D','E','E'}};
    vector<vector<char>> board1;
    for( int i = 0 ; i < 3 ; i ++ )
        board1.push_back(vector<char>(b1[i], b1[i] + sizeof(b1[i]) / sizeof(char)));

    int cases = 3;
    string words[3] = {"ABCCED" , "SEE" , "ABCB" };
    for( int i = 0 ; i < cases ; i ++ )
        if(Solution().exist(board1,words[i]))
            cout<<"found "<<words[i]<<endl;
        else
            cout<<"can not found "<<words[i]<<endl;

    // ---

    char b2[1][1] = {{'A'}};
    vector<vector<char>> board2;
    for(int i = 0 ; i < 3 ; i ++)
        board2.push_back(vector<char>(b2[i],b2[i]+sizeof(b2[i])/sizeof(char)));

    if(Solution().exist(board2,"AB"))
        cout<<"found AB"<<endl;
    else
        cout<<"can not found AB"<<endl;

    return 0;
}


// Source : https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {

        int i = 0;
        int j = 0;
        while(j < nums.size()){
            int k = nextIndex(nums, j);
            int len = min( 2, k-j);
            for(int ii = 0 ; ii < len ; ii ++)
                nums[i+ii] = nums[j];
            i += len;
            j = k;
        }

        return i;
    }

private:
    int nextIndex(const vector<int>& nums, int index){
        for(int i = index ; i < nums.size() ; i ++)
            if(nums[i] != nums[index])
                return i;
        return nums.size();
    }
};


int main() {

    vector<int> nums1 = {1, 1, 1, 2, 2, 3};
    cout << Solution().removeDuplicates(nums1) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/search-in-rotated-sorted-array-ii/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    bool search(vector<int>& nums, int target) {

        if(nums.size() == 0) return false;

        int p = 0;
        for(p = 0; p + 1 < nums.size(); p ++)
            if(nums[p] > nums[p + 1]) break;

        int l = 0, r = p;
        while(l <= r){
            int mid = l + (r - l) / 2;
            if(nums[mid] == target) return true;
            if(target < nums[mid]) r = mid - 1;
            else l = mid + 1;
        }

        l = p + 1, r = nums.size() - 1;
        while(l <= r){
            int mid = l + (r - l) / 2;
            if(nums[mid] == target) return true;
            if(target < nums[mid]) r = mid - 1;
            else l = mid + 1;
        }

        return false;
    }
};


int main() {

    vector<int> nums1 = {4,5,6,7,0,1,2};
    cout << Solution().search(nums1, 0) << endl;

    vector<int> nums2 = {4,5,6,7,8,1,2,3};
    cout << Solution().search(nums2, 8) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = head;

        ListNode* prev = dummyHead;
        ListNode* cur = prev->next;
        while(cur){

            int num = 0;
            ListNode* p = cur;
            while(p && p->val == cur->val){
                num ++;
                p = p->next;
            }

            if(num > 1)
                prev->next = p;
            else
                prev = cur;
            cur = p;
        }

        ListNode* ret = dummyHead->next;
        delete dummyHead;
        return ret;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/remove-duplicates-from-sorted-list/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

        ListNode* cur = head;
        while(cur && cur->next){
            if(cur->val == cur->next->val) cur->next = cur->next->next;
            else cur = cur->next;
        }
        return head;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/largest-rectangle-in-histogram/

#include <iostream>
#include <vector>
#include <stack>

using namespace std;

class Solution {

public:
    int largestRectangleArea(vector<int>& heights) {

        int n = heights.size();
        if(!n) return 0;

        heights.insert(heights.begin(), INT_MAX);
        heights.push_back(INT_MAX);

        vector<int> left(n + 2), right(n + 2);
        left[0] = 0;
        for(int i = 1; i <= n; i ++){
            int p = i - 1;
            while(p > 0 && heights[i] <= heights[p])
                p = left[p];
            left[i] = p;
        }

        right[n + 1] = n + 1;
        for(int i = n; i >= 1; i --){
            int p = i + 1;
            while(p < n + 1 && heights[i] <= heights[p])
                p = right[p];
            right[i] = p;
        }

        int res = 0;
        for(int i = 1; i <= n; i ++)
            res = max(res, heights[i] * (right[i] - left[i] - 1));
        return res;
    }
};


int main() {

    vector<int> heights1 = {2,1,5,6,2,3};
    cout << Solution().largestRectangleArea(heights1) << endl;
    // 10

    vector<int> heights2 = {2,1,2};
    cout << Solution().largestRectangleArea(heights2) << endl;
    // 3

    vector<int> heights3 = {0, 9};
    cout << Solution().largestRectangleArea(heights3) << endl;
    // 9

    vector<int> heights4 = {5, 4, 1, 2};
    cout << Solution().largestRectangleArea(heights4) << endl;
    // 8

    vector<int> heights5 = {1, 2, 3, 4, 5};
    cout << Solution().largestRectangleArea(heights5) << endl;
    // 9

    vector<int> heights6 = {4, 2, 0, 3, 2, 5};
    cout << Solution().largestRectangleArea(heights6) << endl;
    // 6

    return 0;
}

// Source : https://leetcode.com/problems/maximal-rectangle/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {

        if(!matrix.size() || !matrix[0].size()) return 0;

        int R = matrix.size(), C = matrix[0].size();
        vector<vector<int>> dp(R, vector<int>(C, 0));
        for(int i = 0; i < matrix.size(); i ++){
            dp[i][0] = matrix[i][0] - '0';
            for(int j = 1; j < C; j ++)
                if(matrix[i][j] == '1')
                    dp[i][j] = dp[i][j - 1] + 1;
        }

        int res = *max_element(dp[0].begin(), dp[0].end());

        for(int i = 1; i < R; i ++)
            for(int j = 0; j < C; j ++){
                int w = dp[i][j];
                for(int k = i; k >= 0 && w; k --){
                    w = min(w, dp[k][j]);
                    res = max(res, w * (i - k + 1));
                }
            }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/partition-list/description/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* partition(ListNode* head, int x) {

        ListNode* dummyHead1 = new ListNode(-1);
        ListNode* dummyHead2 = new ListNode(-1);
        ListNode* prev1 = dummyHead1;
        ListNode* prev2 = dummyHead2;

        for(ListNode* cur = head ; cur != NULL ;){
            if(cur->val < x){
                prev1->next = cur;
                cur = cur->next;
                prev1 = prev1->next;
                prev1->next = NULL;
            }
            else{
                prev2->next = cur;
                cur = cur->next;
                prev2 = prev2->next;
                prev2->next = NULL;
            }
        }

        prev1->next = dummyHead2->next;
        ListNode* ret = dummyHead1->next;

        delete dummyHead1;
        delete dummyHead2;
        return ret;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/scramble-string/description/

#include <iostream>
#include <string>
#include <unordered_map>

using namespace std;

class Solution {
public:
    bool isScramble(string s1, string s2) {

        if(s1.size() != s2.size())
            return false;

        if(s1 == s2)
            return true;

        unordered_map<char, int> freq;
        for(char c: s1)
            freq[c] += 1;
        for(char c: s2)
            if(freq.find(c) == freq.end())
                return false;
            else{
                freq[c] -= 1;
                if(freq[c] == 0)
                    freq.erase(c);
            }


        for(int i = 1 ; i <= s1.size() - 1 ; i ++){
            if(isScramble(s1.substr(0, i), s2.substr(0, i))
               && isScramble(s1.substr(i), s2.substr(i)))
                return true;
            if(isScramble(s1.substr(0, i), s2.substr(s2.size() - i))
               && isScramble(s1.substr(i), s2.substr(0, s2.size() - i)))
                return true;
        }

        return false;
    }
};


void print_bool(bool res){
    cout << (res ? "true" : "false") << endl;
}

int main() {

    print_bool(Solution().isScramble("great", "rgeat"));
    print_bool(Solution().isScramble("abcde", "caebd"));
    print_bool(Solution().isScramble("abcdefghijklmn", "efghijklmncadb"));

    return 0;
}

// Source : https://leetcode.com/problems/merge-sorted-array/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {

        assert(nums1.size() == m + n && nums2.size() == n);

        for(int i = n + m - 1 ; i >= n ; i -- )
            nums1[i] = nums1[i - n];

        int i = n;  // pointer for nums1 [n, n+m)
        int j = 0;  // pointer for nums2 [0, n)
        int k = 0;  // pointer merged nums1 [0, n+m)
        while( k < n + m ){
            if( i >= n+m )
                nums1[k++] = nums2[j++];
            else if( j >= n )
                nums1[k++] = nums1[i++];
            else if( nums1[i] < nums2[j] )
                nums1[k++] = nums1[i++];
            else
                nums1[k++] = nums2[j++];
        }
    }
};


void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<int> nums1 = {1, 3, 5, 7};
    int m = nums1.size();

    vector<int> nums2 = {2, 4, 6};
    int n = nums2.size();

    for( int i = 0 ; i < nums2.size() ; i ++ )
        nums1.push_back(0);

    Solution().merge(nums1, m, nums2, n);
    print_vec(nums1);

    return 0;
}

// Source : https://leetcode.com/problems/gray-code/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> grayCode(int n) {

        vector<int> res = {0};
        for(int i = 0; i < n; i ++){
            for(int j = res.size() - 1; j >= 0; j --)
                res.push_back((1 << i) + res[j]);
        }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/subsets-ii/

#include <iostream>
#include <vector>
#include <set>

using namespace std;

class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {

        sort(nums.begin(), nums.end());

        int n = nums.size();
        set<vector<int>> s;
        for(int state = 0; state < (1 << n); state ++){
            vector<int> t;
            for(int i = 0; i < n; i ++)
                if(state & (1 << i)) t.push_back(nums[i]);
            s.insert(t);
        }
        return vector<vector<int>>(s.begin(), s.end());
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/decode-ways/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

private:
    int n;
    vector<int> dp;

public:
    int numDecodings(string s) {

        n = s.size();
        dp.resize(n, -1);
        return dfs(s, 0);
    }

private:
    int dfs(const string& s, int start){

        if(start >= s.size()) return 1;
        if(s[start] == '0') return 0;
        if(dp[start] != -1) return dp[start];

        int res = dfs(s, start + 1);
        if(start + 1 < n && s.substr(start, 2) <= "26")
            res += dfs(s, start + 2);
        return dp[start] = res;
    }
};


int main() {

    cout << Solution().numDecodings("12") << endl;
    cout << Solution().numDecodings("226") << endl;

    return 0;
}

// Source : https://leetcode.com/problems/reverse-linked-list-ii/description/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {

        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = head;

        ListNode* pre = dummyHead;
        for(int i = 0; i < m - 1; i ++, pre = pre->next);

        ListNode* tail = pre->next;
        ListNode* left;
        pre->next = reverse(pre->next, n - m, left);
        tail->next = left;

        ListNode* ret = dummyHead->next;
        delete dummyHead;
        return ret;
    }

private:
    ListNode* reverse(ListNode* head, int index, ListNode* &left){

        if(index == 0){
            left = head->next;
            return head;
        }

        ListNode* tail = head->next;
        ListNode* ret = reverse(head->next, index - 1, left);
        tail->next = head;
        return ret;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/restore-ip-addresses/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<string> restoreIpAddresses(string s) {

        vector<string> res;
        vector<int> ip;
        dfs(s, 0, ip, res);
        return res;
    }

private:
    void dfs(const string& s, int index, vector<int>& ip, vector<string>& res){

        if(index == s.size()){
            if(ip.size() == 4)
                res.push_back(get_string(ip));
            return;
        }

        if(index == 0){
            ip.push_back(s[0] - '0');
            dfs(s, index + 1, ip, res);
        }
        else{
            int next = ip.back() * 10 + (s[index] - '0');
            if(next <= 255 && ip.back() != 0){
                ip.back() = next;
                dfs(s, index + 1, ip, res);
                ip.back() /= 10;
            }
            if(ip.size() < 4){
                ip.push_back(s[index] - '0');
                dfs(s, index + 1, ip, res);
                ip.pop_back();
            }
        }
    }

    string get_string(const vector<int>& ip){
        string res = to_string(ip[0]);
        for(int i = 1; i < ip.size(); i ++)
            res += "." + to_string(ip[i]);
        return res;
    }
};


void print_vec(const vector<string>& vec){

    for(const string& e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    string s1 = "25525511135";
    print_vec(Solution().restoreIpAddresses(s1));
    // 255.255.111.35 255.255.11.135

    string s2 = "1";
    print_vec(Solution().restoreIpAddresses(s2));
    // empty

    string s3 = "010010";
    print_vec(Solution().restoreIpAddresses(s3));
    // 0.10.0.10 0.100.1.0

    return 0;
}

// Source : https://leetcode.com/problems/binary-tree-inorder-traversal/

#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {

        vector<int> res;
        __inorderTraversal(root, res);
        return res;
    }

private:
    void __inorderTraversal(TreeNode* node, vector<int> &res){

        if( node ){
            __inorderTraversal(node->left, res);
            res.push_back( node->val );
            __inorderTraversal(node->right, res);
        }
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/unique-binary-search-trees-ii/description/

#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {

        vector<int> vals;
        for(int i = 1; i <= n; i ++)
            vals.push_back(i);
        return generateTrees(vals);
    }

private:
    vector<TreeNode*> generateTrees(const vector<int>& vec){

        if(vec.size() == 0)
            return {};

        if(vec.size() == 1)
            return {new TreeNode(vec[0])};

        vector<TreeNode*> ret;
        for(int i = 0; i < vec.size(); i ++){
            vector<TreeNode*> left = generateTrees(vector<int>(vec.begin(), vec.begin() + i));
            vector<TreeNode*> right = generateTrees(vector<int>(vec.begin() + i + 1, vec.end()));
            if(left.empty()) left.push_back(NULL);
            if(right.empty()) right.push_back(NULL);

            for(TreeNode* ltree: left)
                for(TreeNode* rtree: right){
                    TreeNode* root = new TreeNode(vec[i]);
                    root->left = ltree;
                    root->right = rtree;
                    ret.push_back(root);
                }
        }
        return ret;
    }
};


int main() {

    cout << Solution().generateTrees(0).size() << endl;
    cout << Solution().generateTrees(3).size() << endl;

    return 0;
}

// Source : https://leetcode.com/problems/unique-binary-search-trees/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

public:
    int numTrees(int n) {

        vector<int> dp(n + 1, -1);
        return numTrees(n, dp);
    }

private:
    int numTrees(int n, vector<int>& dp){

        if(n <= 1)
            return 1;

        if(dp[n] != -1)
            return dp[n];

        int res = 0;
        for(int i = 1; i <= n; i ++)
            res += numTrees(i - 1, dp) * numTrees(n - i, dp);
        return dp[n] = res;
    }
};


int main() {

    cout << Solution().numTrees(3) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/interleaving-string/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {

        int n1 = s1.size(), n2 = s2.size();
        if(s3.size() != n1 + n2) return false;

        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, -1));
        return dfs(s1, s2, s3, 0, 0, dp);
    }

private:
    int dfs(const string& s1, const string& s2, const string& s3, int i, int j,
            vector<vector<int>>& dp){

        if(i == s1.size() && j == s2.size()) return 1;
        if(dp[i][j] != -1) return dp[i][j];

        if(i == s1.size())
            return dp[i][j] = (s2[j] == s3[i + j] ? dfs(s1, s2, s3, i, j + 1, dp) : 0);

        if(j == s2.size())
            return dp[i][j] = (s1[i] == s3[i + j] ? dfs(s1, s2, s3, i + 1, j, dp) : 0);

        if(s1[i] == s3[i + j] && dfs(s1, s2, s3, i + 1, j, dp) == 1)
            return dp[i][j] = 1;

        if(s2[j] == s3[i + j] && dfs(s1, s2, s3, i, j + 1, dp) == 1)
            return dp[i][j] = 1;

        return dp[i][j] = 0;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/validate-binary-search-tree/description/

#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    bool isValidBST(TreeNode* root) {

        return isValidBST(root, INT_MIN, INT_MAX);
    }

private:
    bool isValidBST(TreeNode* node, int min, int max){

        if(node == NULL)
            return true;

        if(node->val < min || node->val > max)
            return false;

        if(node->left != NULL && node->left->val >= node->val)
            return false;

        if(node->right != NULL && node->right->val <= node->val)
            return false;

        return isValidBST(node->left, min, node->val - 1) && isValidBST(node->right, node->val + 1, max);
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/validate-binary-search-tree/description/

import java.util.ArrayList;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

class Solution {

    public void recoverTree(TreeNode root) {

        ArrayList<TreeNode> list = new ArrayList<>();
        inOrder(root, list);

        TreeNode a = null;
        TreeNode b = null;
        for(int i = 1 ; i < list.size() ; i ++) {
            if (list.get(i - 1).val > list.get(i).val) {
                if (a == null){
                    a = list.get(i - 1);
                    b = list.get(i);
                }
                else {
                    b = list.get(i);
                    break;
                }
            }
        }

        int t = a.val;
        a.val = b.val;
        b.val = t;
    }

    private void inOrder(TreeNode node, ArrayList<TreeNode> list){

        if(node == null)
            return;

        inOrder(node.left, list);
        list.add(node);
        inOrder(node.right, list);
    }

}

// Source : https://leetcode.com/problems/same-tree/description/

#include <iostream>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {

        if(!p && !q) return true;
        if(!p || !q) return false;
        if(p->val != q->val) return false;
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/symmetric-tree/description/

#include <iostream>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    bool isSymmetric(TreeNode* root) {

        if(root == NULL)
            return true;

        return is_mirror(root, root);
    }

private:
    bool is_mirror(TreeNode* root1, TreeNode* root2){

        if(root1 == NULL && root2 == NULL)
            return true;

        if(root1 == NULL || root2 == NULL)
            return false;

        if(root1->val != root2->val)
            return false;

        return is_mirror(root1->left, root2->right) &&
               is_mirror(root1->right, root2->left);
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/binary-tree-level-order-traversal/description/

#include <iostream>
#include <vector>
#include <queue>
#include <cassert>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

        vector<vector<int>> res;
        if(root == NULL)
            return res;

        queue<pair<TreeNode*,int>> q;
        q.push(make_pair(root, 0));

        while(!q.empty()){

            TreeNode* node = q.front().first;
            int level = q.front().second;
            q.pop();

            if(level == res.size())
                res.push_back(vector<int>());
            assert( level < res.size() );

            res[level].push_back(node->val);
            if(node->left)
                q.push(make_pair(node->left, level + 1 ));
            if(node->right)
                q.push(make_pair(node->right, level + 1 ));
        }

        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};


class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {

        vector<vector<int>> res;
        if(!root) return res;

        vector<TreeNode*> cur;
        cur.push_back(root);
        int index = 0;
        while(cur.size()){

            vector<TreeNode*> next;
            vector<int> tres;

            for(TreeNode* node: cur){
                tres.push_back(node->val);
                if(node->left) next.push_back(node->left);
                if(node->right) next.push_back(node->right);
            }

            if(index % 2) reverse(tres.begin(), tres.end());
            res.push_back(tres);

            cur = next;
            index ++;
        }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/maximum-depth-of-binary-tree/description/

#include <iostream>
#include <stack>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    int maxDepth(TreeNode* root) {

        if(root == NULL)
            return 0;

        stack<pair<TreeNode*, int>> s;
        s.push(make_pair(root, 1));
        int res = 0;
        while(!s.empty()){
            TreeNode* curNode = s.top().first;
            int depth = s.top().second;
            s.pop();

            if(curNode->left == NULL && curNode->right == NULL)
                res = max(res, depth);
            else{
                if(curNode->left)
                    s.push(make_pair(curNode->left, depth + 1));
                if(curNode->right)
                    s.push(make_pair(curNode->right, depth + 1));
            }
        }

        return res;
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return buildTree(preorder, 0, preorder.size(), inorder, 0, inorder.size());
    }

private:
    TreeNode* buildTree(const vector<int>& preorder, int preorderL, int preorderR,
                        const vector<int>& inorder, int inorderL, int inorderR){

        if(inorderL >= inorderR){
            assert(preorderL >= preorderR);
            return NULL;
        }

        if(inorderL + 1 == inorderR){
            assert(preorderL + 1 == preorderR);
            return new TreeNode(inorder[inorderL]);
        }

        TreeNode* root = new TreeNode(preorder[preorderL]);
        int rootPos = find(inorder.begin() + inorderL, inorder.begin() + inorderR, root->val) - inorder.begin();
        assert(rootPos >= inorderL && rootPos < inorderR);

        int lsize = rootPos - inorderL;
        int rsize = inorderR - (rootPos + 1);
        root->left = buildTree(preorder, preorderL + 1, preorderL + 1 + lsize, inorder, inorderL, rootPos);
        root->right = buildTree(preorder, preorderL + 1 + lsize, preorderR, inorder, rootPos + 1, inorderR);
        return root;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};


class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return buildTree(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }

private:
    TreeNode* buildTree(vector<int>& inorder, int inorderL, int inorderR,
                        vector<int>& postorder, int postorderL, int postorderR){

        if(inorderL >= inorderR){
            assert(postorderL >= postorderR);
            return NULL;
        }

        if(inorderL + 1 == inorderR){
            assert(postorderL + 1 == postorderR);
            return new TreeNode(inorder[inorderL]);
        }

        TreeNode* root = new TreeNode(postorder[postorderR - 1]);
        int rootPos = find(inorder.begin() + inorderL, inorder.begin() + inorderR, root->val) - inorder.begin();
        assert(inorderL <= rootPos && rootPos < inorderR);

        int lsize = rootPos - inorderL;
        int rsize = inorderR - (rootPos + 1);
        root->left = buildTree(inorder, inorderL, inorderL + lsize, postorder, postorderL, postorderL + lsize);
        root->right = buildTree(inorder, rootPos + 1, inorderR, postorder, postorderL + lsize, postorderR - 1);
        return root;
    }
};


int main() {

    vector<int> inorder = {9,3,15,20,7};
    vector<int> postorder = {9,15,7,20,3};
    TreeNode* root = Solution().buildTree(inorder, postorder);

    return 0;
}

// Source : https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/

#include <iostream>

using namespace std;

#include <iostream>
#include <vector>
#include <queue>
#include <cassert>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {

        vector<vector<int>> res;
        if(root == NULL)
            return res;

        queue<pair<TreeNode*,int>> q;
        q.push(make_pair(root, 0));

        while(!q.empty()){

            TreeNode* node = q.front().first;
            int level = q.front().second;
            q.pop();

            if(level == res.size())
                res.push_back(vector<int>());
            assert( level < res.size() );

            res[level].push_back(node->val);
            if(node->left)
                q.push(make_pair(node->left, level + 1 ));
            if(node->right)
                q.push(make_pair(node->right, level + 1 ));
        }

        reverse(res.begin(), res.end());
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/

#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {

        if(nums.size() == 0)
            return NULL;
        return buildTree(nums, 0, nums.size() - 1);
    }

private:
    TreeNode* buildTree(const vector<int>& nums, int l, int r){

        if(l > r) return NULL;
        if(l == r) return new TreeNode(nums[l]);

        int mid = l + (r - l + 1) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = buildTree(nums, l, mid - 1);
        root->right = buildTree(nums, mid + 1, r);
        return root;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {

private:
    ListNode* cur;

public:
    TreeNode* sortedListToBST(ListNode* head) {

        if(head == NULL)
            return NULL;

        int len = getLen(head);
        cur = head;
        return buildBST(0, len - 1);
    }

private:
    TreeNode* buildBST(int l, int r){

        if(l > r)
            return NULL;

        int mid = l + (r - l + 1) / 2;
        TreeNode* left = buildBST(l, mid - 1);

        TreeNode* root = new TreeNode(cur->val);
        cur = cur->next;

        TreeNode* right = buildBST(mid + 1, r);

        root->left = left;
        root->right = right;
        return root;
    }

    int getLen(ListNode* head){

        ListNode* cur = head;
        int res = 0;
        while(cur != NULL){
            res ++;
            cur = cur->next;
        }
        return res;
    }
};


/// Test Helper
ListNode* createLinkedList(int arr[], int n){

    if(n == 0)
        return NULL;

    ListNode* head = new ListNode(arr[0]);
    ListNode* curNode = head;
    for(int i = 1 ; i < n ; i ++){
        curNode->next = new ListNode(arr[i]);
        curNode = curNode->next;
    }

    return head;
}

void inOrder(TreeNode* node){

    if(node == NULL)
        return;

    inOrder(node->left);
    cout << node->val << " ";
    inOrder(node->right);
}


int main() {

    int arr1[] = {-10, -3, 0, 5, 9};
    ListNode* head1 = createLinkedList(arr1, 5);
    inOrder(Solution().sortedListToBST(head1));
    cout << endl;

    return 0;
}

// Source : https://leetcode.com/problems/balanced-binary-tree/

#include <iostream>
#include <unordered_map>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {

private:
    unordered_map<TreeNode*, int> height;

public:
    bool isBalanced(TreeNode* root) {

        if(!root) return true;

        int left_height = get_height(root->left);
        int right_height = get_height(root->right);

        return isBalanced(root->left) && isBalanced(root->right) && abs(left_height - right_height) <= 1;
    }

private:
    int get_height(TreeNode* node){

        if(!node) return 0;
        if(height.count(node)) return height[node];

        return height[node] = max(get_height(node->left), get_height(node->right)) + 1;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/minimum-depth-of-binary-tree/

#include <iostream>
#include <stack>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    int minDepth(TreeNode* root) {

        if(root == NULL)
            return 0;

        stack<pair<TreeNode*, int>> stack;
        stack.push(make_pair(root, 1));
        int res = INT_MAX;
        while(!stack.empty()){
            TreeNode* cur = stack.top().first;
            int step = stack.top().second;
            stack.pop();

            if(!cur->left && !cur->right)
                res = min(res, step);
            else{
                if(cur->left)
                    stack.push(make_pair(cur->left, step + 1));
                if(cur->right)
                    stack.push(make_pair(cur->right, step + 1));
            }
        }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/path-sum/description/

#include <iostream>
#include <stack>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {

        if(!root)
            return false;

        stack<pair<TreeNode*, int>> stack;
        stack.push(make_pair(root, sum));
        while(!stack.empty()){
            TreeNode* cur = stack.top().first;
            int num = stack.top().second;
            stack.pop();

            if(num == cur->val && !cur->left && !cur->right)
                return true;

            if (cur->left)
                stack.push(make_pair(cur->left, num - cur->val));
            if (cur->right)
                stack.push(make_pair(cur->right, num - cur->val));
        }
        return false;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/path-sum-ii/description/

#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {

public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {

        vector<vector<int>> res;
        if(!root)
            return res;

        vector<int> tres;
        dfs(root, tres, 0, sum, res);
        return res;
    }

private:
    void dfs(TreeNode* node, vector<int>& tres, int tsum,
             int sum, vector<vector<int>>& res){

        tres.push_back(node->val);
        tsum += node->val;

        if(!node->left && !node->right){
            if(tsum == sum)
                res.push_back(tres);
        }
        else {
            if (node->left)
                dfs(node->left, tres, tsum, sum, res);

            if (node->right)
                dfs(node->right, tres, tsum, sum, res);
        }

        tres.pop_back();
        return;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/flatten-binary-tree-to-linked-list/

#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
    void flatten(TreeNode* root) {

        if(!root) return;

        vector<TreeNode*> v;
        dfs(root, v);

        for(int i = 0; i + 1 < v.size(); i ++)
            v[i]->left = nullptr, v[i]->right = v[i + 1];

        v.back()->right = nullptr;
        root = v[0];
    }

private:
    void dfs(TreeNode* node, vector<TreeNode*>& v){

        if(!node) return;
        v.push_back(node);
        dfs(node->left, v);
        dfs(node->right, v);
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/distinct-subsequences/description/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Solution {
public:
    int numDistinct(string s, string t) {

        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for(int i = 0 ; i <= s.size() ; i ++)
            dp[i][0] = 1;

        for(int i = 1 ; i <= s.size() ; i ++)
            for(int j = 1 ; j <= t.size() ; j ++){
                dp[i][j] = dp[i - 1][j];
                if(s[i - 1] == t[j - 1])
                    dp[i][j] += dp[i - 1][j - 1];
            }

        return dp[s.size()][t.size()];
    }
};

int main() {

    string S1 = "rabbbit";
    string T1 = "rabbit";
    cout << Solution().numDistinct(S1, T1) << endl;
    // 3

    // ---

    string S2 = "babgbag";
    string T2 = "bag";
    cout << Solution().numDistinct(S2, T2) << endl;
    // 5

    return 0;
}

// Source : https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/

#include <iostream>
#include <queue>
#include <cassert>

using namespace std;

class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
            : val(_val), left(_left), right(_right), next(_next) {}
};

class Solution {
public:
    Node* connect(Node *root) {

        if(!root) return root;

        queue<Node*> q;
        q.push(root);
        int level = 0;
        while(!q.empty()){
            int n = (1 << level);
            while(n --){
                Node* cur = q.front();
                q.pop();
                if(n)
                    cur->next = q.front();
                if(cur->left){
                    q.push(cur->left);
                    assert(cur->right);
                    q.push(cur->right);
                }
            }
            level ++;
        }
        return root;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/

#include <iostream>
#include <queue>

using namespace std;

class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
            : val(_val), left(_left), right(_right), next(_next) {}
};

class Solution {
public:
    Node* connect(Node *root) {

        if(!root)
            return root;

        queue<Node*> q;
        q.push(root);
        int level_num = 1;
        while(!q.empty()){

            int new_level_num = 0;
            for(int i = 0; i < level_num; i ++){
                Node* node = q.front();
                q.pop();
                node->next = (i == level_num - 1 ? NULL : q.front());

                if(node->left){
                    q.push(node->left);
                    new_level_num ++;
                }

                if(node->right){
                    q.push(node->right);
                    new_level_num ++;
                }
            }

            level_num = new_level_num;
        }
        return root;
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/pascals-triangle/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<vector<int>> generate(int numRows) {

        vector<vector<int>> res;
        if(numRows <= 0)
            return res;

        res.push_back({1});
        for(int i = 1 ; i < numRows ; i ++){
            vector<int> row;
            row.push_back(1);
            for(int j = 1 ; j < i ; j ++)
                row.push_back(res[i-1][j-1] + res[i-1][j]);
            row.push_back(1);
            res.push_back(row);
        }
        return res;
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/pascals-triangle-ii/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>> res(rowIndex + 1, vector<int>(rowIndex + 1, 1));
        for(int i = 2; i <= rowIndex ; i ++)
            for(int j = 1; j < i; j ++ )
                res[i][j] = res[i-1][j-1] + res[i-1][j];
        return res[rowIndex];
    }
};


void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    for(int i = 0 ; i < 10 ; i ++)
        print_vec(Solution().getRow(i));

    return 0;
}

// Source : https://leetcode.com/problems/triangle/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {

        int n = triangle.size();
        for(int i = 1 ; i < n ; i ++){

            triangle[i][0] += triangle[i-1][0];
            triangle[i][i] += triangle[i-1][i-1];
            for(int j = 1 ; j < i ; j ++)
                triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]);
        }

        return *min_element(triangle[n-1].begin(), triangle[n-1].end());
    }
};


int main() {

    vector<vector<int>> triangle = { {2},
                                     {3, 4},
                                     {6,5,7},
                                     {4,1,8,3}};
    cout << Solution().minimumTotal(triangle) << endl;
    // 11

    return 0;
}

// Source : https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int maxProfit(vector<int>& prices) {

        if(prices.size() == 0)
            return 0;

        int minPrice = prices[0];
        int res = 0;
        for(int i = 1 ; i < prices.size() ; i ++){
            res = max(res, prices[i] - minPrice);
            minPrice = min(minPrice, prices[i]);
        }

        return res;
    }
};

int main() {

    int prices1[] = {7, 1, 5, 3, 6, 4};
    vector<int> pricesVec1(prices1, prices1 + sizeof(prices1)/ sizeof(int));
    cout << Solution().maxProfit(pricesVec1) << endl;

    int prices2[] = {7, 6, 4, 3, 1};
    vector<int> pricesVec2(prices2, prices2 + sizeof(prices2)/ sizeof(int));
    cout << Solution().maxProfit(pricesVec2) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int maxProfit(vector<int>& prices) {

        int res = 0;
        for(int i = 1 ; i < prices.size() ; i ++)
            if(prices[i] > prices[i-1])
                res += (prices[i] - prices[i-1]);

        return res;
    }
};

int main() {

    int prices1[] = {1, 2};
    vector<int> pricesVec1(prices1, prices1 + sizeof(prices1)/sizeof(int));
    cout << Solution().maxProfit(pricesVec1) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int maxProfit(vector<int>& prices) {

        if(prices.size() == 0)
            return 0;

        // first[i] is the max profit within day[0...i]
        vector<int> first(prices.size(), 0);
        int minPrice = prices[0];
        for(int i = 1 ; i < prices.size() ; i ++){
            first[i] = max(first[i-1], prices[i] - minPrice);
            minPrice = min(minPrice, prices[i]);
        }

        // second[i] is the max profit within day[i...n)
        vector<int> second(prices.size(), 0);
        int maxPrice = prices.back();
        for(int i = prices.size() - 2 ; i >= 0 ; i --){
            second[i] = max(second[i+1], maxPrice - prices[i]);
            maxPrice = max(maxPrice, prices[i]);
        }

        int res = second[0];
        for(int i = 0 ; i < prices.size()-1 ; i ++)
            res = max(res, first[i] + second[i+1]);
        res = max(res, first.back());

        return res;
    }
};

int main() {

    int prices1[] = {1, 2};
    vector<int> pricesVec1(prices1, prices1 + sizeof(prices1)/sizeof(int));
    cout << Solution().maxProfit(pricesVec1) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/binary-tree-maximum-path-sum/

#include <iostream>
#include <unordered_map>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {

private:
    unordered_map<TreeNode*, int> map;
    int res = INT_MIN;

public:
    int maxPathSum(TreeNode* root) {

        dfs1(root);
        dfs2(root);
        return res;
    }

private:
    void dfs2(TreeNode* node){

        if(!node) return;
        res = max(res, node->val + max(0, map[node->left]) + max(0, map[node->right]));
        dfs2(node->left);
        dfs2(node->right);
    }

    int dfs1(TreeNode* node){

        int left = node->left ? dfs1(node->left) : 0;
        int right = node->right ? dfs1(node->right) : 0;
        return map[node] = node->val + max(0, max(left, right));
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/valid-palindrome/description/

#include <iostream>

using namespace std;

class Solution {

public:
    bool isPalindrome(string s) {

        int i = next_alpha_numeric(s, 0);
        int j = prev_alpha_numeric(s, s.size() - 1);
        while(i <= j){
            if(tolower(s[i]) != tolower(s[j]))
                return false;
            i = next_alpha_numeric(s, i + 1);
            j = prev_alpha_numeric(s, j - 1);
        }
        return true;
    }

private:
    int next_alpha_numeric(const string& s, int index){
        for(int i = index ; i < s.size() ; i ++)
            if(isalnum(s[i]))
                return i;
        return s.size();
    }

    int prev_alpha_numeric(const string& s, int index){
        for(int i = index ; i >= 0 ; i --)
            if(isalnum(s[i]))
                return i;
        return -1;
    }
};


void print_bool(bool res){
    cout << (res ? "True" : "False") << endl;
}

int main() {

    string s1 = "A man, a plan, a canal: Panama";
    print_bool(Solution().isPalindrome(s1));

    string s2 = "race a car";
    print_bool(Solution().isPalindrome(s2));

    return 0;
}

// Source : https://leetcode.com/problems/word-ladder-ii/description/

#include <iostream>
#include <vector>
#include <cassert>
#include <queue>
#include <unordered_map>

using namespace std;

class Solution {

public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {

        int end = find(wordList.begin(), wordList.end(), endWord) - wordList.begin();
        if(end == wordList.size())
            return {};

        int begin = find(wordList.begin(), wordList.end(), beginWord) - wordList.begin();
        if(begin == wordList.size())
            wordList.push_back(beginWord);

        begin = find(wordList.begin(), wordList.end(), beginWord) - wordList.begin();
        end = find(wordList.begin(), wordList.end(), endWord) - wordList.begin();

        int n = wordList.size();

        // Create Graph
        vector<vector<int>> g(n, vector<int>());
        for(int i = 0 ; i < wordList.size() ; i ++)
            for(int j = i + 1 ; j < wordList.size() ; j ++)
                if(similar(wordList[i], wordList[j])){
                    g[i].push_back(j);
                    g[j].push_back(i);
                }

        unordered_map<int, int> distance;
        bfs(g, begin, end, distance);

        vector<vector<string>> res;
        vector<int> tres = {begin};
        getRes(g, begin, end, distance, wordList, tres, res);

        return res;
    }

private:
    void bfs(const vector<vector<int>>& g, int begin, int end,
             unordered_map<int, int>& distance){

        queue<int> q;
        q.push(begin);
        distance[begin] = 0;

        while(!q.empty()){
            int cur = q.front();
            q.pop();
            // assert(distance.find(cur) != distance.end());

            for(int j: g[cur])
                if(distance.find(j) == distance.end()){
                    distance[j] = distance[cur] + 1;
                    q.push(j);
                }
        }
    }

    void getRes(vector<vector<int>>& g, int cur, int end,
                unordered_map<int, int>& distance,
                const vector<string>& wordList,
                vector<int>& tres, vector<vector<string>>& res){

        if(tres.size() > 0 && tres[tres.size() - 1] == end){
            res.push_back(getPath(tres, wordList));
            return;
        }

        for(int i: g[cur])
            if(distance[i] == distance[cur] + 1){
                tres.push_back(i);
                getRes(g, i, end, distance, wordList, tres, res);
                tres.pop_back();
            }

        return;
    }

    vector<string> getPath(const vector<int>& path,
                           const vector<string>& wordList){
        vector<string> ret;
        for(const int e: path)
            ret.push_back(wordList[e]);
        return ret;
    }

    bool similar(const string& word1, const string& word2){

        // assert(word1 != "" && word1.size() == word2.size() && word1 != word2);

        int diff = 0;
        for(int i = 0 ; i < word1.size() ; i ++)
            if(word1[i] != word2[i]){
                diff ++;
                if(diff > 1)
                    return false;
            }
        return true;
    }
};


void print_vector_vector(const vector<vector<string>>& res){
    for(const vector<string>& v: res){
        for(const string& e: v)
            cout << e << " ";
        cout << endl;
    }
    cout << endl;
}

int main() {

    vector<string> vec1 = {"hot","dot","dog","lot","log","cog"};
    string beginWord1 = "hit";
    string endWord1 = "cog";
    vector<vector<string>> res1 = Solution().findLadders(beginWord1, endWord1, vec1);
    print_vector_vector(res1);

    // ---

    vector<string> vec2 = {"a","b","c"};
    string beginWord2 = "a";
    string endWord2 = "c";
    vector<vector<string>> res2 = Solution().findLadders(beginWord2, endWord2, vec2);
    print_vector_vector(res2);

    return 0;
}

// Source : https://leetcode.com/problems/word-ladder/description/

#include <iostream>
#include <vector>
#include <cassert>
#include <queue>

using namespace std;

class Solution {

public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {

        int end = find(wordList.begin(), wordList.end(), endWord) - wordList.begin();
        if(end == wordList.size())
            return 0;

        int begin = find(wordList.begin(), wordList.end(), beginWord) - wordList.begin();
        if(begin == wordList.size())
            wordList.push_back(beginWord);

        begin = find(wordList.begin(), wordList.end(), beginWord) - wordList.begin();
        end = find(wordList.begin(), wordList.end(), endWord) - wordList.begin();

        int n = wordList.size();

        vector<vector<bool>> g(n, vector<bool>(n, false));
        for(int i = 0 ; i < wordList.size() ; i ++)
            for(int j = i + 1 ; j < wordList.size() ; j ++)
                if(similar(wordList[i], wordList[j])){
                    g[i][j] = g[j][i] = true;
                }

        // bfs
        queue<int> q;
        vector<int> step(n, 0);

        q.push(begin);
        step[begin] = 1;
        while(!q.empty()){
            int cur = q.front();
            q.pop();

            for(int i = 0 ; i < n ; i ++)
                if(step[i] == 0 && g[cur][i]){
                    if(i == end)
                        return step[cur] + 1;
                    step[i] = step[cur] + 1;
                    q.push(i);
                }
        }

        return 0;
    }

private:
    bool similar(const string& word1, const string& word2){

        assert(word1 != "" && word1.size() == word2.size() && word1 != word2);

        int diff = 0;
        for(int i = 0 ; i < word1.size() ; i ++)
            if(word1[i] != word2[i]){
                diff ++;
                if(diff > 1)
                    return false;
            }
        return true;
    }
};

int main() {

    vector<string> vec1 = {"hot","dot","dog","lot","log","cog"};
    string beginWord1 = "hit";
    string endWord1 = "cog";
    cout << Solution().ladderLength(beginWord1, endWord1, vec1) << endl;
    // 5

    // ---

    vector<string> vec2 = {"a","b","c"};
    string beginWord2 = "a";
    string endWord2 = "c";
    cout << Solution().ladderLength(beginWord2, endWord2, vec2) << endl;
    // 2

    return 0;
}

// Source : https://leetcode.com/problems/longest-consecutive-sequence/description/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {

        if(nums.size() == 0)
            return 0;

        sort(nums.begin(), nums.end());

        int res = 1;
        int curres = 1;
        for(int i = 1 ; i <= nums.size() ; i ++){
            if(i == nums.size() || nums[i] - nums[i-1] > 1 ){
                res = max(res, curres);
                curres = 1;
            }
            else if(nums[i-1] + 1 == nums[i])
                curres ++;

        }

        return res;
    }
};

int main() {

    int nums1[6] = {100, 4, 200, 1, 3, 2};
    vector<int> vec1(nums1, nums1 + sizeof(nums1)/sizeof(int));
    cout << Solution().longestConsecutive(vec1) << endl;
    // 4

    // ---

    int nums2[4] = {1, 2, 0, 1};
    vector<int> vec2(nums2, nums2 + sizeof(nums2)/sizeof(int));
    cout << Solution().longestConsecutive(vec2) << endl;
    // 3

    return 0;
}

// Source : https://leetcode.com/problems/sum-root-to-leaf-numbers/description/

#include <iostream>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    int sumNumbers(TreeNode* root) {

        if(!root) return 0;

        int res = 0;
        dfs(root, 0, res);
        return res;
    }

private:
    void dfs(TreeNode* node, int tnum, int& sum){

        tnum = tnum * 10 + node->val;

        if(!node->left && !node->right)
            sum += tnum;
        else{
            if(node->left)
                dfs(node->left, tnum, sum);
            if(node->right)
                dfs(node->right, tnum, sum);
        }
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/surrounded-regions/description/

#include <vector>
#include <string>
#include <iostream>
#include <queue>
#include <cassert>

using namespace std;

class Solution {
private:
    int m, n;
    int d[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};

private:
    bool inArea(int x, int y){
        return x >= 0 && y >= 0 && x < m && y < n;
    }

    bool bfs(const vector<vector<char>> &board, int x, int y,
             vector<vector<bool>>& visited, vector<pair<int,int>>& record){

        queue<pair<int,int>> q;

        // return true if we can only get to 'X' during BFS,
        // otherwise, return false
        bool ret = true;

        visited[x][y] = true;
        q.push(pair<int,int>(x, y));
        while( !q.empty()){
            pair<int, int> cur = q.front();
            q.pop();
            record.push_back(pair<int, int>(cur.first, cur.second));

            for(int i = 0 ; i < 4 ;i ++){
                int newX = cur.first + d[i][0];
                int newY = cur.second + d[i][1];

                if(!inArea(newX, newY))
                    // If newX, newY is not in the area,
                    // it means we get out of the board in this BFS,
                    // we need to return false in this case
                    ret = false;
                else if(board[newX][newY] == 'O' && !visited[newX][newY]){
                    visited[newX][newY] = true;
                    q.push(pair<int, int>(newX, newY));
                }
            }
        }

        return ret;
    }

public:
    void solve(vector<vector<char>>& board) {
        m = board.size();
        if(m == 0)
            return;
        n = board[0].size();
        if(n == 0)
            return;

        vector<vector<bool>> visited(m, vector<bool>(n, false));
        vector<pair<int,int>> record;
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (board[i][j] == 'O' && !visited[i][j]){
                    // clear record before each time we run BFS
                    record.clear();
                    if(bfs(board, i, j, visited, record))
                        // If BFS return true,
                        // means from this position,
                        // we will not get out of the board.
                        // As a result, we can make every position we visited in this BFS from 'O' to 'X'
                        for(int k = 0 ; k < record.size() ; k ++)
                            board[record[k].first][record[k].second] = 'X';
                }

        return;
    }
};


int main(){

    int n = 4, m = 4;
    string board_array[] = {
            "XXXX",
            "XOOX",
            "XXOX",
            "XOXX"};
    vector<vector<char>> board = vector<vector<char>>(n, vector<char>(m, ' '));
    for(int i = 0 ; i < n ; i ++)
        for(int j = 0 ; j < m ; j ++)
            board[i][j] = board_array[i][j];

    Solution().solve(board);

    for(int i = 0 ; i < n ; i ++){
        for(int j = 0 ; j < m ; j ++)
            cout << board[i][j];
        cout << endl;
    }

    return 0;
}

// Source : https://leetcode.com/problems/palindrome-partitioning/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<vector<string>> partition(string s) {

        vector<vector<string>> res;
        vector<string> cur;
        dfs(s, 0, cur, res);
        return res;
    }

private:
    void dfs(const string& s, int l, vector<string>& cur,
             vector<vector<string>>& res){

        if(l == s.size()){
            res.push_back(cur);
            return;
        }

        for(int r = l; r < s.size(); r ++)
            if(ispalindrome(s, l, r)){
                cur.push_back(s.substr(l, r + 1 - l));
                dfs(s, r + 1, cur, res);
                cur.pop_back();
            }
    }

    bool ispalindrome(const string& s, int l, int r){

        while(l <= r){
            if(s[l] != s[r]) return false;
            l ++, r --;
        }
        return true;
    }
};


int main() {

    Solution().partition("efe");
    return 0;
}

// Source : https://leetcode.com/problems/palindrome-partitioning-ii/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int minCut(string s) {

        int n = s.size();

        vector<vector<bool>> dp(n + 1);
        dp[1] = vector<bool>(n, true);
        for(int i = 0; i + 1 < n; i ++)
            dp[2].push_back(s[i] == s[i + 1]);

        for(int sz = 3; sz <= n; sz ++)
            for(int i = 0; i + sz <= n; i ++)
                dp[sz].push_back((s[i] == s[i + sz - 1]) && dp[sz - 2][i + 1]);

        vector<int> res(n + 1, INT_MAX);
        res[n] = 0;
        for(int i = n - 1; i >= 0; i --){
            for(int sz = 1; i + sz <= n; sz ++)
                if(dp[sz][i]) res[i] = min(res[i], 1 + res[i + sz]);
        }
        return res[0] - 1;
    }
};


int main() {

    cout << Solution().minCut("aab") << endl;
    // 1

    cout << Solution().minCut("a") << endl;
    // 0

    cout << Solution().minCut("ab") << endl;
    // 1

    cout << Solution().minCut("aaabaa") << endl;
    // 1

    return 0;
}

// Source : https://leetcode.com/problems/clone-graph/description/

#include <iostream>
#include <stack>
#include <vector>
#include <unordered_map>

using namespace std;

struct Node {
    int val;
    vector<Node *> neighbors;
    Node(int x) : val(x) {};
};

class Solution {
public:
    Node *cloneGraph(Node *node) {

        if(node == NULL)
            return NULL;

        Node* ret = new Node(node->val);
        stack<Node*> stack;
        stack.push(node);
        unordered_map<Node*, Node*> nodeMap;
        nodeMap[node] = ret;
        while(!stack.empty()){
            Node* cur = stack.top();
            stack.pop();
            for(Node *next: cur->neighbors) {
                if (!nodeMap.count(next)) {
                    nodeMap[next] = new Node(next->val);
                    stack.push(next);
                }
                nodeMap[cur]->neighbors.push_back(nodeMap[next]);
            }
        }
        return ret;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/gas-station/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {

        int n = gas.size();

        int minv = INT_MAX, res = -1, cur = 0;
        for(int i = 0; i < n; i ++){
            cur += gas[i] - cost[i];
            if(cur < minv) minv = cur, res = i;
        }
        if(cur < 0) return -1;
        return (res + 1) % n;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/candy/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int candy(vector<int>& ratings) {

        int n = ratings.size();

        vector<int> left(n, 1);
        for(int i = 1; i < n; i ++)
            if(ratings[i] > ratings[i - 1])
                left[i] = left[i - 1] + 1;

        vector<int> right(n, 1);
        for(int i = n - 2; i >= 0; i --)
            if(ratings[i] > ratings[i + 1])
                right[i] = right[i + 1] + 1;

        int res = 0;
        for(int i = 0; i < n; i ++)
            res += max(left[i], right[i]);
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/single-number/

#include <iostream>
#include <vector>
#include <unordered_set>
#include <cassert>

using namespace std;

class Solution {
public:
    int singleNumber(vector<int>& nums) {

        assert(nums.size()%2 == 1);

        unordered_set<int> hashtable;
        for(int i = 0 ; i < nums.size() ; i ++)
            if(hashtable.find(nums[i]) == hashtable.end())
                hashtable.insert(nums[i]);
            else
                hashtable.erase(nums[i]);

        assert(hashtable.size() == 1);
        return *hashtable.begin();
    }
};


int main() {

    vector<int> nums = {0, 0, 1, 1, 2};
    cout << Solution().singleNumber(nums) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/single-number-ii/

#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

class Solution {
public:
    int singleNumber(vector<int>& nums) {

        unordered_map<int, int> f;
        for(int e: nums) f[e] ++;

        for(const pair<int, int>& p: f)
            if(p.second == 1) return p.first;
        return -1;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/copy-list-with-random-pointer/description/

#include <iostream>
#include <unordered_map>

using namespace std;

struct Node {
    int val;
    Node *next, *random;
    Node(int x) : label(x), next(NULL), random(NULL) {}
};

class Solution {
public:
    Node *copyRandomList(Node *head) {

        // oldNode -> newNode
        unordered_map<Node*, Node*> nodeMap;

        Node* dummyHead = new Node(-1);
        Node* pre = dummyHead;
        Node* node = head;
        while(node){
            if(!nodeMap.count(node))
                nodeMap[node] = new Node(node->val);
            pre->next = nodeMap[node];
            pre = pre->next;

            if(node->random){
                if(!nodeMap.count(node->random))
                    nodeMap[node->random] = new Node(node->random->val);
                pre->random = nodeMap[node->random];
            }

            node = node->next;
        }

        Node* ret = dummyHead->next;
        delete dummyHead;
        return ret;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/word-break/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {

        vector<bool> dp(s.size() + 1, false);
        dp[s.size()] = true;
        for(int i = dp.size() - 1; i >= 0; i --){
            int left = s.size() - i;
            for(const string& word: wordDict)
                if(left >= word.size() && s.substr(i, word.size()) == word &&
                   dp[i + word.size()]){
                    dp[i] = true;
                    break;
                }
        }
        return dp[0];
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/word-break-ii/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
 public:
  vector<string> wordBreak(string s, vector<string>& wordDict) {
    unordered_set<string> wordSet{begin(wordDict), end(wordDict)};
    vector<bool> dp(size(s) + 1);
    dp[0] = true;
    for (int i = 1; i <= size(s); ++i) {
      for (int j = 0; j < i; ++j) {
        if (dp[j] && wordSet.count(s.substr(j, i - j))) {
          dp[i] = true;
          break;
        }
      }
    }
    vector<string> res;
    if (!dp.back()) {
      return res;
    }
    vector<string> path;
    dfs(wordSet, dp, res, path, s, 0);
    return res;
  }

  void dfs(unordered_set<string>& wordSet, vector<bool>& dp,
           vector<string>& res, vector<string>& path, string_view s, int n) {
    if (!dp[n]) {
      return;
    }
    if (n == size(s)) {
      string t;
      for (int i = 0; i < size(path) - 1; ++i) {
        t += (path[i] + " ");
      }
      t += path.back();
      res.emplace_back(t);
    }
    for (int i = n; i < size(s); ++i) {
      string t{s.substr(n, i - n + 1)};
      if (wordSet.count(t)) {
        path.emplace_back(t);
        dfs(wordSet, dp, res, path, s, i + 1);
        path.pop_back();
      }
    }
  }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/linked-list-cycle/description/

#include <iostream>
#include <unordered_set>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    bool hasCycle(ListNode *head) {

        if(head == NULL)
            return false;

        // Use long long type for 64-bit os
        unordered_set<long long> node_address;

        ListNode* p = head;
        while(p != NULL){
            if(node_address.find((long long)(p)) == node_address.end())
                node_address.insert((long long)(p));
            else
                return true;

            p = p->next;
        }

        return false;
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/linked-list-cycle-ii/description/

#include <iostream>
#include <cassert>
#include <set>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

        if(head == NULL || head->next == NULL)
            return NULL;

        set<ListNode*> records;
        ListNode* curNode = head;
        while(curNode != NULL){
            if(records.find(curNode) != records.end())
                return curNode;

            records.insert(curNode);
            curNode = curNode->next;
        }

        return NULL;
    }
};

ListNode* createLinkedList(int arr[], int n){

    if( n == 0 )
        return NULL;

    ListNode* head = new ListNode(arr[0]);
    ListNode* curNode = head;
    for( int i = 1 ; i < n ; i ++ ){
        curNode->next = new ListNode(arr[i]);
        curNode = curNode->next;
    }

    return head;
}

ListNode* tail(ListNode* head){

    if(head == NULL)
        return NULL;

    ListNode* curNode = head;
    while(curNode->next != NULL)
        curNode = curNode->next;

    return curNode;
}

void deleteLinkedList(ListNode* head){

    ListNode* curNode = head;
    while( curNode != NULL ){
        ListNode* delNode = curNode;
        curNode = curNode->next;
        delete delNode;
    }

    return;
}

int main() {

    int n1 = 2;
    int nums1[2] = {1, 2};
    ListNode* head1 = createLinkedList(nums1, n1);

    ListNode* entrance1 = Solution().detectCycle(head1);
    if(entrance1 != NULL)
        cout << "Loop entrance at " << entrance1->val << endl;
    else
        cout << "No Loop" << endl;

    deleteLinkedList(head1);

    // ---

    int n2 = 2;
    int nums2[2] = {1, 2};
    ListNode* head2 = createLinkedList(nums2, n2);
    ListNode* tail2 = tail(head2);
    tail2->next = head2;

    ListNode* entrance2 = Solution().detectCycle(head2);
    if(entrance2)
        cout << "Loop entrance at " << entrance2->val << endl;
    else
        cout << "No Loop" << endl;

    tail2->next = NULL;
    deleteLinkedList(head2);

    return 0;
}

// Source : https://leetcode.com/problems/reorder-list/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    void reorderList(ListNode* head) {

        if(!head || !head->next) return;

        ListNode* slow = head, *fast = head;
        while(fast->next && fast->next->next)
            slow = slow->next, fast = fast->next, fast = fast->next;

        ListNode* head1 = head, *head2 = slow->next;
        slow->next = NULL;
        head2 = reverse(head2);

        ListNode* dummyHead = new ListNode(-1);
        ListNode* cur= dummyHead, *cur1 = head1, *cur2 = head2;
        for(int i = 0; cur1 || cur2; i ++)
            if(i % 2 == 0) cur->next = cur1, cur = cur->next, cur1 = cur1->next;
            else cur->next = cur2, cur = cur->next, cur2 = cur2->next;
        head = dummyHead->next;
        delete dummyHead;
    }

private:
    ListNode* reverse(ListNode* node){

        if(!node->next) return node;
        ListNode* ret = reverse(node->next);
        node->next->next = node;
        node->next = NULL;
        return ret;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/binary-tree-preorder-traversal/description/

#include <iostream>
#include <vector>
#include <stack>
#include <cassert>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {

public:
    vector<int> preorderTraversal(TreeNode* root) {

        vector<int> res;
        if(root == NULL)
            return res;

        stack<TreeNode*> stack;
        stack.push(root);
        while(!stack.empty()){
            TreeNode* curNode = stack.top();
            stack.pop();
            res.push_back(curNode->val);

            if(curNode->right)
                stack.push(curNode->right);
            if(curNode->left)
                stack.push(curNode->left);
        }
        return res;
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/binary-tree-postorder-traversal/description/

#include <iostream>
#include <vector>
#include <stack>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {

public:
    vector<int> postorderTraversal(TreeNode* root) {

        vector<int> res;
        if(root == NULL)
            return res;

        stack<TreeNode*> stack;
        TreeNode* pre = NULL;
        TreeNode* cur = root;

        while(cur != NULL || !stack.empty()){
            if(cur != NULL){
                stack.push(cur);
                pre = cur;
                cur = cur->left;
            }
            else{
                cur = stack.top();
                stack.pop();

                if(cur->right == NULL || pre == cur->right){
                    res.push_back(cur->val);
                    pre = cur;
                    cur = NULL;
                }
                else{
                    stack.push(cur);
                    pre = cur;
                    cur = cur->right;
                }
            }
        }

        return res;
    }
};


void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    TreeNode* root = new TreeNode(1);
    root->right = new TreeNode(2);
    root->right->left = new TreeNode(3);
    print_vec(Solution().postorderTraversal(root));

    return 0;
}

// Source : https://leetcode.com/problems/lru-cache/

#include <iostream>
#include <unordered_map>
#include <cassert>

using namespace std;

class LRUCache {

private:
    class Node{

    public:
        int key, value;
        Node *prev, *next;

        Node(int k, int v): key(k), value(v), prev(NULL), next(NULL){}
    };

    int capacity;
    unordered_map<int, Node*> data;

    Node* dummyHead;
    Node* tail;

public:
    LRUCache(int capacity): capacity(capacity){
        dummyHead = new Node(-1, -1);
        tail = new Node(-1, -1);

        dummyHead->next = tail;
        tail->prev = dummyHead;
    }

    ~LRUCache(){
        Node* curNode = dummyHead->next;
        Node* delNode;
        while (curNode != tail)
        {
            delNode = curNode;
            curNode = curNode->next;
            delete delNode;
        }
    }

    int get(int key) {
        if(data.count(key)){
            moveToHead(data[key]);
            assert(dummyHead->next);
            return dummyHead->next->value;
        }
        return -1;
    }

    void put(int key, int value) {
        if(data.count(key)){
            data[key]->value = value;
            moveToHead(data[key]);
            return;
        }

        data[key] = new Node(key, value);
        addFirst(data[key]);
        if(data.size() > capacity){
            assert(data.size() == capacity + 1);
            int delKey = removeLast();
            assert(data.count(delKey));
            data.erase(delKey);
        }
    }

private:
    void moveToHead(Node* node){
        node->prev->next = node->next;
        node->next->prev = node->prev;

        node->prev = node->next = NULL;
        addFirst(node);
    }

    void addFirst(Node* node){

        node->next = dummyHead->next;
        node->next->prev= node;

        node->prev = dummyHead;
        dummyHead->next = node;
    }

    int removeLast(){

        assert(tail->prev != dummyHead);
        Node* delNode = tail->prev;

        tail->prev = tail->prev->prev;
        tail->prev->next = tail;

        int key = delNode->key;
        delete delNode;
        return key;
    }

    void debug(){

        cout << "Hash Map : sz = " << data.size() << endl;
        for(const pair<int, Node*>& p: data)
            cout << p.first << " : ( " << p.second->key << " , " << p.second->value << " )" << endl;

        cout << "Double Linked List : " << endl;
        Node* cur = dummyHead;
        while(cur)
            cout << "(" << cur->key << "," << cur->value << ") -> ", cur = cur->next;
        cout << "NULL" << endl << endl;
    }
};


int main() {

    LRUCache cache1(2);
    cache1.put(1, 1);
    cache1.put(2, 2);
    cout << cache1.get(1) << endl; // 1
    cache1.put(3, 3);
    cout << cache1.get(2) << endl; // -1
    cache1.put(4, 4);
    cout << cache1.get(1) << endl; // -1
    cout << cache1.get(3) << endl; // 3
    cout << cache1.get(4) << endl; // 4

    cout << endl;

    LRUCache cache2(2);
    cache2.put(2, 1);
    cache2.put(1, 1);
    cache2.put(2, 3);
    cache2.put(4, 1);
    cout << cache2.get(1) << endl; // -1
    cout << cache2.get(2) << endl; // 3

    return 0;
}

// Source : https://leetcode.com/problems/insertion-sort-list/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};


ListNode* createLinkedList(int arr[], int n){

    if(n == 0)
        return NULL;

    ListNode* head = new ListNode(arr[0]);
    ListNode* curNode = head;
    for(int i = 1 ; i < n ; i ++){
        curNode->next = new ListNode(arr[i]);
        curNode = curNode->next;
    }

    return head;
}

void printLinkedList(ListNode* head){

    ListNode* curNode = head;
    while(curNode != NULL){
        cout << curNode->val << " -> ";
        curNode = curNode->next;
    }

    cout << "NULL" << endl;

    return;
}

void deleteLinkedList(ListNode* head){

    ListNode* curNode = head;
    while(curNode != NULL){
        ListNode* delNode = curNode;
        curNode = curNode->next;
        delete delNode;
    }

    return;
}

class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {

        if(!head || !head->next) return head;

        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = head;

        ListNode* pre = dummyHead->next;
        while(pre->next){
            int val = pre->next->val;
            ListNode* next = pre->next->next;
            ListNode* pi = dummyHead;
            for(; pi != pre; pi = pi->next)
                if(pi->next->val > val){
                    ListNode* pj = pi->next;
                    ListNode* swapNode = pre->next;

                    pi->next = swapNode;
                    swapNode->next = pj;
                    pre->next = next;

                    break;
                }

            if(pi == pre) pre = pre->next;
        }
        return dummyHead->next;
    }
};


int main() {

    int arr1[4] = {4, 2, 1, 3};
    ListNode* head1 = createLinkedList(arr1, 4);
    ListNode* res1 = Solution().insertionSortList(head1);
    printLinkedList(res1);
    deleteLinkedList(res1);

    int arr2[5] = {-1, 5, 3, 4, 0};
    ListNode* head2 = createLinkedList(arr2, 5);
    ListNode* res2 = Solution().insertionSortList(head2);
    printLinkedList(res2);
    deleteLinkedList(res2);

    return 0;
}

// Source : https://leetcode.com/problems/two-sum/description/

#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class ListOp{

public:
    static ListNode* createLinkedList(const vector<int>& arr){

        if(arr.size() == 0)
            return NULL;

        ListNode* head = new ListNode(arr[0]);
        ListNode* curNode = head;
        for(int i = 1 ; i < arr.size() ; i ++){
            curNode->next = new ListNode(arr[i]);
            curNode = curNode->next;
        }
        return head;
    }

    static void printLinkedList(ListNode* head){

        ListNode* curNode = head;
        while(curNode){
            cout << curNode->val << " -> ";
            curNode = curNode->next;
        }
        cout << "NULL" << endl;
    }

    static void deleteLinkedList(ListNode* head){

        ListNode* curNode = head;
        while(curNode){
            ListNode* delNode = curNode;
            curNode = curNode->next;
            delete delNode;
        }
    }
};

class Solution {
public:
    ListNode* sortList(ListNode* head) {

        if(head == NULL || head->next == NULL)
            return head;

        ListNode* slow = head;
        ListNode* fast = head->next;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode* head2 = slow->next;
        slow->next = NULL;
        head = sortList(head);
        head2 = sortList(head2);
        return merge(head, head2);
    }

private:
    ListNode* merge(ListNode* a, ListNode* b){

        ListNode* dummyHead = new ListNode(-1);
        ListNode *p1 = a, *p2 = b, *p = dummyHead;
        while(p1 && p2)
            if(p1->val < p2->val){
                p->next = p1;
                p1 = p1->next;
                p = p->next;
                p->next = NULL;
            }
            else{
                p->next = p2;
                p2 = p2->next;
                p = p->next;
                p->next = NULL;
            }
        if(p1) p->next = p1;
        if(p2) p->next = p2;

        ListNode* ret = dummyHead->next;
        delete dummyHead;
        return ret;
    }
};


int main() {

    vector<int> arr = {4, 2, 1, 3};
    ListNode* head = Solution().sortList(ListOp::createLinkedList(arr));
    ListOp::printLinkedList(head);
    ListOp::deleteLinkedList(head);

    return 0;
}

// Source : https://leetcode.com/problems/max-points-on-a-line/

#include <iostream>
#include <vector>
#include <map>

using namespace std;

class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {

        if(points.size() <= 1)
            return points.size();

        int res = 1;
        for( int i = 0 ; i < points.size() ; i ++ ){

            map<pair<int,int>, int> record;
            int samePoint = 0;
            for( int j = 0 ; j < points.size() ; j ++ ){
                if( points[i][0] == points[j][0] && points[i][1] == points[j][1])
                    samePoint ++;
                else
                    record[slope(points[j], points[i])]++;
            }

            res = max(res, samePoint);    // In case the record is empty and all the points are in the same point.
            for(map<pair<int,int>,int>::iterator iter = record.begin() ; iter != record.end() ; iter ++)
                res = max(res, iter->second + samePoint);
        }

        return res;
    }

private:
    pair<int,int> slope(const vector<int>& pa, const vector<int>& pb){

        int dy = pa[1] - pb[1];
        int dx = pa[0] - pb[0];
        if(dx == 0)
            return make_pair(1,0);
        if(dy == 0)
            return make_pair(0,1);

        int g = gcd(abs(dy), abs(dx));
        dy /= g;
        dx /= g;
        if(dx < 0){
            dy = -dy;
            dx = -dx;
        }
        return make_pair(dy, dx);
    }

    int gcd(int a, int b){

        if(a < b)
            swap(a, b);

        if(a % b == 0)
            return b;

        return gcd(b, a%b );
    }
};


int main() {

    vector<vector<int>> pvec1 = {{1, 1}, {1, 1}};
    cout<<Solution().maxPoints(pvec1)<<endl;

    return 0;
}

// Source : https://leetcode.com/problems/evaluate-reverse-polish-notation/description/

#include <iostream>
#include <stack>
#include <vector>

using namespace std;

class Solution {
public:
    int evalRPN(vector<string>& tokens) {

        stack<int> nums;
        for(const string& s: tokens){
            if(s == "+" || s == "-" || s == "*" || s == "/"){
                int a = nums.top();
                nums.pop();
                int b = nums.top();
                nums.pop();

                if(s == "+")
                    nums.push(b + a);
                else if(s == "-")
                    nums.push(b - a);
                else if(s == "*")
                    nums.push(b * a);
                else if(s == "/")
                    nums.push(b / a);
            }
            else
                nums.push(atoi(s.c_str()));
        }
        return nums.top();
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/reverse-words-in-a-string/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

public:
    string reverseWords(string &s) {

        vector<string> vec = split(s);
        if(vec.size() == 0){
            s = "";
            return s;
        }

        reverse(vec.begin(), vec.end());
        s = vec[0];
        for(int i = 1; i < vec.size() ; i ++)
            s += " " + vec[i];

        return s;
    }

private:
    vector<string> split(const string& s){

        vector<string> res;

        int start = nextNonSpace(s, 0);
        for(int i = start + 1; i <= s.size() ;)
            if(i == s.size() || s[i] == ' ') {
                res.push_back(s.substr(start, i - start));
                start = nextNonSpace(s, i);
                i = start + 1;
            }
            else
                i ++;

        return res;
    }

    int nextNonSpace(const string& s, int start){
        int i = start;
        for(; i < s.size() ; i ++)
            if(s[i] != ' ')
                return i;
        return i;
    }
};


int main() {

    string s1 = "the sky is blue";
    cout << Solution().reverseWords(s1) << endl;

    string s2 = "";
    cout << Solution().reverseWords(s2) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/maximum-product-subarray/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int maxProduct(vector<int>& nums) {

        int res = nums[0] == 0 ? 0 : INT_MIN;
        bool has_zero = nums[0] == 0 ? true : false;
        for(int start = next_non_zero(nums, 0), i = start + 1; i <= nums.size(); i ++)
            if(i == nums.size() || nums[i] == 0){
                if(i < nums.size() && nums[i] == 0) has_zero = true;
                res = max(res, solve(nums, start, i - 1));
                start = next_non_zero(nums, i);
                i = start;
            }

        if(has_zero) res = max(res, 0);
        return res;
    }

private:
    int solve(const vector<int>& nums, int l, int r){

        int res = nums[l], cur = nums[l];
        for(int i = l + 1; i <= r; i ++){
            cur *= nums[i];
            res = max(res, cur);
        }

        res = max(res, nums[r]);
        cur = nums[r];
        for(int i = r - 1; i >= l; i --){
            cur *= nums[i];
            res = max(res, cur);
        }
        return res;
    }

    int next_non_zero(const vector<int>& nums, int start){

        for(int i = start; i < nums.size(); i ++)
            if(nums[i] != 0) return i;
        return nums.size();
    }
};


int main() {

    vector<int> nums1 = {-3, 0, 1, -2};
    cout << Solution().maxProduct(nums1) << endl;
    // 1

    return 0;
}

// Source : https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {
public:
    int findMin(vector<int>& nums) {
        int lo = 0, hi = nums.size()-1;
        while (lo < hi && nums[lo] > nums[hi]) {
            int mid = lo + (hi-lo)/2;
            if (nums[mid] < nums[hi]) {
                hi = mid;
            } else {
                lo = mid+1;
            }
        }
        return nums[lo];
    }
};

int main() {

    vector<int> nums1 = {3, 4, 5, 1, 2};
    cout << Solution().findMin(nums1) << endl; // 1

    vector<int> nums2 = {4, 5, 6, 7, 0, 1, 2};
    cout << Solution().findMin(nums2) << endl; // 0

    vector<int> nums3 = {3, 1, 2};
    cout << Solution().findMin(nums3) << endl; // 1

    vector<int> nums4 = {7, 1, 2, 3, 4, 5, 6};
    cout << Solution().findMin(nums4) << endl; // 1

    return 0;
}

// Source : https://leetcode.com/problems/min-stack/description/

#include <iostream>
#include <set>
#include <cassert>

using namespace std;

class MinStack {

private:
    int index = 0;
    set<pair<int, int>> vi;   // value - index
    set<pair<int, int>> iv;   // index - value

public:
    /** initialize your data structure here. */
    MinStack() {
        vi.clear();
        iv.clear();
        index = 0;
    }

    void push(int x) {
        vi.insert(make_pair(x, index));
        iv.insert(make_pair(index, x));
        index ++;
    }

    int pop() {

        assert(iv.size() > 0);

        pair<int, int> e_iv = *iv.rbegin();
        iv.erase(e_iv);

        pair<int, int> e_vi = make_pair(e_iv.second, e_iv.first);
        vi.erase(e_vi);

        return e_iv.second;
    }

    int top() {
        assert(iv.size() > 0);
        return iv.rbegin()->second;
    }

    int getMin() {
        assert(vi.size() > 0);
        return vi.begin()->first;
    }

};

int main() {

    MinStack minStack;
    minStack.push(-2);
    minStack.push(0);
    minStack.push(-3);
    cout << minStack.getMin() << endl; // -> -3
    minStack.pop();
    cout << minStack.top() << endl;    // -> 0
    cout << minStack.getMin() << endl; // -> -2

    return 0;
}

// Source : https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/description/

#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>
#include <cmath>

using namespace std;

class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {

        unordered_map<char, int> map;
        int l = 0, r = 0;
        int res = 0;
        while(r <= s.size()){
            if(r == s.size() || (map.size() == 2 && map.find(s[r]) == map.end())){
                res = max(res, r-l);
                while(map.size() >= 2){
                    if(map[s[l]] == 1)
                        map.erase(s[l]);
                    else
                        map[s[l]] --;
                    l ++;
                }

                if( r == s.size() )
                    break;
            }
            else{
                if(map.find(s[r]) == map.end())
                    map[s[r]] = 1;
                else
                    map[s[r]] += 1;
                r ++;
            }
        }

        return res;
    }
};


int main() {

    cout << Solution().lengthOfLongestSubstringTwoDistinct("eceba") << endl;
    cout << Solution().lengthOfLongestSubstringTwoDistinct("a") << endl;

    return 0;
}

// Source : https://leetcode.com/problems/intersection-of-two-linked-lists/description/

#include <iostream>
#include <unordered_set>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

        unordered_set<ListNode*> set;
        for(ListNode* pA = headA; pA; pA = pA->next)
            set.insert(pA);

        for(ListNode* pB = headB; pB; pB = pB->next)
            if(set.count(pB))
                return pB;

        return NULL;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/one-edit-distance/

#include <iostream>
#include <cassert>

using namespace std;

class Solution {

public:
    bool isOneEditDistance(string s, string t) {

        if(s.size() == 0) return t.size() == 1;
        if(t.size() == 0) return s.size() == 1;

        int si = 0, ti = 0;
        while(si < s.size() && ti < t.size() && s[si] == t[ti]) si ++, ti ++;
        si --, ti --;

        int sj = s.size() - 1, tj = t.size() - 1;
        while(sj > si && tj > ti && s[sj] == t[tj]) sj --, tj --;

        if(si + 1 == sj && ti == tj) return true;
        if(ti + 1 == tj && si == sj) return true;
        if(si + 1 == sj && ti + 1 == tj) return true;
        return false;
    }
};


int main() {

    string s1 = "ab", t1 = "acb";
    cout << Solution().isOneEditDistance(s1, t1) << endl;

    string s2 = "cab", t2 = "ad";
    cout << Solution().isOneEditDistance(s2, t2) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/find-peak-element/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int findPeakElement(vector<int>& nums) {

        if(nums.size() == 1) return 0;

        int n = nums.size();
        if(nums[0] > nums[1]) return 0;
        if(nums[n - 1] > nums[n - 2]) return n - 1;

        for(int i = 1; i + 1 < n; i ++)
            if(nums[i] > nums[i - 1] && nums[i] > nums[i + 1])
                return i;
        return -1;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/missing-ranges/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<string> findMissingRanges(vector<int>& nums, int lower, int upper) {

        nums.insert(nums.begin(), lower - 1);
        nums.push_back(upper + 1);

        vector<string> res;
        for(int i = 0; i + 1 < nums.size(); i ++)
            if(nums[i] + 1 != nums[i + 1]){
                int l = nums[i] + 1, r = nums[i + 1] - 1;
                if(l == r) res.push_back(to_string(l));
                else res.push_back(to_string(l) + "->" + to_string(r));
            }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/maximum-gap/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int maximumGap(vector<int>& nums) {

        if(nums.size() < 2) return 0;

        sort(nums.begin(), nums.end());
        int res = INT_MIN;
        for(int i = 1; i < nums.size(); i ++)
            res = max(res, nums[i] - nums[i - 1]);
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/compare-version-numbers/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int compareVersion(string version1, string version2) {

        vector<int> v1 = get_ver(version1), v2 = get_ver(version2);

        while(v1.size() < v2.size()) v1.push_back(0);
        while(v2.size() < v1.size()) v2.push_back(0);
        return v1 == v2 ? 0 : (v1 < v2 ? -1 : 1);
    }

private:
    vector<int> get_ver(string s){

        vector<int> res;
        while(true){
            int p = s.find('.');
            if(p == string::npos){
                res.push_back(atoi(s.c_str()));
                break;
            }

            res.push_back(atoi(s.substr(0, p).c_str()));
            s = s.substr(p + 1);
        }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {

public:
    vector<int> twoSum(vector<int>& numbers, int target) {

        assert(numbers.size() >= 2);
        // assert(isSorted(numbers));

        int l = 0, r = numbers.size() - 1;
        while(l < r){

            if(numbers[l] + numbers[r] == target){
                int res[2] = {l+1, r+1};
                return vector<int>(res, res+2);
            }
            else if(numbers[l] + numbers[r] < target)
                l ++;
            else // numbers[l] + numbers[r] > target
                r --;
        }

        throw invalid_argument("the input has no solution");
    }

private:
    bool isSorted(const vector<int>& numbers){
        for(int i = 1 ; i < numbers.size() ; i ++)
            if(numbers[i] < numbers[i-1])
                return false;
        return true;
    }

};

void printVec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    int nums[] = {2, 7, 11, 15};
    vector<int> vec(nums, nums + sizeof(nums) / sizeof(int));
    int target = 9;
    printVec(Solution().twoSum(vec, target));

    return 0;
}

// Source : https://leetcode.com/problems/excel-sheet-column-title/

#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    string convertToTitle(int columnNumber) {

        string res = "";
        while(columnNumber){
            int c = columnNumber % 26;
            if(c == 0) c += 26;

            res += string(1, 'A' + c - 1);
            columnNumber = (columnNumber - c) / 26;
        }
        reverse(res.begin(), res.end());
        return res;
    }
};


int main() {

    cout << Solution().convertToTitle(1) << endl;
    // A

    cout << Solution().convertToTitle(28) << endl;
    // AB

    cout << Solution().convertToTitle(701) << endl;
    // ZY

    cout << Solution().convertToTitle(2147483647) << endl;
    // FXSHRXW

    cout << Solution().convertToTitle(52) << endl;
    // AZ

    return 0;
}

// Source : https://leetcode.com/problems/majority-element/description/

#include <iostream>
#include <vector>
#include <unordered_map>
#include <cassert>

using namespace std;

class Solution {

public:
    int majorityElement(vector<int>& nums) {

        assert(nums.size() > 0);

        unordered_map<int, int> records;
        for(int num: nums)
            records[num] ++;

        for(pair<int, int> record: records)
            if(record.second > nums.size()/2)
                return record.first;

        throw invalid_argument("No Solution!");
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/two-sum-iii-data-structure-design/

#include <iostream>
#include <unordered_map>
#include <cassert>
#include <stdexcept>

using namespace std;

class TwoSum {

private:
    // The numbers store the number pair represent (number, count of the number)
    unordered_map<int,int> numbers;

public:
    // Add the number to an internal data structure.
    void add(int number) {
        numbers[number] += 1;
    }

    // Find if there exists any pair of numbers which sum is equal to the value.
    bool find(int value) {

        for( unordered_map<int,int>::iterator iter = numbers.begin() ; iter != numbers.end() ; iter ++ ){
            int num = iter->first;
            if( numbers.find(value - num)  != numbers.end() ){
                if( value - num == num && numbers[num] == 1 )
                    continue;

                return true;
            }
        }

        return false;
    }
};


int main() {

    TwoSum twoSum;
    twoSum.add(1);
    twoSum.add(3);
    twoSum.add(5);

    cout << twoSum.find(4) << endl;
    cout << twoSum.find(7) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/excel-sheet-column-number/description/

#include <iostream>
#include <cmath>

using namespace std;

class Solution {
public:
    int titleToNumber(string s) {

        int num = 0;
        for(char c: s)
            num = num * 26 + (c - 'A' + 1);

        return num;
    }
};


int main() {

    cout << Solution().titleToNumber("A") << endl;  // 1
    cout << Solution().titleToNumber("AB") << endl; // 28
    cout << Solution().titleToNumber("ZY") << endl; // 701

    return 0;
}

// Source : https://leetcode.com/problems/binary-search-tree-iterator/description/

#include <iostream>
#include <stack>
#include <vector>
#include <cassert>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class BSTIterator {

private:
    stack<TreeNode*> myStack;

public:
    BSTIterator(TreeNode *root) {

        TreeNode* node = root;
        while(node != NULL){
            myStack.push(node);
            node = node->left;
        }
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {

        return !myStack.empty();
    }

    /** @return the next smallest number */
    int next() {

        assert(hasNext());
        TreeNode* retNode = myStack.top();
        myStack.pop();

        TreeNode* node = retNode->right;
        while(node != NULL){
            myStack.push(node);
            node = node->left;
        }

        return retNode->val;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/largest-number/

#include <iostream>
#include <string>
#include <algorithm>
#include <vector>

using namespace std;

class Solution {
public:
    string largestNumber(vector<int>& nums) {

        vector<string> v;
        for(int num: nums) v.push_back(to_string(num));

        sort(v.begin(), v.end(), [](const string& a, const string& b){

            return a + b > b + a;
        });

        string res = "";
        for(const string& s: v) res += s;

        while(res[0] == '0') res = res.substr(1);
        return res.size() ? res : "0";
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/reverse-words-in-a-string-ii/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    void reverseWords(vector<char>& str) {

        vector<string> stack;
        int start = 0;
        string cur = "";
        for(int i = start; i <= str.size() ;)
            if(i == str.size() || str[i] == ' '){
                stack.push_back(cur);
                start = i + 1;
                i = start;
                cur = "";
            }
            else
                cur += str[i++];

        int index = 0;
        for(int i = stack.size() - 1; i >= 0 ; i --){
            for(int j = 0; j < stack[i].size() ; j ++)
                str[index++] = stack[i][j];
            if(i > 0)
                str[index++] = ' ';
        }
    }
};


void print_vec(const vector<char>& vec){
    for(char c: vec)
        cout << c << " ";
    cout << endl;
}

int main() {

    vector<char> str1 = {'t', 'h', 'e', ' ',
                         's', 'k', 'y', ' ',
                         'i', 's', ' ',
                         'b', 'l', 'u', 'e'};
    Solution().reverseWords(str1);
    print_vec(str1);

    return 0;
}

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

#include <iostream>
#include <vector>

using namespace std;

class Solution {

private:
    int **dp;  // dp[i][j], start from day[i],
               // the most profit to complete at most j transactions.

public:
    int maxProfit(int k, vector<int>& prices) {
        if(k <= 0) return 0;

        if(k >= prices.size() -1)
            return maxProfit(prices);

        dp = new int*[prices.size()];
        for(int i = 0 ; i < prices.size() ; i ++){
            dp[i] = new int[k+1];
            for(int j = 0 ; j <= k ; j ++)
                dp[i][j] = -1;
        }

        int res = solve(prices, 0, k);

        for(int i = 0 ; i < prices.size() ; i ++)
            delete[] dp[i];
        delete[] dp;

        return res;
    }

private:
    int solve(const vector<int>& prices, int startIndex, int left){

        if(startIndex >= prices.size() || left == 0)
            return 0;

        if(dp[startIndex][left] != -1)
            return dp[startIndex][left];

        int minPrice = prices[startIndex];
        int best = 0;
        for(int i = startIndex + 1 ; i < prices.size() ; i ++)
            if(prices[i] > minPrice)
                best = max(best, prices[i] - minPrice + solve(prices, i + 1, left - 1));
            else{
                best = max(best, solve(prices, i + 1, left));
                minPrice = prices[i];
            }

        return dp[startIndex][left] = best;
    }

    int maxProfit(const vector<int>& prices){
        int res = 0;
        for(int i = 1 ; i < prices.size() ; i ++)
            if(prices[i] > prices[i-1])
                res += (prices[i] - prices[i-1]);
        return res;
    }
};

int main() {

    int prices1[] = {1, 2};
    int k1 = 1;
    vector<int> pricesVec1(prices1, prices1 + sizeof(prices1)/sizeof(int));
    cout << Solution().maxProfit(k1, pricesVec1) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/rotate-array/description/

#include <iostream>
#include <vector>
#include <queue>

using namespace std;

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        if(k == 0) return;

        reverse(begin(nums), end(nums));
        reverse(begin(nums), begin(nums) + k);
        reverse(begin(nums) + k, end(nums));

        return;
    }
};


void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<int> nums1 = {1, 2, 3, 4, 5, 6, 7};
    Solution().rotate(nums1, 3);
    print_vec(nums1);

    vector<int> nums2 = {1, 2};
    Solution().rotate(nums2, 3);
    print_vec(nums2);

    return 0;
}

// Source : https://leetcode.com/problems/reverse-bits/

#include <iostream>

class Solution {
public:
    uint32_t reverseBits(uint32_t n) {

        uint32_t res = 0;
        for(int i = 0; i < 32; i ++){
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/number-of-1-bits/description/

#include <iostream>

using namespace std;

class Solution {
public:
    int hammingWeight(uint32_t n) {

        int res = popcountll(n);
        return res;
    }
private:
    int popcountll(unsigned long long x)
    {
      int n;
      if (x == 0){return 0;}
      x = (x&0x5555555555555555ULL)+((x>>1)&0x5555555555555555ULL);
      x = (x&0x3333333333333333ULL)+((x>>2)&0x3333333333333333ULL);
      x = (x&0x0F0F0F0F0F0F0F0FULL)+((x>>4)&0x0F0F0F0F0F0F0F0FULL);
      x = (x&0x00FF00FF00FF00FFULL)+((x>>8)&0x00FF00FF00FF00FFULL);
      x = (x&0x0000FFFF0000FFFFULL)+((x>>16)&0x0000FFFF0000FFFFULL);
      x = (x&0x00000000FFFFFFFFULL)+((x>>32)&0x00000000FFFFFFFFULL);
      n = (int)x;
      return n;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/house-robber/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
private:
    // the max profit for robbing nums[i...n)
    vector<int> memo;

    int tryRob(const vector<int> &nums, int index){

        if(index >= nums.size())
            return 0;

        if(memo[index] != -1)
            return memo[index];

        return memo[index] = max(tryRob(nums, index + 1),
                                 nums[index] + tryRob(nums, index + 2));
    }

public:
    int rob(vector<int>& nums) {

        memo.clear();
        for(int i = 0 ; i < nums.size() ; i ++)
            memo.push_back(-1);
        return tryRob(nums, 0);
    }
};

int main() {

    int nums[] = {2, 1};
    vector<int> vec(nums, nums + sizeof(nums)/sizeof(int));

    cout << Solution().rob(vec) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/binary-tree-right-side-view/

#include <iostream>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};


class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {

        vector<int> res;
        if(!root) return res;

        vector<TreeNode*> cur = {root};
        while(cur.size()){
            res.push_back(cur.back()->val);

            vector<TreeNode*> next;
            for(TreeNode* node: cur){
                if(node->left) next.push_back(node->left);
                if(node->right) next.push_back(node->right);
            }
            cur = next;
        }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/number-of-islands/description/

#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

class Solution {

private:
    int d[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int m, n;
    vector<vector<bool>> visited;

    bool inArea(int x, int y){
        return x >= 0 && x < m && y >= 0 && y < n;
    }

    void dfs(vector<vector<char>>& grid, int x, int y){

        //assert(inArea(x,y));
        visited[x][y] = true;
        for(int i = 0; i < 4; i ++){
            int newx = x + d[i][0];
            int newy = y + d[i][1];
            if(inArea(newx, newy) && !visited[newx][newy] && grid[newx][newy] == '1')
                dfs(grid, newx, newy);
        }

        return;
    }

public:
    int numIslands(vector<vector<char>>& grid) {

        m = grid.size();
        if(m == 0)
            return 0;
        n = grid[0].size();
        if(n == 0)
            return 0;

        for(int i = 0 ; i < m ; i ++)
            visited.push_back(vector<bool>(n, false));

        int res = 0;
        for(int i = 0 ; i < m ; i ++)
            for(int j = 0 ; j < n ; j ++)
                if(grid[i][j] == '1' && !visited[i][j]){
                    dfs(grid, i, j);
                    res ++;
                }
        return res;
    }
};


int main() {

    char g1[4][5] = {
            {'1','1','1','1','0'},
            {'1','1','0','1','0'},
            {'1','1','0','0','0'},
            {'0','0','0','0','0'}
    };
    vector<vector<char>> grid1;
    for(int i = 0 ; i < 4 ; i ++)
        grid1.push_back( vector<char>(g1[i], g1[i] + sizeof( g1[i])/sizeof(char)));

    cout << Solution().numIslands(grid1) << endl;
    // 1

    // ---

    char g2[4][5] = {
            {'1','1','0','0','0'},
            {'1','1','0','0','0'},
            {'0','0','1','0','0'},
            {'0','0','0','1','1'}
    };
    vector<vector<char>> grid2;
    for(int i = 0 ; i < 4 ; i ++)
        grid2.push_back(vector<char>(g2[i], g2[i] + sizeof( g2[i])/sizeof(char)));

    cout << Solution().numIslands(grid2) << endl;
    // 2

    return 0;
}

// Source : https://leetcode.com/problems/bitwise-and-of-numbers-range/

#include <iostream>

using namespace std;

class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {

        int cur = 0;
        for(int i = 30; i >= 0; i --){
            if(left < cur + (1 << i) && cur + (1 << i) <= right)
                break;
            else if(left >= cur + (1 << i))
                cur += (1 << i);
        }
        return cur;
    }
};


int main() {

    cout << Solution().rangeBitwiseAnd(5, 7) << endl;
    // 4

    return 0;
}

// Source : https://leetcode.com/problems/happy-number/

#include <iostream>
#include <set>

using namespace std;

/// The only cycle is 4-16-37-58-89-145-42-20-4
class Solution {
public:
    bool isHappy(int n) {

        set<int> cycle = {4, 16, 37, 58, 89, 145, 42, 20};
        unordered_set<int> record;
        record.insert(n);
        while(n != 1){
            if(cycle.count(n)) return false;
            n = op(n);
            if( record.find(n) == record.end() )
                record.insert(n);
            else
                return false;
        }
        return true;
    }

private:
    int op(int x){
        int res = 0;
        while(x){
            int t = x % 10;
            res += t * t;
            x /= 10;
        }
        return res;
    }
};


void print_bool(bool res){

    cout << (res ? "True" : "False") << endl;
}

int main() {

    print_bool(Solution().isHappy(19));
    // true

    return 0;
}

// Source : https://leetcode.com/problems/remove-linked-list-elements/description/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* createLinkedList(int arr[], int n){

    if(n == 0)
        return NULL;

    ListNode* head = new ListNode(arr[0]);
    ListNode* curNode = head;
    for(int i = 1 ; i < n ; i ++){
        curNode->next = new ListNode(arr[i]);
        curNode = curNode->next;
    }

    return head;
}

void printLinkedList(ListNode* head){

    if(head == NULL){
        cout << "NULL" << endl;
        return;
    }

    ListNode* curNode = head;
    while(curNode != NULL){
        cout << curNode->val;
        if(curNode->next != NULL)
            cout << " -> ";
        curNode = curNode->next;
    }

    cout << endl;

    return;
}

void deleteLinkedList(ListNode* head){

    ListNode* curNode = head;
    while(curNode != NULL){
        ListNode* delNode = curNode;
        curNode = curNode->next;
        delete delNode;
    }

    return;
}

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {

        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* cur = dummyHead;
        while(cur->next != NULL){
            if(cur->next->val == val){
                ListNode* delNode = cur->next;
                cur->next = delNode->next;
                delete delNode;
            }
            else
                cur = cur->next;
        }

        ListNode* retNode = dummyHead->next;
        delete dummyHead;

        return retNode;
    }
};


int main() {

    int arr[] = {1, 2, 6, 3, 4, 5, 6};
    int n = sizeof(arr) / sizeof(int);

    ListNode* head = createLinkedList(arr, n);
    printLinkedList(head);

    Solution().removeElements(head, 6);
    printLinkedList(head);

    deleteLinkedList(head);

    return 0;
}

// Source : https://leetcode.com/problems/count-primes/submissions/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    int countPrimes(int n) {

        int res = 0;
        vector<int> shieve(n, false);
        for(int i = 2; i < n; i ++)
            if(!shieve[i]){
                res ++;
                for(int j = i; j < n; j += i) shieve[j] = true;
            }
        return res;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/isomorphic-strings/description/

#include <iostream>

using namespace std;

class Solution {
public:
    bool isIsomorphic(string s, string t) {

        if(s.size() != t.size())
            return false;

        int map[256];
        memset(map, -1, sizeof(map));

        bool mapped[256];
        memset(mapped, false, sizeof(mapped));

        for(int i = 0 ; i < s.size() ; i ++){
            if(map[s[i]] == -1){
                if(mapped[t[i]])
                    return false;
                map[s[i]] = t[i];
                mapped[t[i]] = true;
            }
            else if(map[s[i]] != t[i])
                return false;
        }
        return true;
    }
};


void print_bool(bool res){
    cout << (res ? "True" : "False") << endl;
}

int main() {

    print_bool(Solution().isIsomorphic("egg", "add"));
    print_bool(Solution().isIsomorphic("foo", "bar"));
    print_bool(Solution().isIsomorphic("paper", "title"));
    print_bool(Solution().isIsomorphic("aa", "ab"));

    return 0;
}

// Source : https://leetcode.com/problems/reverse-linked-list/description/

#include <iostream>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* reverseList(ListNode* head) {

        ListNode* pre = NULL;
        ListNode* cur = head;
        while(cur != NULL){
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }

        return pre;
    }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/course-schedule/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> g(numCourses);
        vector<int> inDegree(numCourses, 0);
        for(const vector<int>& p: prerequisites){
            int from = p[1];
            int to = p[0];
            g[from].push_back(to);
            inDegree[to]++;
        }
        queue<int> q;

        for(int i = 0; i < inDegree.size(); i++){
            if(inDegree[i] == 0){
                q.push(i);
            }
        }
        while(!q.empty()){
            int temp = q.front();
            q.pop();
            for(auto j : g[temp]){
                inDegree[j]--;
                if(inDegree[j] == 0){
                    q.push(j);
                }
            }
        }
        for(int i = 0; i < inDegree.size(); i++){
            if(inDegree[i] != 0){
                return false;
            }
        }
        return true;
    }

};

int main() {

    return 0;
}


#include <iostream>
#include <vector>

using namespace std;

class Solution {

public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

        vector<vector<int>> g(numCourses);
        for(const vector<int>& p: prerequisites){
            int from = p[1];
            int to = p[0];
            g[from].push_back(to);
        }

        return !hasCircle(g);
    }

private:
    bool hasCircle(const vector<vector<int>>& g){

        vector<bool> visited(g.size(), false);
        vector<bool> onPath(g.size(), false);
        for(int i = 0; i < g.size(); i ++)
            if(!visited[i])
                if(circleDFS(g, i, visited, onPath))
                    return true;
        return false;
    }

    bool circleDFS(const vector<vector<int>>& g, int v,
                   vector<bool>& visited, vector<bool>& onPath){

        visited[v] = true;
        onPath[v] = true;
        for(int next: g[v])
            if(!visited[next]){
                if(circleDFS(g, next, visited, onPath))
                    return true;
            }
            else if(onPath[next])
                return true;

        onPath[v] = false;
        return false;
    }
};


int main() {

    return 0;
}

// Source : https://leetcode.com/problems/implement-trie-prefix-tree/description/

#include <iostream>
#include <vector>
#include <map>

using namespace std;

class Trie{

private:
    struct Node{
        map<char, int> next;
        bool end = false;
    };
    vector<Node> trie;

public:
    Trie(){
        trie.clear();
        trie.push_back(Node());
    }

    /** Inserts a word into the trie. */
    void insert(const string& word){
        insert(0, word, 0);
    }

    /** Returns if the word is in the trie. */
    bool search(const string& word){
        return search(0, word, 0);
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(const string& prefix) {
        return startsWith(0, prefix, 0);
    }

private:
    void insert(int treeID, const string& word, int index){

        if(index == word.size()) {
            trie[treeID].end = true;
            return;
        }

        if(trie[treeID].next.find(word[index]) == trie[treeID].next.end()){
            trie[treeID].next[word[index]] = trie.size();
            trie.push_back(Node());
        }

        insert(trie[treeID].next[word[index]], word, index + 1);
    }

    bool search(int treeID, const string& word, int index){

        if(index == word.size())
            return trie[treeID].end;

        if(trie[treeID].next.find(word[index]) == trie[treeID].next.end())
            return false;

        return search(trie[treeID].next[word[index]], word, index + 1);
    }

    bool startsWith(int treeID, const string& prefix, int index){

        if(index == prefix.size())
            return true;

        if(trie[treeID].next.find(prefix[index]) == trie[treeID].next.end())
            return false;

        return startsWith(trie[treeID].next[prefix[index]], prefix, index + 1);
    }
};


void printBool(bool res){
    cout << (res ? "True" : "False") << endl;
}

int main() {

    Trie trie1;
    trie1.insert("ab");
    printBool(trie1.search("a"));     // false
    printBool(trie1.startsWith("a")); // true;

    cout << endl;

    // ---

    Trie trie2;
    trie2.insert("a");
    printBool(trie2.search("a"));     // true
    printBool(trie2.startsWith("a")); // true;

    return 0;
}

// https://leetcode.com/problems/minimum-size-subarray-sum/description/

#include <iostream>
#include <cassert>
#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {

        assert(s > 0);

        vector<int> sums(nums.size() + 1, 0);
        for(int i = 1 ; i <= nums.size() ; i ++)
            sums[i] = sums[i-1] + nums[i-1];

        int res = nums.size() + 1;
        for(int l = 0; l < (int)nums.size(); l ++){
            auto r_bound = lower_bound(sums.begin(), sums.end(), sums[l] + s);
            if(r_bound != sums.end()){
                int r = r_bound - sums.begin();
                res = min(res, r - l);
            }
        }

        return res == nums.size() + 1 ? 0 : res;
    }
};

int main() {

    vector<int> nums1 = {2, 3, 1, 2, 4, 3};
    int s1 = 7;
    cout << Solution().minSubArrayLen(s1, nums1) << endl;
    // 2

    // ---

    vector<int> nums2 = {};
    int s2 = 100;
    cout << Solution().minSubArrayLen(s2, nums2) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/course-schedule-ii/

#include <iostream>
#include <vector>
#include <queue>

using namespace std;

class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {

        vector<int> pre(numCourses, 0);
        vector<vector<int>> g(numCourses);
        for(const vector<int>& p: prerequisites){
            int from = p[1];
            int to = p[0];
            g[from].push_back(to);
            pre[to] ++;
        }

        queue<int> q;
        for(int i = 0; i < numCourses; i ++)
            if(pre[i] == 0)
                q.push(i);

        vector<int> res;
        while(!q.empty()){
            int id = q.front();
            q.pop();

            res.push_back(id);
            for(int next: g[id]){
                pre[next] --;
                if(pre[next] == 0)
                q.push(next);
            }
        }

        if(res.size() == numCourses)
            return res;
        return {};
    }
};


void print_vec(const vector<int>& vec){
    for(int e: vec)
        cout << e << " ";
    cout << endl;
}

int main() {

    vector<pair<int, int>> pre1 = {{1,0}};
    print_vec(Solution().findOrder(2, pre1));
    // 0 1

    vector<pair<int, int>> pre2 = {{1,0},{2,0},{3,1},{3,2}};
    print_vec(Solution().findOrder(4, pre2));
    // 0 1 2 3

    return 0;
}

// Source : https://leetcode.com/problems/add-and-search-word-data-structure-design/description/

#include <iostream>
#include <map>
#include <vector>

using namespace std;

class WordDictionary {

private:
    struct Node {
        map<char, int> next;
        bool end = false;
    };
    vector<Node> trie;

public:
    /** Initialize your data structure here. */
    WordDictionary() {
        trie.clear();
        trie.push_back(Node());
    }

    /** Adds a word into the data structure. */
    void addWord(string word) {
        int treeID = 0;
        for(char c: word){
            if(trie[treeID].next.find(c) == trie[treeID].next.end()){
                trie[treeID].next[c] = trie.size();
                trie.push_back(Node());
            }

            treeID = trie[treeID].next[c];
        }

        trie[treeID].end = true;
    }

    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */
    bool search(string word) {
        return search(0, word, 0);
    }

private:
    bool search(int treeID, const string &word, int index) {

        if (index == word.size())
            return trie[treeID].end;

        if(word[index] != '.'){
            if (trie[treeID].next.find(word[index]) == trie[treeID].next.end())
                return false;

            return search(trie[treeID].next[word[index]], word, index + 1);
        }
        else{
            for(pair<char, int> next: trie[treeID].next)
                if(search(next.second, word, index + 1))
                    return true;
            return false;
        }
    }
};


void printBool(bool res){
    cout << (res ? "True" : "False") << endl;
}

int main() {

    WordDictionary obj;
    obj.addWord("bad");
    obj.addWord("mad");
    obj.addWord("dad");
    printBool(obj.search("pad")); // false
    printBool(obj.search("bad")); // true
    printBool(obj.search(".ad")); // true
    printBool(obj.search("b..")); // true

    return 0;
}

// Source : https://leetcode.com/problems/word-search-ii/

#include <iostream>
#include <vector>

using namespace std;

class Trie {
 public:
  void insert(string word) {
    Trie* t = this;
    for (auto& x : word) {
      if (!t->next[x - 'a']) {
        t->next[x - 'a'] = new Trie;
      }
      t = t->next[x - 'a'];
    }
    t->word = word;
  }

 public:
  vector<Trie*> next{vector<Trie*>(26)};
  string word;
};

class Solution {
 public:
  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
    vector<string> res;
    if (empty(board) || empty(board[0])) {
      return res;
    }
    Trie* trie = new Trie;
    for (auto& x : words) trie->insert(x);
    for (int i = 0; i < size(board); ++i) {
      for (int j = 0; j < size(board[0]); ++j) {
        dfs(board, i, j, trie, res);
      }
    }
    return res;
  }

  void dfs(vector<vector<char>>& board, int i, int j, Trie* trie,
           vector<string>& res) {
    if (board[i][j] != '#' && trie->next[board[i][j] - 'a']) {
      trie = trie->next[board[i][j] - 'a'];
      if (!empty(trie->word)) {
        res.emplace_back(trie->word);
        trie->word.clear();
      }
      char t = board[i][j];
      board[i][j] = '#';
      if (i > 0) {
        dfs(board, i - 1, j, trie, res);
      }
      if (i + 1 < size(board)) {
        dfs(board, i + 1, j, trie, res);
      }
      if (j > 0) {
        dfs(board, i, j - 1, trie, res);
      }
      if (j + 1 < size(board[0])) {
        dfs(board, i, j + 1, trie, res);
      }
      board[i][j] = t;
    }
  }
};

int main() {

    return 0;
}

// Source : https://leetcode.com/problems/house-robber-ii/description/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
 public:
  int rob(vector<int>& nums) {
    if (empty(nums)) {
      return 0;
    }
    int sz = size(nums);
    if (sz == 1) {
      return nums[0];
    }
    if (sz == 2) {
      return max(nums[0], nums[1]);
    }
    vector<int> dp_no_first(sz);
    vector<int> dp_no_last(sz - 1);
    dp_no_first[1] = nums[1];
    dp_no_first[2] = max(nums[1], nums[2]);
    dp_no_last[0] = nums[0];
    dp_no_last[1] = max(nums[0], nums[1]);
    for (int i = 3; i < size(dp_no_first); ++i) {
      dp_no_first[i] = max(dp_no_first[i - 1], dp_no_first[i - 2] + nums[i]);
    }
    for (int i = 2; i < size(dp_no_last); ++i) {
      dp_no_last[i] = max(dp_no_last[i - 1], dp_no_last[i - 2] + nums[i]);
    }
    return max(dp_no_first.back(), dp_no_last.back());
  }
};

int main() {

    vector<int> nums = {2, 7, 9, 3, 1};
    cout << Solution().rob(nums) << endl;

    return 0;
}

// Source : https://leetcode.com/problems/kth-largest-element-in-an-array/

#include <iostream>
#include <vector>
#include <cassert>
#include <stdexcept>
#include <ctime>

using namespace std;

class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {

        sort(nums.begin(), nums.end(), [](int a, int b){return a > b;});
        return nums[k - 1];
    }
};


int main() {

    vector<int> nums1 = {3, 2, 1, 5, 6, 4};
    cout << Solution().findKthLargest(nums1, 2) << endl;
    // 5

    vector<int> nums2 = {3, 1, 2, 4};
    cout << Solution().findKthLargest(nums2, 2) << endl;
    // 3

    vector<int> nums3 = {3, 3, 3, 3, 3, 3, 3, 3, 3};
    cout << Solution().findKthLargest(nums3, 8) << endl;
    // 3

    return 0;
}

