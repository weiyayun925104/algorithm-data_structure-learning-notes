// Source https://leetcode.com/problems/number-of-orders-in-the-backlog/

You are given a 2D integer array orders, where each orders[i] = [pricei, amounti, orderTypei] denotes that amounti orders have been placed of type orderTypei at the price pricei. 
The orderTypei is:

0 if it is a batch of buy orders, or
1 if it is a batch of sell orders.
Note that orders[i] represents a batch of amounti independent orders with the same price and order type. 
All orders represented by orders[i] will be placed before all orders represented by orders[i+1] for all valid i.

There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:

If the order is a buy order, you look at the sell order with the smallest price in the backlog. 
If that sell order's price is smaller than or equal to the current buy order's price, they will match and be executed, 
and that sell order will be removed from the backlog. Else, the buy order is added to the backlog.
Vice versa, if the order is a sell order, you look at the buy order with the largest price in the backlog. 
If that buy order's price is larger than or equal to the current sell order's price, they will match and be executed, 
and that buy order will be removed from the backlog. Else, the sell order is added to the backlog.
Return the total amount of orders in the backlog after placing all the orders from the input. Since this number can be large, return it modulo 109 + 7.

 

Example 1:


Input: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]
Output: 6
Explanation: Here is what happens with the orders:
- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.
- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.
- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.
- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. 
The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, 
so the 4th order is added to the backlog.
Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.
Example 2:


Input: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]
Output: 999999984
Explanation: Here is what happens with the orders:
- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.
- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.
- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.
- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.
Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).
 

Constraints:

1 <= orders.length <= 105
orders[i].length == 3
1 <= pricei, amounti <= 109
orderTypei is either 0 or 1.

class Solution
{
public:
    const int mod = 1e9 + 7;

    int getNumberOfBacklogOrders(vector<vector<int>> &orders)
    {
        priority_queue<pair<int, int>> buy; // max-heap
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sell; // min-heap

        for (auto &order : orders)
        {
            auto price = order[0], amount = order[1], type = order[2];
            if (type == 0)
            {
                while (amount > 0 && !sell.empty() && price >= sell.top().first)
                {
                    auto [sp, sq] = sell.top();
                    sell.pop();
                    if (amount < sq)
                    {
                        sq -= amount;
                        sell.push({sp, sq});
                        amount = 0;
                    }
                    else amount -= sq; 
                }
                if (amount > 0)
                {
                    buy.push({price, amount});
                }
            }
            else
            {
                while (amount > 0 && !buy.empty() && buy.top().first >= price)
                {
                    auto [bp, bq] = buy.top();
                    buy.pop();
                    if (amount < bq)
                    {
                        bq -= amount;
                        buy.push({bp, bq});
                        amount = 0;
                    }
                    else amount -= bq;
                }
                if (amount > 0)
                {
                    sell.push({price, amount});
                }
            }
        }

        int ans = 0;
        while (!buy.empty())
        {
            ans = (ans + buy.top().second) % mod;
            buy.pop();
        }
        while (!sell.empty())
        {
            ans = (ans + sell.top().second) % mod;
            sell.pop();
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/

You are given three positive integers: n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:

nums.length == n
nums[i] is a positive integer where 0 <= i < n.
abs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.
The sum of all the elements of nums does not exceed maxSum.
nums[index] is maximized.
Return nums[index] of the constructed array.

Note that abs(x) equals x if x >= 0, and -x otherwise.

 

Example 1:

Input: n = 4, index = 2,  maxSum = 6
Output: 2
Explanation: nums = [1,2,2,1] is one array that satisfies all the conditions.
There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].
Example 2:

Input: n = 6, index = 1,  maxSum = 10
Output: 3
 

Constraints:

1 <= n <= maxSum <= 109
0 <= index < n

nums[index] 尽可能大，index左右两边尽可能小，因此，从index向左、向右为等差数列

			nums[index] = mid
mid - itemLeft ... mid - 1			     mid-1 ... mid-itemRight
sumLeft = (mid-1)*mid / 2 - (mid - itemLeft - 1) * (mid - itemLeft) / 2 
sumRight = (mid-1)*mid / 2 - (mid - itemRight - 1) * (mid - itemRight) / 2

				nums[index] = mid
itemLeft - (mid -1)个1, 1 ... mid - 1			     mid-1 ... 1, itemRight - (mid -1)个1

class Solution
{
public:
    int maxValue(int n, int index, int maxSum)
    {
        long itemLeft = index;
        long itemRight = n - index - 1;
        long top = maxSum;
        long bottom = 1;
        long mid;
        long sumLeft = 0, sumRight = 0;
        long ans = 0;
        while (bottom <= top)
        {
            mid = bottom + (top - bottom) / 2;
            if (mid > itemLeft && itemLeft > 0)
                sumLeft = ((mid - 1) * (mid) / 2) - ((mid - 1 - itemLeft) * (mid - itemLeft) / 2);
            else if (mid <= itemLeft && itemLeft > 0)
                sumLeft = ((mid - 1) * (mid) / 2) + 1 * (itemLeft - (mid - 1));
            if (mid > itemRight && itemRight > 0)
                sumRight = ((mid - 1) * (mid) / 2) - ((mid - 1 - itemRight) * (mid - itemRight) / 2);
            else if (mid <= itemRight && itemRight > 0)
                sumRight = ((mid - 1) * (mid) / 2) + 1 * (itemRight - (mid - 1));
            long totalSum = sumRight + sumLeft + mid;
            if (totalSum == maxSum)
                return mid;
            else if (totalSum < maxSum)
            {
                ans = mid;
                bottom = mid + 1;
            }
            else
                top = mid - 1;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/count-pairs-with-xor-in-a-range/

Given a (0-indexed) integer array nums and two integers low and high, return the number of nice pairs.

A nice pair is a pair (i, j) where 0 <= i < j < nums.length and low <= (nums[i] XOR nums[j]) <= high.

 

Example 1:

Input: nums = [1,4,2,7], low = 2, high = 6
Output: 6
Explanation: All nice pairs (i, j) are as follows:
    - (0, 1): nums[0] XOR nums[1] = 5 
    - (0, 2): nums[0] XOR nums[2] = 3
    - (0, 3): nums[0] XOR nums[3] = 6
    - (1, 2): nums[1] XOR nums[2] = 6
    - (1, 3): nums[1] XOR nums[3] = 3
    - (2, 3): nums[2] XOR nums[3] = 5
Example 2:

Input: nums = [9,8,4,2,1], low = 5, high = 14
Output: 8
Explanation: All nice pairs (i, j) are as follows:
​​​​​    - (0, 2): nums[0] XOR nums[2] = 13
    - (0, 3): nums[0] XOR nums[3] = 11
    - (0, 4): nums[0] XOR nums[4] = 8
    - (1, 2): nums[1] XOR nums[2] = 12
    - (1, 3): nums[1] XOR nums[3] = 10
    - (1, 4): nums[1] XOR nums[4] = 9
    - (2, 3): nums[2] XOR nums[3] = 6
    - (2, 4): nums[2] XOR nums[4] = 5
 

Constraints:

1 <= nums.length <= 2 * 104
1 <= nums[i] <= 2 * 104
1 <= low <= high <= 2 * 104

find(x, k) 查找trie中与x异或结果小于k的值的个数
find(x, high + 1) - find(x, low) 查找trie中与x异或结果大于等于low且小于等于high的值的个数
x为nums[j]，找满足low <= (nums[i] XOR x) <= high的值的个数，0 <= i < j < nums.length

struct Node
{
    int count;
    int children[2];
} nodes[1 << 19];

class Solution
{
public:
    int nodes_label;

    void insert(int x)
    {
        Node *curr = &nodes[0];
        for (int b_idx = 15; b_idx >= 0; --b_idx)
        {
            int b = (x >> b_idx) & 1;
            int &next_idx = curr->children[b];
            if (next_idx == 0)
            {
                next_idx = nodes_label;
                nodes[next_idx].children[0] = nodes[next_idx].children[1] = 0;
                nodes[next_idx].count = 0;
                ++nodes_label;
            }
            curr = &nodes[next_idx];
            curr->count++;
        }
    }

    int find(int x, int k)
    {
        if (nodes_label == 1)
            return 0;
        int ans = 0;
        Node *curr = &nodes[0];
        for (int b_idx = 15; b_idx >= 0; --b_idx)
        {
            int xdig = (x >> b_idx) & 1;
            int kdig = (k >> b_idx) & 1;
            int index1 = curr->children[1];
            int index0 = curr->children[0];
            if(kdig)
            {
                if(xdig)
                {
                    if(index1 != 0)
                        ans = ans + nodes[index1].count;

                    if(index0 != 0)
                        curr = &nodes[index0];
                    else return ans;
                }
                else
                {
                    if(index0 != 0)
                        ans = ans + nodes[index0].count;

                    if(index1 != 0)
                        curr = &nodes[index1];
                    else return ans;
                }
            }
            else
            {
                if(xdig == 0 && index0 != 0)
                    curr = &nodes[index0];
                else if(xdig && index1 != 0)
                    curr = &nodes[index1];
                else return ans;
            }
        }
        return ans;
    }

    int countPairs(vector<int> &nums, int low, int high)
    {
        nodes[0].children[0] = nodes[0].children[1] = 0;
        nodes[0].count = 0;
        nodes_label = 1;
        int ans = 0;
        for(auto x : nums)
        {
            ans += (find(x, high + 1) - find(x, low));
            insert(x);
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-different-integers-in-a-string/

You are given a string word that consists of digits and lowercase English letters.

You will replace every non-digit character with a space. For example, "a123bc34d8ef34" will become " 123  34 8  34". 
Notice that you are left with some integers that are separated by at least one space: "123", "34", "8", and "34".

Return the number of different integers after performing the replacement operations on word.

Two integers are considered different if their decimal representations without any leading zeros are different.

 

Example 1:

Input: word = "a123bc34d8ef34"
Output: 3
Explanation: The three different integers are "123", "34", and "8". Notice that "34" is only counted once.
Example 2:

Input: word = "leet1234code234"
Output: 2
Example 3:

Input: word = "a1b01c001"
Output: 1
Explanation: The three integers "1", "01", and "001" all represent the same integer because
the leading zeros are ignored when comparing their decimal values.
 

Constraints:

1 <= word.length <= 1000
word consists of digits and lowercase English letters.

class Solution
{
public:
    int numDifferentIntegers(string str)
    {
        int n = str.length();
        unordered_map<string, int>mp;
        for(int i = 0; i < n; i++)
        {
            if(str[i] >= '0' && str[i] <= '9')
            {
                int j = i;
                string s = "";
                while(str[j] >= '0' && str[j] <= '9' && j < n)
                {
                    s += str[j];
                    j++;
                }
                int k = 0;
                while(s[k] == '0' && k < s.length())
                {
                    k++;
                }
                mp[s.substr(k)]++;
                i = j;
            }
        }
        return mp.size();
    }
};


// Source https://leetcode.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/

You are given an even integer n​​​​​​. You initially have a permutation perm of size n​​ where perm[i] == i​ (0-indexed)​​​​.

In one operation, you will create a new array arr, and for each i:

If i % 2 == 0, then arr[i] = perm[i / 2].
If i % 2 == 1, then arr[i] = perm[n / 2 + (i - 1) / 2].
You will then assign arr​​​​ to perm.

Return the minimum non-zero number of operations you need to perform on perm to return the permutation to its initial value.

 

Example 1:

Input: n = 2
Output: 1
Explanation: perm = [0,1] initially.
After the 1st operation, perm = [0,1]
So it takes only 1 operation.
Example 2:

Input: n = 4
Output: 2
Explanation: perm = [0,1,2,3] initially.
After the 1st operation, perm = [0,2,1,3]
After the 2nd operation, perm = [0,1,2,3]
So it takes only 2 operations.
Example 3:

Input: n = 6
Output: 4

[0, 1, 2, 3, 4, 5]
[0, 3, 1, 4, 2, 5]
[0, 4, 3, 2, 1, 5]
[0, 2, 4, 1, 3, 5]
[0, 1, 2, 3, 4, 5]

Constraints:

2 <= n <= 1000
n​​​​​​ is even.

// Only need to focus on one element, 1 for example.
// And what we should do is to think about how many times needed for it to go back to the starting point.

class Solution
{
public:
    int reinitializePermutation(int n)
    {
        int count = 0;
        int pos = 1;
        do
        {
            if(pos & 1)
                pos = n / 2 + (pos - 1) / 2;
            else
                pos = pos / 2;
            count++;
        }
        while(pos != 1);
        return count;
    }
};


// Source https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/

You are given a string s that contains some bracket pairs, with each pair containing a non-empty key.

For example, in the string "(name)is(age)yearsold", there are two bracket pairs that contain the keys "name" and "age".
You know the values of a wide range of keys. This is represented by a 2D string array knowledge where each knowledge[i] = [keyi, valuei] indicates that key keyi has a value of valuei.

You are tasked to evaluate all of the bracket pairs. When you evaluate a bracket pair that contains some key keyi, you will:

Replace keyi and the bracket pair with the key's corresponding valuei.
If you do not know the value of the key, you will replace keyi and the bracket pair with a question mark "?" (without the quotation marks).
Each key will appear at most once in your knowledge. There will not be any nested brackets in s.

Return the resulting string after evaluating all of the bracket pairs.

 

Example 1:

Input: s = "(name)is(age)yearsold", knowledge = [["name","bob"],["age","two"]]
Output: "bobistwoyearsold"
Explanation:
The key "name" has a value of "bob", so replace "(name)" with "bob".
The key "age" has a value of "two", so replace "(age)" with "two".
Example 2:

Input: s = "hi(name)", knowledge = [["a","b"]]
Output: "hi?"
Explanation: As you do not know the value of the key "name", replace "(name)" with "?".
Example 3:

Input: s = "(a)(a)(a)aaa", knowledge = [["a","yes"]]
Output: "yesyesyesaaa"
Explanation: The same key can appear multiple times.
The key "a" has a value of "yes", so replace all occurrences of "(a)" with "yes".
Notice that the "a"s not in a bracket pair are not evaluated.
 

Constraints:

1 <= s.length <= 105
0 <= knowledge.length <= 105
knowledge[i].length == 2
1 <= keyi.length, valuei.length <= 10
s consists of lowercase English letters and round brackets '(' and ')'.
Every open bracket '(' in s will have a corresponding close bracket ')'.
The key in each bracket pair of s will be non-empty.
There will not be any nested bracket pairs in s.
keyi and valuei consist of lowercase English letters.
Each keyi in knowledge is unique.

class Solution
{
public:
    string evaluate(string s, vector<vector<string>> &knowledge)
    {
        unordered_map<string, string> mp;
        for(int i = 0; i < knowledge.size(); i++)
        {
            mp[knowledge[i][0]] = knowledge[i][1];
        }
        int n = s.size();
        string ans = "";
        for(int i = 0; i < n; i++)
        {
            if(s[i] != '(')
                ans += s[i];
            else
            {
                int j = i + 1;
                string check = "";
                while(j < n && s[j] != ')')
                {
                    check += s[j];
                    j++;
                }
                if(mp.find(check) != mp.end())
                    ans += mp[check];
                else
                    ans += '?';
                i = j;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximize-number-of-nice-divisors/

You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:

The number of prime factors of n (not necessarily distinct) is at most primeFactors.
The number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. 
For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.
Return the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.

Note that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. 
The prime factors of a number n is a list of prime numbers such that their product equals n.

 

Example 1:

Input: primeFactors = 5
Output: 6
Explanation: 200 is a valid value of n.
It has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].
There is not other value of n that has at most 5 prime factors and more nice divisors.
Example 2:

Input: primeFactors = 8
Output: 18
 

Constraints:

1 <= primeFactors <= 109

为使The number of nice divisors of n最大化，应尽可能按照 3 个为一组选取质因数，即对所给的 primeFactors 按 3 进行拆分。
只有当 primeFactors % 3 == 1 时，将其中一组 3 个质因数和剩余 1 个一起考虑，选取 4 个或 2 组 2 个质因数。

class Solution
{
public:
    const int mod = 1e9 + 7;

    unsigned long long int power(int b, int x)
    {
        if(x == 0) return 1;
        auto temp = power(b, x / 2);
        auto res = ((unsigned long long int)temp * temp) % mod;
        if(x % 2)
        {
            res = (res * b) % mod;
        }
        return res;
    }

    int maxNiceDivisors(int primeFactors)
    {
        if(primeFactors <= 4)
        {
            return primeFactors;
        }
        if(primeFactors % 3 == 0)
        {
            return power(3, primeFactors / 3);
        }
        else if(primeFactors % 3 == 1)
        {
            return (power(3, (primeFactors / 3) - 1) * 4) % mod;
        }
        else
        {
            return (power(3, primeFactors / 3) * 2) % mod;
        }
    }
};


// Source https://leetcode.com/problems/determine-color-of-a-chessboard-square/

You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.



Return true if the square is white, and false if the square is black.

The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.

 

Example 1:

Input: coordinates = "a1"
Output: false
Explanation: From the chessboard above, the square with coordinates "a1" is black, so return false.
Example 2:

Input: coordinates = "h3"
Output: true
Explanation: From the chessboard above, the square with coordinates "h3" is white, so return true.
Example 3:

Input: coordinates = "c7"
Output: false
 

Constraints:

coordinates.length == 2
'a' <= coordinates[0] <= 'h'
'1' <= coordinates[1] <= '8'

class Solution
{
public:
    bool squareIsWhite(string coordinates)
    {
        int idx1 = coordinates[0] - 'a';
        int idx2 = coordinates[1] - '1';
        if (idx1 % 2 == 0)
        {
            if (idx2 % 2) return true;
            else return false;
        }
        else
        {
            if (idx2 % 2) return false;
            else return true;
        }
    }
};


// Source https://leetcode.com/problems/sentence-similarity-iii/

A sentence is a list of words that are separated by a single space with no leading or trailing spaces. 
For example, "Hello World", "HELLO", "hello world hello world" are all sentences. Words consist of only uppercase and lowercase English letters.

Two sentences sentence1 and sentence2 are similar if it is possible to insert an arbitrary sentence (possibly empty) inside one of these sentences such that the two sentences become equal. 
For example, sentence1 = "Hello my name is Jane" and sentence2 = "Hello Jane" can be made equal by inserting "my name is" between "Hello" and "Jane" in sentence2.

Given two sentences sentence1 and sentence2, return true if sentence1 and sentence2 are similar. Otherwise, return false.

 

Example 1:

Input: sentence1 = "My name is Haley", sentence2 = "My Haley"
Output: true
Explanation: sentence2 can be turned to sentence1 by inserting "name is" between "My" and "Haley".
Example 2:

Input: sentence1 = "of", sentence2 = "A lot of words"
Output: false
Explanation: No single sentence can be inserted inside one of the sentences to make it equal to the other.
Example 3:

Input: sentence1 = "Eating right now", sentence2 = "Eating"
Output: true
Explanation: sentence2 can be turned to sentence1 by inserting "right now" at the end of the sentence.
 

Constraints:

1 <= sentence1.length, sentence2.length <= 100
sentence1 and sentence2 consist of lowercase and uppercase English letters and spaces.
The words in sentence1 and sentence2 are separated by a single space.

class Solution
{
public:
    bool areSentencesSimilar(string s1, string s2)
    {
        deque<string> d, q;
        stringstream ss1(s1);
        stringstream ss2(s2);
        string t;
        while (ss1 >> t) d.push_back(t);
        while (ss2 >> t) q.push_back(t);
        while(!d.empty() && !q.empty() && d.front() == q.front()) d.pop_front(), q.pop_front();
        while(!d.empty() && !q.empty() && d.back() == q.back()) d.pop_back(), q.pop_back();
        return (d.empty() || q.empty());
    }
};


// Source https://leetcode.com/problems/count-nice-pairs-in-an-array/

You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. 
For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:

0 <= i < j < nums.length
nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.

nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])

Example 1:

Input: nums = [42,11,1,97]
Output: 2
Explanation: The two pairs are:
 - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
 - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.
Example 2:

Input: nums = [13,10,35,24,76]
Output: 4
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 109

class Solution
{
public:
    const int mod = 1e9 + 7;

    int rev(int n)
    {
        int r, sum = 0;
        while(n > 0)
        {
            r = n % 10;
            sum = sum * 10 + r;
            n /= 10;
        }
        return sum;
    }

    int countNicePairs(vector<int> &nums)
    {
        long res = 0;
        unordered_map<int, int> mp;
        for(auto val : nums)
            mp[val - rev(val)]++;
        for(auto p : mp)
        {
            res += (long(p.second - 1) * p.second) / 2;
            res %= mod;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/

There is a donuts shop that bakes donuts in batches of batchSize. They have a rule where they must serve all of the donuts of a batch before serving any donuts of the next batch. 
You are given an integer batchSize and an integer array groups, where groups[i] denotes that there is a group of groups[i] customers that will visit the shop. 
Each customer will get exactly one donut.

When a group visits the shop, all customers of the group must be served before serving any of the following groups. 
A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.

You can freely rearrange the ordering of the groups. Return the maximum possible number of happy groups after rearranging the groups.

 

Example 1:

Input: batchSize = 3, groups = [1,2,3,4,5,6]
Output: 4
Explanation: You can arrange the groups as [6,2,4,5,1,3]. Then the 1st, 2nd, 4th, and 6th groups will be happy.
Example 2:

Input: batchSize = 4, groups = [1,3,2,5,2,2,1,6]
Output: 4
 
1 3
2 2
2 6
5 1

Constraints:

1 <= batchSize <= 9
1 <= groups.length <= 30
1 <= groups[i] <= 109

凑batchSize的整数倍
1个group，batchSize的整数倍
2个group，batchSize的整数倍
3个group，batchSize的整数倍
...

class Solution
{
public:
    int batchSize;
    map<vector<int>, int> dp;

    int recur(vector<int> &freq, int left)
    {
        if (dp.find(freq) != dp.end()) return dp[freq];
        int res = 0;
        bool flag = false;
        for (int i = 1; i < batchSize; ++i)
        {
            if (freq[i])
            {
                --freq[i];
                res = max(res, recur(freq, (left + i) % batchSize));
                ++freq[i];
                flag = true;
            }
        }
        if (left == 0 && flag) res += 1;
        return dp[freq] = res;
    }

    int maxHappyGroups(int batchSize, vector<int> &groups)
    {
        this->batchSize = batchSize;
        vector<int> freq(batchSize, 0);
        int ans = 0;
        for (auto customerCnt : groups)
        {
            customerCnt %= batchSize;
            if (customerCnt == 0) ++ans;
            else if (freq[batchSize - customerCnt])
            {
                ++ans;
                --freq[batchSize - customerCnt];
            }
            else ++freq[customerCnt];
        }
        return ans + recur(freq, 0);
    }
};


// Source https://leetcode.com/problems/truncate-sentence/

A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).

For example, "Hello World", "HELLO", and "hello world hello world" are all sentences.
You are given a sentence s​​​​​​ and an integer k​​​​​​. You want to truncate s​​​​​​ such that it contains only the first k​​​​​​ words. Return s​​​​​​ after truncating it.

 

Example 1:

Input: s = "Hello how are you Contestant", k = 4
Output: "Hello how are you"
Explanation:
The words in s are ["Hello", "how" "are", "you", "Contestant"].
The first 4 words are ["Hello", "how", "are", "you"].
Hence, you should return "Hello how are you".
Example 2:

Input: s = "What is the solution to this problem", k = 4
Output: "What is the solution"
Explanation:
The words in s are ["What", "is" "the", "solution", "to", "this", "problem"].
The first 4 words are ["What", "is", "the", "solution"].
Hence, you should return "What is the solution".
Example 3:

Input: s = "chopper is not a tanuki", k = 5
Output: "chopper is not a tanuki"
 

Constraints:

1 <= s.length <= 500
k is in the range [1, the number of words in s].
s consist of only lowercase and uppercase English letters and spaces.
The words in s are separated by a single space.
There are no leading or trailing spaces.

class Solution
{
public:
    string truncateSentence(string s, int k)
    {
        int n = s.length();
        int count = 0;
        for (int i = 0; i < n; ++i)
        {
            if (s[i] != ' ') continue;
            count++;
            if (count == k) return s.substr(0, i);
        }
        return s;
    }
};


// Source https://leetcode.com/problems/finding-the-users-active-minutes/

You are given the logs for users' actions on LeetCode, and an integer k. The logs are represented by a 2D integer array logs 
where each logs[i] = [IDi, timei] indicates that the user with IDi performed an action at the minute timei.

Multiple users can perform actions simultaneously, and a single user can perform multiple actions in the same minute.

The user active minutes (UAM) for a given user is defined as the number of unique minutes in which the user performed an action on LeetCode. 
A minute can only be counted once, even if multiple actions occur during it.

You are to calculate a 1-indexed array answer of size k such that, for each j (1 <= j <= k), answer[j] is the number of users whose UAM equals j.

Return the array answer as described above.

 

Example 1:

Input: logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5
Output: [0,2,0,0,0]
Explanation:
The user with ID=0 performed actions at minutes 5, 2, and 5 again. Hence, they have a UAM of 2 (minute 5 is only counted once).
The user with ID=1 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.
Since both users have a UAM of 2, answer[2] is 2, and the remaining answer[j] values are 0.
Example 2:

Input: logs = [[1,1],[2,2],[2,3]], k = 4
Output: [1,1,0,0]
Explanation:
The user with ID=1 performed a single action at minute 1. Hence, they have a UAM of 1.
The user with ID=2 performed actions at minutes 2 and 3. Hence, they have a UAM of 2.
There is one user with a UAM of 1 and one with a UAM of 2.
Hence, answer[1] = 1, answer[2] = 1, and the remaining values are 0.
 

Constraints:

1 <= logs.length <= 104
0 <= IDi <= 109
1 <= timei <= 105
k is in the range [The maximum UAM for a user, 105].

class Solution
{
public:
    vector<int> findingUsersActiveMinutes(vector<vector<int>> &logs, int k)
    {
        unordered_map<int, unordered_set<int>> mp;
        for(int i = 0; i < logs.size(); i++)
        {
            mp[logs[i][0]].insert(logs[i][1]);
        }
        vector<int>ans(k, 0);
        for(auto &[id, st] : mp)
        {
            ans[st.size() - 1]++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-absolute-sum-difference/

You are given two positive integer arrays nums1 and nums2, both of length n.

The absolute sum difference of arrays nums1 and nums2 is defined as the sum of |nums1[i] - nums2[i]| for each 0 <= i < n (0-indexed).

You can replace at most one element of nums1 with any other element in nums1 to minimize the absolute sum difference.

Return the minimum absolute sum difference after replacing at most one element in the array nums1. Since the answer may be large, return it modulo 109 + 7.

|x| is defined as:

x if x >= 0, or
-x if x < 0.
 

Example 1:

Input: nums1 = [1,7,5], nums2 = [2,3,5]
Output: 3
Explanation: There are two possible optimal solutions:
- Replace the second element with the first: [1,7,5] => [1,1,5], or
- Replace the second element with the third: [1,7,5] => [1,5,5].
Both will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3.
Example 2:

Input: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]
Output: 0
Explanation: nums1 is equal to nums2 so no replacement is needed. This will result in an 
absolute sum difference of 0.
Example 3:

Input: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]
Output: 20
Explanation: Replace the first element with the second: [1,10,4,4,2,7] => [10,10,4,4,2,7].
This yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20
 

Constraints:

n == nums1.length
n == nums2.length
1 <= n <= 105
1 <= nums1[i], nums2[i] <= 105

class Solution
{
public:
    int minAbsoluteSumDiff(vector<int> &nums1, vector<int> &nums2)
    {
        const int mod = 1e9 + 7;
        int n = nums1.size();
        vector<int> vec1(nums1);
        long long sum = 0;
        for(int i = 0; i < n; i++)
        {
            sum += abs(nums1[i] - nums2[i]);
        }
        long long final = sum;
        sort(nums1.begin(), nums1.end());
        for(int i = 0; i < n; i++)
        {
            int val;
            auto itr = lower_bound(nums1.begin(), nums1.end(), nums2[i]);
            if (itr == nums1.end()) val = nums1.back();
            else if (itr == nums1.begin()) val = *itr;
            else
            {
                auto itr2 = itr;
                --itr2;
                int diff = abs(*itr - nums2[i]);
                int diff2 = abs(*itr2 - nums2[i]);
                if (diff < diff2) val = *itr;
                else val = *itr2;
            }
            if(abs(val - nums2[i]) < abs(vec1[i] - nums2[i]))
            {
                final = min(final, sum - abs(vec1[i] - nums2[i]) + abs(val - nums2[i]));
            }
        }
        return final % mod;
    }
};


// Source https://leetcode.com/problems/number-of-different-subsequences-gcds/

You are given an array nums that consists of positive integers.

The GCD of a sequence of numbers is defined as the greatest integer that divides all the numbers in the sequence evenly.

For example, the GCD of the sequence [4,6,16] is 2.
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.

For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].
Return the number of different GCDs among all non-empty subsequences of nums.

 

Example 1:


Input: nums = [6,10,3]
Output: 5
Explanation: The figure shows all the non-empty subsequences and their GCDs.
The different GCDs are 6, 10, 3, 2, and 1.
Example 2:

Input: nums = [5,15,40,5,6]
Output: 7
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 2 * 105

// We will loop through all the possible gcd options i.e from 1 to max_element_in_array (if max_element in array is x then we can't have gcd greater than x)
// Now we will check each multiples of gcd option (1 to max_element) and update our current_gcd.
// If current_gcd is equal to gcd_option we increase ans by 1.
// for understanding point 2 and 3->
// suppose we have elements 4, 8, 12, 16, 20, 24, 28, 32, 36, . . . . . . . i.e multiples of 4
// gcd of any subsequence will be >=4
// and if we keep on adding more element gcd will decrease or be same. eg

// we have 8, 16 -> gcd=8
// if we add 24 then gcd of 8, 16, 24 = 8
// if we add 36 then gcd of 8, 16, 24, 36 = 4

若数字 i 为某子序列的最大公约数，则该序列中的数字，一定都是 i 的倍数。
因此可枚举可能的数字 i ，在 nums 中寻找这些数字的倍数，若它们的最大公约数为 i，说明 i 是某子序列的最大公约数。

class Solution
{
public:
    int b[200001];

    int countDifferentSubsequenceGCDs(vector<int> &nums)
    {
        int ans = 0;
        int mxVal = INT_MIN;
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
            mxVal = max(mxVal, nums[i]);
            b[nums[i]] = 1;
        }

        for(int i = 1; i <= mxVal; i++)
        {
            int cgcd = 0;   //current gcd
            for(int j = i; j <= mxVal; j += i) //loop for all multiples of i
            {
                if (b[j] == 0) continue;
                cgcd = __gcd(cgcd, j);
                if(cgcd == i)   //check if we can form subsequence with gcd
                {
                    ans++;   //increment ans;
                    break;
                }
            }
        }
        return ans;
    }
};



// Source https://leetcode.com/problems/sign-of-the-product-of-an-array/

There is a function signFunc(x) that returns:

1 if x is positive.
-1 if x is negative.
0 if x is equal to 0.
You are given an integer array nums. Let product be the product of all values in the array nums.

Return signFunc(product).

 

Example 1:

Input: nums = [-1,-2,-3,-4,3,2,1]
Output: 1
Explanation: The product of all values in the array is 144, and signFunc(144) = 1
Example 2:

Input: nums = [1,5,0,2,-3]
Output: 0
Explanation: The product of all values in the array is 0, and signFunc(0) = 0
Example 3:

Input: nums = [-1,1,-1,1,-1]
Output: -1
Explanation: The product of all values in the array is -1, and signFunc(-1) = -1
 

Constraints:

1 <= nums.length <= 1000
-100 <= nums[i] <= 100

class Solution
{
public:
    int arraySign(vector<int> &nums)
    {
        int cnt = 0;
        for (int i = 0; i < nums.size(); ++i)
        {
            if (nums[i] == 0) return 0;
            else if (nums[i] < 0) cnt++;
        }
        if (cnt % 2) return -1;
        return 1;
    }
};


// Source https://leetcode.com/problems/find-the-winner-of-the-circular-game/

There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. 
More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.

The rules of the game are as follows:

Start at the 1st friend.
Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
The last friend you counted leaves the circle and loses the game.
If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
Else, the last friend in the circle wins the game.
Given the number of friends, n, and an integer k, return the winner of the game.

 

Example 1:


Input: n = 5, k = 2
Output: 3
Explanation: Here are the steps of the game:
1) Start at friend 1.
2) Count 2 friends clockwise, which are friends 1 and 2.
3) Friend 2 leaves the circle. Next start is friend 3.
4) Count 2 friends clockwise, which are friends 3 and 4.
5) Friend 4 leaves the circle. Next start is friend 5.
6) Count 2 friends clockwise, which are friends 5 and 1.
7) Friend 1 leaves the circle. Next start is friend 3.
8) Count 2 friends clockwise, which are friends 3 and 5.
9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.
Example 2:

Input: n = 6, k = 5
Output: 1
Explanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.
 

Constraints:

1 <= k <= n <= 500

class Solution
{
public:
    int findTheWinner(int n, int k)
    {
        vector<int> res;
        for(int i = 0; i < n; i++)
        {
            res.push_back(i + 1);
        }
        int i = 0;
        while(res.size() > 1)
        {
            int sz = res.size();
            i = (i + k - 1) % sz;
            res.erase(res.begin() + i);
        }
        return res[0];
    }
};


// Source https://leetcode.com/problems/minimum-sideway-jumps/

There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. 
However, there could be obstacles along the way.

You are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. 
If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.

For example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.
The frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. 
To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane.

For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.
Return the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0.

Note: There will be no obstacles on points 0 and n.

 

Example 1:


Input: obstacles = [0,1,2,3,0]
Output: 2 
Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).
Note that the frog can jump over obstacles only when making side jumps (as shown at point 2).
Example 2:


Input: obstacles = [0,1,1,3,3,0]
Output: 0
Explanation: There are no obstacles on lane 2. No side jumps are required.
Example 3:


Input: obstacles = [0,2,1,0,3,0]
Output: 2
Explanation: The optimal solution is shown by the arrows above. There are 2 side jumps.
 

Constraints:

obstacles.length == n + 1
1 <= n <= 5 * 105
0 <= obstacles[i] <= 3
obstacles[0] == obstacles[n] == 0

class Solution
{
public:
    int n;
    int dp[3][500005];

    int solve(int i, int row, vector<int> &obstacles)
    {
        if(i == n - 1) return 0;
        if(obstacles[i] == row + 1) return 1e9;
        if(dp[row][i] != -1) return dp[row][i];
        int res = 1e9;
        if(obstacles[i + 1] != row + 1)
        {
            res = solve(i + 1, row, obstacles);
        }
        else
        {
            res = min(res, 1 + solve(i, (row + 1) % 3, obstacles));
            res = min(res, 1 + solve(i, (row + 2) % 3, obstacles));
        }
        return dp[row][i] = res;
    }

    int minSideJumps(vector<int> &obstacles)
    {
        n = obstacles.size();
        memset(dp, -1, sizeof(dp));
        return solve(0, 1, obstacles);
    }
};


// Source https://leetcode.com/problems/finding-mk-average/

You are given two integers, m and k, and a stream of integers. You are tasked to implement a data structure that calculates the MKAverage for the stream.

The MKAverage can be calculated using these steps:

If the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.
Remove the smallest k elements and the largest k elements from the container.
Calculate the average value for the rest of the elements rounded down to the nearest integer.
Implement the MKAverage class:

MKAverage(int m, int k) Initializes the MKAverage object with an empty stream and the two integers m and k.
void addElement(int num) Inserts a new element num into the stream.
int calculateMKAverage() Calculates and returns the MKAverage for the current stream rounded down to the nearest integer.
 

Example 1:

Input
["MKAverage", "addElement", "addElement", "calculateMKAverage", "addElement", "calculateMKAverage", "addElement", "addElement", "addElement", "calculateMKAverage"]
[[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]
Output
[null, null, null, -1, null, 3, null, null, null, 5]

Explanation
MKAverage obj = new MKAverage(3, 1); 
obj.addElement(3);        // current elements are [3]
obj.addElement(1);        // current elements are [3,1]
obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist.
obj.addElement(10);       // current elements are [3,1,10]
obj.calculateMKAverage(); // The last 3 elements are [3,1,10].
                          // After removing smallest and largest 1 element the container will be [3].
                          // The average of [3] equals 3/1 = 3, return 3
obj.addElement(5);        // current elements are [3,1,10,5]
obj.addElement(5);        // current elements are [3,1,10,5,5]
obj.addElement(5);        // current elements are [3,1,10,5,5,5]
obj.calculateMKAverage(); // The last 3 elements are [5,5,5].
                          // After removing smallest and largest 1 element the container will be [5].
                          // The average of [5] equals 5/1 = 5, return 5
 

Constraints:

3 <= m <= 105
1 <= k*2 < m
1 <= num <= 105
At most 105 calls will be made to addElement and calculateMKAverage.

class MKAverage
{
public:
    vector<int> items;
    map<int, int> lastM;
    int m, k, s, e;
    long total;

    MKAverage(int m, int k)
    {
        this->m = m;
        this->k = k;
        items.reserve(30000);
        s = 0;
        e = 0;
        total = 0;
    }

    void addElement(int num)
    {
        items.push_back(num);
        lastM[num]++;
        total += num;
        e++;

        if(e - s > m)
        {
            if(--lastM[items[s]] == 0) lastM.erase(items[s]);
            total -= items[s++];
        }
    }

    int calculateMKAverage()
    {
        if(e - s < m) return -1;
        int n = k, minVal = 0, maxVal = 0;
        auto itr = lastM.begin();
        while(n > 0)
        {
            minVal += itr->first * min(itr->second, n);
            n -= min(itr->second, n);
            if(n > 0)
            {
                itr++;
            }
        }

        auto _itr = lastM.rbegin();
        n = k;
        while(n > 0)
        {
            maxVal += _itr->first * min(_itr->second, n);
            n -= min(_itr->second, n);
            if(n > 0)
            {
                _itr++;
            }
        }

        return (total - minVal - maxVal) / (m - 2 * k);
    }
};


// Source https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/

You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.

For example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].
Return the minimum number of operations needed to make nums strictly increasing.

An array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.

 

Example 1:

Input: nums = [1,1,1]
Output: 3
Explanation: You can do the following operations:
1) Increment nums[2], so nums becomes [1,1,2].
2) Increment nums[1], so nums becomes [1,2,2].
3) Increment nums[2], so nums becomes [1,2,3].
Example 2:

Input: nums = [1,5,2,4,1]
Output: 14
Example 3:

Input: nums = [8]
Output: 0
 

Constraints:

1 <= nums.length <= 5000
1 <= nums[i] <= 104

class Solution
{
public:
    int minOperations(vector<int> &nums)
    {
        int n = nums.size();
        int res = 0;
        for (int i = 1; i < n; ++i)
        {
            if (nums[i] > nums[i - 1]) continue;
            res += (nums[i - 1] - nums[i] + 1);
            nums[i] = nums[i - 1] + 1;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/

You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.

You are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.

For each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.

Return an array answer, where answer[j] is the answer to the jth query.

 

Example 1:


Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]
Output: [3,2,2]
Explanation: The points and circles are shown above.
queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.
Example 2:


Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]
Output: [2,3,2,4]
Explanation: The points and circles are shown above.
queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple.
 

Constraints:

1 <= points.length <= 500
points[i].length == 2
0 <= x​​​​​​i, y​​​​​​i <= 500
1 <= queries.length <= 500
queries[j].length == 3
0 <= xj, yj <= 500
1 <= rj <= 500
All coordinates are integers.

class Solution
{
public:
    vector<int> countPoints(vector<vector<int>> &points, vector<vector<int>> &queries)
    {
        int m = points.size();
        int n = queries.size();
        vector<int> vec(n);
        for(int i = 0; i < n; i++)
        {
            int radius = queries[i][2];
            int x = queries[i][0];
            int y = queries[i][1];
            int count = 0;
            for(int j = 0; j < m; j++)
            {
                if( pow((points[j][0] - x), 2) + pow((points[j][1] - y), 2) <= pow(radius, 2))
                {
                    count++;
                }
            }
            vec[i] = count;
        }
        return vec;
    }
};


// Source https://leetcode.com/problems/maximum-xor-for-each-query/

You are given a sorted array nums of n non-negative integers and an integer maximumBit. You want to perform the following query n times:

Find a non-negative integer k < 2^maximumBit such that nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the answer to the ith query.
Remove the last element from the current array nums.
Return an array answer, where answer[i] is the answer to the ith query.

 

Example 1:

Input: nums = [0,1,1,3], maximumBit = 2
Output: [0,3,2,3]
Explanation: The queries are answered as follows:
1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.
2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.
3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.
4th query: nums = [0], k = 3 since 0 XOR 3 = 3.
Example 2:

Input: nums = [2,3,4,7], maximumBit = 3
Output: [5,2,6,5]
Explanation: The queries are answered as follows:
1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.
2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.
3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.
4th query: nums = [2], k = 5 since 2 XOR 5 = 7.
Example 3:

Input: nums = [0,1,2,2,5,7], maximumBit = 3
Output: [4,3,6,4,6,7]
 

Constraints:

nums.length == n
1 <= n <= 105
1 <= maximumBit <= 20
0 <= nums[i] < 2maximumBit
nums​​​ is sorted in ascending order.

class Solution
{
public:
    vector<int> getMaximumXor(vector<int> &nums, int maximumBit)
    {
        int n = nums.size();
        vector<int> prefix(n);
        prefix[0] = nums[0];
        for(int i = 1; i < n; i++)
        {
            prefix[i] = prefix[i - 1]^nums[i];
        }
        int maxNum = (1 << maximumBit) - 1;
        vector<int> ans;
        ans.reserve(n);
        for(int i = n - 1; i >= 0; i--)
        {
            ans.push_back(prefix[i]^maxNum);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-operations-to-make-string-sorted/

You are given a string s (0-indexed)​​​​​​. You are asked to perform the following operation on s​​​​​​ until you get a sorted string:

Find the largest index i such that 1 <= i < s.length and s[i] < s[i - 1].
Find the largest index j such that i <= j < s.length and s[k] < s[i - 1] for all the possible values of k in the range [i, j] inclusive.
Swap the two characters at indices i - 1​​​​ and j​​​​​.
Reverse the suffix starting at index i​​​​​​.
Return the number of operations needed to make the string sorted. Since the answer can be too large, return it modulo 109 + 7.

 

Example 1:

Input: s = "cba"
Output: 5
Explanation: The simulation goes as follows:
cba - > cab - > cab
cab -> bac -> bca
bca -> bac -> bac
bac -> abc -> acb
acb -> abc -> abc
Operation 1: i=2, j=2. Swap s[1] and s[2] to get s="cab", then reverse the suffix starting at 2. Now, s="cab".
Operation 2: i=1, j=2. Swap s[0] and s[2] to get s="bac", then reverse the suffix starting at 1. Now, s="bca".
Operation 3: i=2, j=2. Swap s[1] and s[2] to get s="bac", then reverse the suffix starting at 2. Now, s="bac".
Operation 4: i=1, j=1. Swap s[0] and s[1] to get s="abc", then reverse the suffix starting at 1. Now, s="acb".
Operation 5: i=2, j=2. Swap s[1] and s[2] to get s="abc", then reverse the suffix starting at 2. Now, s="abc".
Example 2:

Input: s = "aabaa"
Output: 2
Explanation: The simulation goes as follows:
Operation 1: i=3, j=4. Swap s[2] and s[4] to get s="aaaab", then reverse the substring starting at 3. Now, s="aaaba".
Operation 2: i=4, j=4. Swap s[3] and s[4] to get s="aaaab", then reverse the substring starting at 4. Now, s="aaaab".
 

Constraints:

1 <= s.length <= 3000
s​​​​​​ consists only of lowercase English letters.

题中每次对字符串 s 执行的操作，是将其变为由当前字母组成的前一字典序的字符串。因此求最少操作次数，等价于求解该字符串在由当前字母组成的所有排列中的字典序；
求比当前字符串 s 小的排列个数，可通过排列组合公式计算得到；
排列组合公式中的阶乘逆元取模，可通过费马小定理，转化为对模数的乘方进行计算；
可通过快速乘方算法，进一步提高对乘方的计算效率。

class Solution
{
public:
    const int mod = 1e9 + 7;

    long long modpow(long long b, long long p)
    {
        long long ans = 1;
        while (p > 0)
        {
            if (p & 1)
                ans = ans * b % mod;
            b = b * b % mod;
            p >>= 1;
        }
        return ans;
    }

    int makeStringSorted(string s)
    {
        long long ans = 0;
        long long freq[26] = {0};
        for (char c : s)
        {
            freq[c - 'a']++;
        }
        vector<long long> fact(s.size() + 1, 1ll);
        for (int i = 1; i <= s.size(); i++)
        {
            fact[i] = (fact[i - 1] * i) % mod;
        }
        int l = s.size();
        for (char c : s)
        {
            l--;
            long long t = 0, rev = 1;
            for (int i = 0; i < 26; i++)
            {
                if (i < c - 'a')
                    t += freq[i];
                rev = (rev * fact[freq[i]]) % mod;
            }
            ans += (t * fact[l] % mod) * modpow(rev, mod - 2);
            ans %= mod;
            freq[c - 'a']--;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/check-if-the-sentence-is-pangram/

A pangram is a sentence where every letter of the English alphabet appears at least once.

Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.

 

Example 1:

Input: sentence = "thequickbrownfoxjumpsoverthelazydog"
Output: true
Explanation: sentence contains at least one of every letter of the English alphabet.
Example 2:

Input: sentence = "leetcode"
Output: false
 

Constraints:

1 <= sentence.length <= 1000
sentence consists of lowercase English letters.

class Solution
{
public:
    bool checkIfPangram(string s)
    {
        int n = s.length();
        if (n < 26) return false;
        vector<int> v(26);
        for (auto ch : s)
        {
            if(v[ch - 'a'] == 0)
                v[ch - 'a']++;
            int sum = accumulate(v.begin(), v.end(), 0);
            if(sum > 25)
            {
                return true;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/maximum-ice-cream-bars/

It is a sweltering summer day, and a boy wants to buy some ice cream bars.

At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. 
The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. 

Return the maximum number of ice cream bars the boy can buy with coins coins.

Note: The boy can buy the ice cream bars in any order.

 

Example 1:

Input: costs = [1,3,2,4,1], coins = 7
Output: 4
Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.
Example 2:

Input: costs = [10,6,8,7,7,8], coins = 5
Output: 0
Explanation: The boy cannot afford any of the ice cream bars.
Example 3:

Input: costs = [1,6,3,1,2,5], coins = 20
Output: 6
Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.
 

Constraints:

costs.length == n
1 <= n <= 105
1 <= costs[i] <= 105
1 <= coins <= 108

class Solution
{
public:
    int maxIceCream(vector<int> &costs, int coins)
    {
        int ans = 0;
        priority_queue<int, vector<int>, greater<int>> pq(costs.begin(), costs.end());
        while(!pq.empty() && pq.top() <= coins)
        {
            ans++;
            coins -= pq.top();
            pq.pop();
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/single-threaded-cpu/

You are given n​​​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that 
the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.

You have a single-threaded CPU that can process at most one task at a time and will act in the following way:

If the CPU is idle and there are no available tasks to process, the CPU remains idle.
If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. 
If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.
Once a task is started, the CPU will process the entire task without stopping.
The CPU can finish a task then start a new one instantly.
Return the order in which the CPU will process the tasks.

 

Example 1:

Input: tasks = [[1,2],[2,4],[3,2],[4,1]]
Output: [0,2,3,1]
Explanation: The events go as follows: 
- At time = 1, task 0 is available to process. Available tasks = {0}.
- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.
- At time = 2, task 1 is available to process. Available tasks = {1}.
- At time = 3, task 2 is available to process. Available tasks = {1, 2}.
- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.
- At time = 4, task 3 is available to process. Available tasks = {1, 3}.
- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.
- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.
- At time = 10, the CPU finishes task 1 and becomes idle.
Example 2:

Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
Output: [4,3,2,0,1]
Explanation: The events go as follows:
- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.
- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.
- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.
- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.
- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.
- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.
- At time = 40, the CPU finishes task 1 and becomes idle.
 

Constraints:

tasks.length == n
1 <= n <= 105
1 <= enqueueTimei, processingTimei <= 109

class Solution
{
public:
    vector<int> getOrder(vector<vector<int>> &tasks)
    {
        int n = tasks.size();
        for ( int i = 0; i < n; i++  )
        {
            tasks[i].push_back(i);
        }
        sort (tasks.begin(), tasks.end(), [](vector<int> &a, vector<int> &b)
        {
            return a[0] < b[0];
        });
        vector<int> ans;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        long long curTime = tasks[0][0];
        pq.push ( { tasks[0][1], tasks[0][2] } );
        int l = 1;
        while (l < n)
        {
            if (tasks[l][0] > curTime) break;
            pq.push ( { tasks[l][1], tasks[l][2] } );
            l++;
        }
        while (!pq.empty())
        {
            ans.push_back ( pq.top().second );
            curTime += pq.top().first;
            pq.pop();
            if (pq.empty() && l < n)
            {
                pq.push( {tasks[l][1], tasks[l][2]} );
                curTime = max(curTime, (long long)tasks[l][0]);
                l++;
            }
            while (l < n)
            {
                if (tasks[l][0] > curTime) break;
                pq.push ( { tasks[l][1], tasks[l][2] } );
                l++;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/find-xor-sum-of-all-pairs-bitwise-and/

The XOR sum of a list is the bitwise XOR of all its elements. If the list only contains one element, then its XOR sum will be equal to this element.

For example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 4 = 4, and the XOR sum of [3] is equal to 3.
You are given two 0-indexed arrays arr1 and arr2 that consist only of non-negative integers.

Consider the list containing the result of arr1[i] AND arr2[j] (bitwise AND) for every (i, j) pair where 0 <= i < arr1.length and 0 <= j < arr2.length.

Return the XOR sum of the aforementioned list.

 

Example 1:

Input: arr1 = [1,2,3], arr2 = [6,5]
Output: 0
Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1].
The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.
Example 2:

Input: arr1 = [12], arr2 = [4]
Output: 4
Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4.
 

Constraints:

1 <= arr1.length, arr2.length <= 105
0 <= arr1[i], arr2[j] <= 109

(a & b) ^ (a & c) = a & (b ^ c)
(0 & 0) ^ (0 & 0) = 0 & (0 ^0) = 0
(0 & 0) ^ (0 & 1) = 0 & (0 ^1) = 0
(0 & 1) ^ (0 & 0) = 0 & (1 ^0) = 0
(0 & 1) ^ (0 & 1) = 0 & (1 ^1) = 0
(1 & 0) ^ (1 & 0) = 1 & (0 ^0) = 0
(1 & 0) ^ (1 & 1) = 1 & (0 ^1) = 1
(1 & 1) ^ (1 & 0) = 1 & (1 ^0) = 1
(1 & 1) ^ (1 & 1) = 1 & (1 ^1) = 0
(arr1[0] & arr2[0]) ^ (arr1[0] & arr2[1]) ^ ... ^ (arr1[0] & arr2[m-1]) = arr1[0] & (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])
(arr1[1] & arr2[0]) ^ (arr1[1] & arr2[1]) ^ ... ^ (arr1[1] & arr2[m-1]) = arr1[1] & (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])
...
(arr1[n-1] & arr2[0]) ^ (arr1[n-1] & arr2[1]) ^ ... ^ (arr1[n-1] & arr2[m-1]) = arr1[n-1] & (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])

x = (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])

(x & arr1[0]) ^ (x & arr1[0]) ^ ... ^ (x & arr1[n-1]) = x & (arr1[0] ^ arr1[1] ^ ... ^ arr1[n-1) = (arr1[0] ^ arr1[1] ^ ... ^ arr1[n-1) & (arr2[0] ^ arr2[1] ^ ... ^ arr2[m-1])

class Solution
{
public:
    int getXORSum(vector<int> &arr1, vector<int> &arr2)
    {
        int n = arr1.size();
        int m = arr2.size();
        long res1 = 0, res2 = 0;
        for(int i = 0; i < n; i++)
        {
            res1 = res1 ^ arr1[i];
        }
        for(int i = 0; i < m; i++)
        {
            res2 = res2 ^ arr2[i];
        }
        return (res1 & res2);
    }
};


// Source https://leetcode.com/problems/sum-of-digits-in-base-k/

Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.

After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.

 

Example 1:

Input: n = 34, k = 6
Output: 9
Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.
Example 2:

Input: n = 10, k = 10
Output: 1
Explanation: n is already in base 10. 1 + 0 = 1.
 

Constraints:

1 <= n <= 100
2 <= k <= 10

class Solution
{
public:
    int sumBase(int n, int k)
    {
        int ans = 0;
        while(n > 0)
        {
            ans += n % k;
            n /= k;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/frequency-of-the-most-frequent-element/

The frequency of an element is the number of times it occurs in an array.

You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.

Return the maximum possible frequency of an element after performing at most k operations.

 

Example 1:

Input: nums = [1,2,4], k = 5
Output: 3
Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.
Example 2:

Input: nums = [1,4,8,13], k = 5
Output: 2
Explanation: There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.
Example 3:

Input: nums = [3,9,6], k = 2
Output: 1
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105
1 <= k <= 105

class Solution
{
public:
    int maxFrequency(vector<int> &nums, int k)
    {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        long sum = 0;
        int ans = 0;
        int i = 0, j = 0;
        while(j < n)
        {
            sum += nums[j];
            while(long(j - i + 1)*nums[j] > sum + k)
            {
                sum -= nums[i];
                ++i;
            }
            ans = max(ans, j - i + 1);
            ++j;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/

A string is considered beautiful if it satisfies the following conditions:

Each of the 5 English vowels ('a', 'e', 'i', 'o', 'u') must appear at least once in it.
The letters must be sorted in alphabetical order (i.e. all 'a's before 'e's, all 'e's before 'i's, etc.).
For example, strings "aeiou" and "aaaaaaeiiiioou" are considered beautiful, but "uaeio", "aeoiu", and "aaaeeeooo" are not beautiful.

Given a string word consisting of English vowels, return the length of the longest beautiful substring of word. If no such substring exists, return 0.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: word = "aeiaaioaaaaeiiiiouuuooaauuaeiu"
Output: 13
Explanation: The longest beautiful substring in word is "aaaaeiiiiouuu" of length 13.
Example 2:

Input: word = "aeeeiiiioooauuuaeiou"
Output: 5
Explanation: The longest beautiful substring in word is "aeiou" of length 5.
Example 3:

Input: word = "a"
Output: 0
Explanation: There is no beautiful substring, so return 0.
 

Constraints:

1 <= word.length <= 5 * 105
word consists of characters 'a', 'e', 'i', 'o', and 'u'.

class Solution
{
public:
    int longestBeautifulSubstring(string word)
    {
        int n = word.length();
        vector<char> vowels{'a', 'e', 'i', 'o', 'u'};
        int result = 0;
        for (int i = 0; i < n; ++i)
        {
            if (word[i] != 'a') continue;
            int runningLength = 1;
            int currPos = 1;
            int j = i + 1;
            for (; j < n; ++j)
            {
                if (currPos < 5 && word[j] == vowels[currPos])
                {
                    currPos++;
                    runningLength++;
                }
                else if(currPos > 0 && word[j] == vowels[currPos - 1])
                {
                    runningLength++;
                }
                else
                {
                    break;
                }
                if(currPos == 5)
                {
                    result = max(result, runningLength);
                }
            }
            i = j - 1;
        }
        return result;
    }
};


// Source https://leetcode.com/problems/maximum-building-height/

You want to build n new buildings in a city. The new buildings will be built in a line and are labeled from 1 to n.

However, there are city restrictions on the heights of the new buildings:

The height of each building must be a non-negative integer.
The height of the first building must be 0.
The height difference between any two adjacent buildings cannot exceed 1.
Additionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array restrictions 
where restrictions[i] = [idi, maxHeighti] indicates that building idi must have a height less than or equal to maxHeighti.

It is guaranteed that each building will appear at most once in restrictions, and building 1 will not be in restrictions.

Return the maximum possible height of the tallest building.

 

Example 1:


Input: n = 5, restrictions = [[2,1],[4,1]]
Output: 2
Explanation: The green area in the image indicates the maximum allowed height for each building.
We can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2.
Example 2:


Input: n = 6, restrictions = []
Output: 5
Explanation: The green area in the image indicates the maximum allowed height for each building.
We can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5.
Example 3:


Input: n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]]
Output: 5
Explanation: The green area in the image indicates the maximum allowed height for each building.
We can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5.
 

Constraints:

2 <= n <= 109
0 <= restrictions.length <= min(n - 1, 105)
2 <= idi <= n
idi is unique.
0 <= maxHeighti <= 109

// considering the following restractions:
// 
// Building #1 max-height = 1, Building #5 max-height = 1
// then we can have the building height list - [1,2,3,2,1]
//
// Building #1 max-height = 1, Building #6 max-height = 1
// then we can have the building height list - [1,2,3,3,2,1]
// 
// Building #1 max-height = 3, Building #5 max-height = 1
// then we can have the building height list - [3,4,3,2,1]
// 
// Building #1 max-height = 3, Building #6 max-height = 1
// then we can have the building height list - [3,4,4,3,2,1]
//
// Building #1 max-height = 1, Building #5 max-height = 9
// then we can have the building height list - [1,2,3,4,5]
// 
// So, we can figure out the following rules :
// 
// if two restraction has same limited height, suppose we have [n ......... n],
// then we can have the building height list [n, n+1, n+2, ... n+m-1, n+m, n+m-1 ..., n+2, n+1, n] or [n, n+1, n+2, ... n+m-1, n+m, n+m, n+m-1 ..., n+2, n+1, n]
// 2 * m + 1 = width
// 2 * m + 2 = width
// So, m = (width - 1) /2 - the width is the number of buildings.
// 
// if two restraction has different limited height, suppose we have [n ...... n+x]
// then we still can have the building height list like 1) - we just add some buildings behind [n ... n+m ... n+x, (n+x-1... n) ]
// 
// So, m = (width+x - 1)/2 - we need to extend x buildings
// m >= x -> (width + x - 1) / 2 >= x -> width -1 >= x
// if there hasn't enough buildings between two restractions. then, the max height we can make is width. For examples:
// 
// Building#1 max-height = 2, building#3 max-height = 5 : then, we only can make [2,3,4]
// Building#1 max-height = 2, building#2 max-height = 9 : then, we only can make [2,3]
// So, we can have the following source code to calculate the max height between two restractions.
// 
//     int getMaxHeight(vector<int>& left, vector<int>& right) {
//         
//         int width = right[0] - left[0];
//         int height_delta = abs(right[1] - left[1]);
//         int min_height = min (left[1], right[1]);
//         
//         //if the `width` is enough to have `height_delta`
//         if (width >= height_delta) return min_height + (width + height_delta) / 2;
//         
//         // if the `width` is not enought have `height_delta`
//         // then, the `width` is the max height we can make
//         int max_height =  min_height + width;
//         
//         return max_height;
//     }
// BUT, we still have a case need to deal with, considering we have the following restractions:
// 
// [1,1], [2,2] ,[3,3], [4,0]
// 
// we can process them couple by couple.
// 
// step 1: [1,1], [2,2] : max-height = 2
// step 2: [2,2] ,[3,3] : max-height = 3
// step 3: [3,3], [4,0] : max-height = 1
// for the last couple of restractions, we can see the building#3 max-height is 1, so we have go backwards to recaluate the building#2 and building#1.
// 
// step 3: [3,1], [4,0] : max-height = 1 (change the [3,3] to [3,1] )
// step:4: [2,2] ,[3,1] : max-height = 2
// step 5: [1,1], [2,2] : max-height = 2
// So, the correct answer of max height is 2

class Solution
{
public:
    int getMaxHeight(pair<int, int> &left, pair<int, int> &right)
    {
        int width = right.first - left.first;
        int height_delta = abs(right.second - left.second);
        int min_height = min(left.second, right.second);

        if (width >= height_delta) return min_height + (width + height_delta) / 2;
        int max_height =  min_height + width;

        left.second = min(left.second, max_height);
        right.second = min(right.second, max_height);

        return max_height;
    }

    int maxBuilding(int n, vector<vector<int>> &restrictions)
    {
        vector<pair<int, int>> vec;
        vec.reserve(restrictions.size() + 2);
        vec.push_back({1, 0});
        int mxVal = 0;
        for (auto &v : restrictions)
        {
            vec.push_back({v[0], v[1]});
            mxVal = max(mxVal, v[0]);
        }
        if (mxVal < n)
        {
            vec.push_back({n, n - 1});
        }
        sort(vec.begin(), vec.end());
        int m = vec.size();
        for(int i = 0; i < m - 1; i++)
        {
            int height = getMaxHeight(vec[i], vec[i + 1]);
        }
        int maxHeight = 0;
        for(int i = m - 1; i > 0; i--)
        {
            int height = getMaxHeight(vec[i - 1], vec[i]);
            maxHeight = max(maxHeight, height);
        }
        return maxHeight;
    }
};


// Source https://leetcode.com/problems/replace-all-digits-with-characters/

You are given a 0-indexed string s that has lowercase English letters in its even indices and digits in its odd indices.

There is a function shift(c, x), where c is a character and x is a digit, that returns the xth character after c.

For example, shift('a', 5) = 'f' and shift('x', 0) = 'x'.
For every odd index i, you want to replace the digit s[i] with shift(s[i-1], s[i]).

Return s after replacing all digits. It is guaranteed that shift(s[i-1], s[i]) will never exceed 'z'.

 

Example 1:

Input: s = "a1c1e1"
Output: "abcdef"
Explanation: The digits are replaced as follows:
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('c',1) = 'd'
- s[5] -> shift('e',1) = 'f'
Example 2:

Input: s = "a1b2c3d4e"
Output: "abbdcfdhe"
Explanation: The digits are replaced as follows:
- s[1] -> shift('a',1) = 'b'
- s[3] -> shift('b',2) = 'd'
- s[5] -> shift('c',3) = 'f'
- s[7] -> shift('d',4) = 'h'
 

Constraints:

1 <= s.length <= 100
s consists only of lowercase English letters and digits.
shift(s[i-1], s[i]) <= 'z' for all odd indices i.

class Solution
{
public:
    string replaceDigits(string s)
    {
        int n = s.length();
        for(int i = 0; i < n; i++)
        {
            if(i % 2) s[i] = (s[i - 1]+ (s[i] - '0'));
        }
        return s;
    }
};


// Source https://leetcode.com/problems/seat-reservation-manager/

Design a system that manages the reservation state of n seats that are numbered from 1 to n.

Implement the SeatManager class:

SeatManager(int n) Initializes a SeatManager object that will manage n seats numbered from 1 to n. All seats are initially available.
int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and returns its number.
void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.
 

Example 1:

Input
["SeatManager", "reserve", "reserve", "unreserve", "reserve", "reserve", "reserve", "reserve", "unreserve"]
[[5], [], [], [2], [], [], [], [], [5]]
Output
[null, 1, 2, null, 2, 3, 4, 5, null]

Explanation
SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.
seatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1.
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5].
seatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.
seatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3.
seatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4.
seatManager.reserve();    // The only available seat is seat 5, so return 5.
seatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].
 

Constraints:

1 <= n <= 105
1 <= seatNumber <= n
For each call to reserve, it is guaranteed that there will be at least one unreserved seat.
For each call to unreserve, it is guaranteed that seatNumber will be reserved.
At most 105 calls in total will be made to reserve and unreserve.

class SeatManager
{
public:
    priority_queue<int, vector<int>, greater<int>> pq;

    SeatManager(int n)
    {
        for(int i = 1; i <= n; i++)
            pq.push(i);
    }

    int reserve()
    {
        int res = pq.top();
        pq.pop();
        return res;
    }

    void unreserve(int seatNumber)
    {
        pq.push(seatNumber);
    }
};


// Source https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging/

You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:

The value of the first element in arr must be 1.
The absolute difference between any 2 adjacent elements must be less than or equal to 1. 
In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
There are 2 types of operations that you can perform any number of times:

Decrease the value of any element of arr to a smaller positive integer.
Rearrange the elements of arr to be in any order.
Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.

 

Example 1:

Input: arr = [2,2,1,2,1]
Output: 2
Explanation: 
We can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].
The largest element in arr is 2.
Example 2:

Input: arr = [100,1,1000]
Output: 3
Explanation: 
One possible way to satisfy the conditions is by doing the following:
1. Rearrange arr so it becomes [1,100,1000].
2. Decrease the value of the second element to 2.
3. Decrease the value of the third element to 3.
Now arr = [1,2,3], which satisfies the conditions.
The largest element in arr is 3.
Example 3:

Input: arr = [1,2,3,4,5]
Output: 5
Explanation: The array already satisfies the conditions, and the largest element is 5.
 

Constraints:

1 <= arr.length <= 105
1 <= arr[i] <= 109

class Solution
{
public:
    int maximumElementAfterDecrementingAndRearranging(vector<int> &arr)
    {
        int n = arr.size();
        sort(arr.begin(), arr.end());
        if(arr[0] != 1) arr[0] = 1;
        for(int i = 1; i < n; i++)
        {
            if(abs(arr[i] - arr[i - 1]) > 1 ) arr[i] = arr[i - 1] + 1;
        }
        return arr[n - 1];
    }
};


// Source https://leetcode.com/problems/closest-room/

There is a hotel with n rooms. The rooms are represented by a 2D integer array rooms where rooms[i] = [roomIdi, sizei] denotes that 
there is a room with room number roomIdi and size equal to sizei. Each roomIdi is guaranteed to be unique.

You are also given k queries in a 2D array queries where queries[j] = [preferredj, minSizej]. The answer to the jth query is the room number id of a room such that:

The room has a size of at least minSizej, and
abs(id - preferredj) is minimized, where abs(x) is the absolute value of x.
If there is a tie in the absolute difference, then use the room with the smallest such id. If there is no such room, the answer is -1.

Return an array answer of length k where answer[j] contains the answer to the jth query.

 

Example 1:

Input: rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]
Output: [3,-1,3]
Explanation: The answers to the queries are as follows:
Query = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3.
Query = [3,3]: There are no rooms with a size of at least 3, so the answer is -1.
Query = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3.
Example 2:

Input: rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]
Output: [2,1,3]
Explanation: The answers to the queries are as follows:
Query = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2.
Query = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller.
Query = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3.
 

Constraints:

n == rooms.length
1 <= n <= 105
k == queries.length
1 <= k <= 104
1 <= roomIdi, preferredj <= 107
1 <= sizei, minSizej <= 107

class Solution
{
public:
    vector<int> closestRoom(vector<vector<int>> &rooms, vector<vector<int>> &queries)
    {
        set<pair<int, int>> room_set;
        vector<pair<int, int>> room_lst(rooms.size());
        vector<array<int, 3>> query_lst(queries.size());
        vector<int> v(queries.size());
        for(int i = 0; i < rooms.size(); i++)
        {
            room_lst[i] = {rooms[i][1], rooms[i][0]};
        }
        for(int i = 0; i < queries.size(); i++)
        {
            query_lst[i] = {queries[i][1], queries[i][0], i};
        }
        sort(room_lst.begin(), room_lst.end(), greater<pair<int, int>>());
        sort(query_lst.begin(), query_lst.end(), greater<array<int, 3>>());
        int loc = 0;
        for(auto &q : query_lst)
        {
            int qsize = q[0];
            int qpref = q[1];
            int qnum = q[2];
            while(loc < room_lst.size() && room_lst[loc].first >= qsize)
            {
                room_set.emplace(room_lst[loc].second, room_lst[loc].first);
                loc++;
            }
            if(room_set.size() == 0)
            {
                v[qnum] = -1;
                continue;
            }
            else if(room_set.size() == 1)
            {
                v[qnum] = room_set.begin()->first;
                continue;
            }
            auto iter = room_set.lower_bound({qpref, 0});
            if(iter == room_set.begin())
            {
                v[qnum] = iter->first;
            }
            else if(iter == room_set.end())
            {
                iter--;
                v[qnum] = iter->first;
            }
            else
            {
                int id1 = iter->first;
                int s1 = iter->second;
                int diff1 = abs(id1 - qpref);
                iter--;
                int id2 = iter->first;
                int s2 = iter->second;
                int diff2 = abs(id2 - qpref);
                if(diff1 < diff2)
                {
                    v[qnum] = id1;
                }
                else if(diff1 > diff2)
                {
                    v[qnum] = id2;
                }
                else
                {
                    v[qnum] = min(id1, id2);
                }
            }
        }
        return v;
    }
};


// Source https://leetcode.com/problems/minimum-distance-to-the-target-element/

Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x.

Return abs(i - start).

It is guaranteed that target exists in nums.

 

Example 1:

Input: nums = [1,2,3,4,5], target = 5, start = 3
Output: 1
Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.
Example 2:

Input: nums = [1], target = 1, start = 0
Output: 0
Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.
Example 3:

Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
Output: 0
Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.
 

Constraints:

1 <= nums.length <= 1000
1 <= nums[i] <= 104
0 <= start < nums.length
target is in nums.

class Solution
{
public:
    int getMinDistance(vector<int> &nums, int target, int start)
    {
        int res = INT_MAX;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] == target)
                res = min(res, abs(i - start));
        }
        return res;
    }
};


// Source https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/

You are given a string s that consists of only digits.

Check if we can split s into two or more non-empty substrings such that the numerical values of the substrings are in descending order 
and the difference between numerical values of every two adjacent substrings is equal to 1.

For example, the string s = "0090089" can be split into ["0090", "089"] with numerical values [90,89]. The values are in descending order and adjacent values differ by 1, so this way is valid.
Another example, the string s = "001" can be split into ["0", "01"], ["00", "1"], or ["0", "0", "1"]. However all the ways are invalid because they have numerical values [0,1], [0,1], and [0,0,1] respectively, all of which are not in descending order.
Return true if it is possible to split s​​​​​​ as described above, or false otherwise.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: s = "1234"
Output: false
Explanation: There is no valid way to split s.
Example 2:

Input: s = "050043"
Output: true
Explanation: s can be split into ["05", "004", "3"] with numerical values [5,4,3].
The values are in descending order with adjacent values differing by 1.
Example 3:

Input: s = "9080701"
Output: false
Explanation: There is no valid way to split s.
 

Constraints:

1 <= s.length <= 20
s only consists of digits.

class Solution
{
public:
    int n;

    bool find(int cnt, int index, long long int prev, string &s)
    {
        if(index >= n && cnt >= 2) return true;
        long long int val = 0;
        for(int i = index; i < n; i++)
        {
            val = val * 10 + (s[i] - '0');
            if(val >= prev) break;
            if((prev - val == 1) && find(cnt + 1, i + 1, val, s))
            {
                return true;
            }
        }
        return false;
    }

    bool splitString(string s)
    {
        n = s.length();
        long long int val = 0;
        for(int i = 0; i < n - 1; i++)
        {
            if (val >= 1e10) break;
            val = val * 10 + (s[i] - '0');
            if(find(1, i + 1, val, s))
            {
                return true;
            }
        }
        return false;
    }
};


// Source https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/

You are given a string num, representing a large integer, and an integer k.

We call some integer wonderful if it is a permutation of the digits in num and is greater in value than num. There can be many wonderful integers. 
However, we only care about the smallest-valued ones.

For example, when num = "5489355142":
The 1st smallest wonderful integer is "5489355214".
The 2nd smallest wonderful integer is "5489355241".
The 3rd smallest wonderful integer is "5489355412".
The 4th smallest wonderful integer is "5489355421".
Return the minimum number of adjacent digit swaps that needs to be applied to num to reach the kth smallest wonderful integer.

The tests are generated in such a way that kth smallest wonderful integer exists.

 

Example 1:

Input: num = "5489355142", k = 4
Output: 2
Explanation: The 4th smallest wonderful number is "5489355421". To get this number:
- Swap index 7 with index 8: "5489355142" -> "5489355412"
- Swap index 8 with index 9: "5489355412" -> "5489355421"
Example 2:

Input: num = "11112", k = 4
Output: 4
Explanation: The 4th smallest wonderful number is "21111". To get this number:
- Swap index 3 with index 4: "11112" -> "11121"
- Swap index 2 with index 3: "11121" -> "11211"
- Swap index 1 with index 2: "11211" -> "12111"
- Swap index 0 with index 1: "12111" -> "21111"
Example 3:

Input: num = "00123", k = 1
Output: 1
Explanation: The 1st smallest wonderful number is "00132". To get this number:
- Swap index 3 with index 4: "00123" -> "00132"
 

Constraints:

2 <= num.length <= 1000
1 <= k <= 1000
num only consists of digits.

class Solution
{
public:
    int getMinSwaps(string num, int k)
    {
        string original = num;
        while(k-- > 0) next_permutation(num.begin(), num.end());
        int n = num.length();
        int res = 0;
        for(int j = 0; j < n; j++)
        {
            if(num[j] != original[j])
            {
                int i = j + 1;
                while(original[i] != num[j]) i++;
                while(num[j] != original[j])
                {
                    swap(original[i], original[i - 1]);
                    ++res;
                    --i;
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-interval-to-include-each-query/

You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). 
The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.

You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.

Return an array containing the answers to the queries.

 

Example 1:

Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
Output: [3,3,1,4]
Explanation: The queries are processed as follows:
- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.
- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.
- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.
- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.
Example 2:

Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
Output: [2,-1,4,6]
Explanation: The queries are processed as follows:
- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.
- Query = 19: None of the intervals contain 19. The answer is -1.
- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.
- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.
 

Constraints:

1 <= intervals.length <= 105
1 <= queries.length <= 105
intervals[i].length == 2
1 <= lefti <= righti <= 107
1 <= queries[j] <= 107

class Solution
{
public:
    vector<int> minInterval(vector<vector<int>> &intervals, vector<int> &queries)
    {
        int n = intervals.size();
        vector<pair<int, int>> vIntervals;
        vIntervals.reserve(n);
        for (auto &v : intervals)
        {
            vIntervals.push_back({v[0], v[1]});
        }
        sort(vIntervals.begin(), vIntervals.end());
        int m = queries.size();
        vector<pair<int, int>> vQuerys;
        vQuerys.reserve(m);
        for (int i = 0; i < m; ++i)
        {
            vQuerys.push_back({queries[i], i});
        }
        sort(vQuerys.begin(), vQuerys.end());
        vector<int> ans(m, -1);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        int k = 0;
        for (auto [val, idx] : vQuerys)
        {
            for (; k < n && vIntervals[k].first <= val; ++k)
                pq.push( {vIntervals[k].second - vIntervals[k].first + 1, vIntervals[k].second} );
            while (!pq.empty() && pq.top().second < val)
                pq.pop();
            if (!pq.empty())
                ans[idx] = pq.top().first;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-population-year/

You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person.

The population of some year x is the number of people alive during that year. The ith person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. 
Note that the person is not counted in the year that they die.

Return the earliest year with the maximum population.

 

Example 1:

Input: logs = [[1993,1999],[2000,2010]]
Output: 1993
Explanation: The maximum population is 1, and 1993 is the earliest year with this population.
Example 2:

Input: logs = [[1950,1961],[1960,1971],[1970,1981]]
Output: 1960
Explanation: 
The maximum population is 2, and it had happened in years 1960 and 1970.
The earlier year between them is 1960.
 

Constraints:

1 <= logs.length <= 100
1950 <= birthi < deathi <= 2050

class Solution
{
public:
    int maximumPopulation(vector<vector<int>> &logs)
    {
        int arr[128] = {0};
        for (auto &v : logs)
        {
            arr[v[0] - 1950]++;
            arr[v[1] - 1950]--;
        }
        int mxVal = INT_MIN;
        int sum = 0;
        int res = 0;
        for (int i = 0; i < 128; ++i)
        {
            sum += arr[i];
            if (sum > mxVal)
            {
                mxVal = sum;
                res = i + 1950;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-distance-between-a-pair-of-values/

You are given two non-increasing 0-indexed integer arrays nums1​​​​​​ and nums2​​​​​​.

A pair of indices (i, j), where 0 <= i < nums1.length and 0 <= j < nums2.length, is valid if both i <= j and nums1[i] <= nums2[j]. The distance of the pair is j - i​​​​.

Return the maximum distance of any valid pair (i, j). If there are no valid pairs, return 0.

An array arr is non-increasing if arr[i-1] >= arr[i] for every 1 <= i < arr.length.

 

Example 1:

Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
Output: 2
Explanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).
The maximum distance is 2 with pair (2,4).
Example 2:

Input: nums1 = [2,2,2], nums2 = [10,10,1]
Output: 1
Explanation: The valid pairs are (0,0), (0,1), and (1,1).
The maximum distance is 1 with pair (0,1).
Example 3:

Input: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
Output: 2
Explanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).
The maximum distance is 2 with pair (2,4).
 

Constraints:

1 <= nums1.length, nums2.length <= 105
1 <= nums1[i], nums2[j] <= 105
Both nums1 and nums2 are non-increasing.

class Solution
{
public:
    int maxDistance(vector<int> &nums1, vector<int> &nums2)
    {
        int n = nums1.size();
        int m = nums2.size();
        int res = 0;
        int i = 0, j = 0;
        while (i < n && j < m)
        {
            if (nums1[i] > nums2[j])
            {
                ++i;
                if (i > j) j = i;
                continue;
            }
            res = max(res, j - i);
            ++j;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-subarray-min-product/

The min-product of an array is equal to the minimum value in the array multiplied by the array's sum.

For example, the array [3,2,5] (minimum value is 2) has a min-product of 2 * (3+2+5) = 2 * 10 = 20.
Given an array of integers nums, return the maximum min-product of any non-empty subarray of nums. Since the answer may be large, return it modulo 109 + 7.

Note that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer.

A subarray is a contiguous part of an array.

 

Example 1:

Input: nums = [1,2,3,2]
Output: 14
Explanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).
2 * (2+3+2) = 2 * 7 = 14.
Example 2:

Input: nums = [2,3,3,1,2]
Output: 18
Explanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).
3 * (3+3) = 3 * 6 = 18.
Example 3:

Input: nums = [3,1,5,6,4,2]
Output: 60
Explanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).
4 * (5+6+4) = 4 * 15 = 60.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 107

class Solution
{
public:
    int maxSumMinProduct(vector<int> &nums)
    {
        int n = nums.size();
        const int mod = 1e9 + 7;
        stack<pair<int, int>> left, right;
        int larr[n], rarr[n];
        long long preSum[n], sum = 0;
        for(int i = 0; i < n; i++)
        {
            int count = 1;
            while(!left.empty() && left.top().first >= nums[i])
            {
                count += left.top().second;
                left.pop();
            }
            larr[i] = count;
            left.push({nums[i], count});
            sum += nums[i];
            preSum[i] = sum;
        }
        for(int i = n - 1; i > -1; i--)
        {
            int count = 1;
            while(!right.empty() && right.top().first >= nums[i])
            {
                count += right.top().second;
                right.pop();
            }
            rarr[i] = count;
            right.push({nums[i], count});
        }
        long res = 0;
        for(int i = 0; i < n; i++)
        {
            long tempSum = (preSum[i + rarr[i] - 1] - (i - larr[i] >= 0 ? preSum[i - larr[i]] : 0));
            res = max(res, (tempSum * nums[i]));
        }
        return res % mod;
    }
};


// Source https://leetcode.com/problems/largest-color-value-in-a-directed-graph/

There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1.

You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). 
You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj.

A valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. 
The color value of the path is the number of nodes that are colored the most frequently occurring color along that path.

Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle.

 

Example 1:



Input: colors = "abaca", edges = [[0,1],[0,2],[2,3],[3,4]]
Output: 3
Explanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored "a" (red in the above image).
Example 2:



Input: colors = "a", edges = [[0,0]]
Output: -1
Explanation: There is a cycle from 0 to 0.
 

Constraints:

n == colors.length
m == edges.length
1 <= n <= 105
0 <= m <= 105
colors consists of lowercase English letters.
0 <= aj, bj < n

class Solution
{
public:
    int largestPathValue(string colors, vector<vector<int>> &edges)
    {
        int n = colors.size();
        vector<int> in1(n, 0);
        vector<int> in2(n, 0);
        vector<int> adj[n];
        for(auto &v : edges)
        {
            adj[v[1]].push_back(v[0]);
            in1[v[0]]++;
        }
        int res = 0;
        vector<int> dp(n, 0);
        int seen[26] = {0};
        for(char c : colors)
        {
            if(seen[c - 'a']) continue;
            seen[c - 'a'] = 1;

            queue<int> q;
            for(int i = 0; i < n; ++i)
            {
                dp[i] = -1;
                in2[i] = in1[i];
                if(in2[i] == 0)
                {
                    dp[i] = (c - 'a' == colors[i] - 'a');
                    q.push(i);
                }
            }

            for(int i = 0; i < n; ++i)
            {
                if(q.empty()) return -1; // 有环存在

                int u = q.front();
                q.pop();
                res = max(res, dp[u]);

                for(int v : adj[u])
                {
                    dp[v] = max(dp[v], (c - 'a' == colors[v] - 'a') + dp[u]);
                    in2[v]--;
                    if(in2[v] == 0)
                    {
                        q.push(v);
                    }
                }
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/sorting-the-sentence/

A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.

A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence.

For example, the sentence "This is a sentence" can be shuffled as "sentence4 a3 is2 This1" or "is2 sentence4 This1 a3".
Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence.

 

Example 1:

Input: s = "is2 sentence4 This1 a3"
Output: "This is a sentence"
Explanation: Sort the words in s to their original positions "This1 is2 a3 sentence4", then remove the numbers.
Example 2:

Input: s = "Myself2 Me1 I4 and3"
Output: "Me Myself and I"
Explanation: Sort the words in s to their original positions "Me1 Myself2 and3 I4", then remove the numbers.
 

Constraints:

2 <= s.length <= 200
s consists of lowercase and uppercase English letters, spaces, and digits from 1 to 9.
The number of words in s is between 1 and 9.
The words in s are separated by a single space.
s contains no leading or trailing spaces.

class Solution
{
public:
    string sortSentence(string s)
    {
        vector<string> vec;
        vec.reserve(10);
        stringstream ss(s);
        string t;
        while (ss >> t) vec.emplace_back(std::move(t));
        string arr[10];
        for (auto &str : vec)
        {
            auto ch = str.back();
            str.pop_back();
            arr[ch - '0'] = str;
        }
        string ans = "";
        for(auto &str : arr)
        {
            if (str.length() == 0) continue;
            ans += str;
            ans += " ";
        }
        ans.pop_back();
        return ans;
    }
};


// Source https://leetcode.com/problems/incremental-memory-leak/

You are given two integers memory1 and memory2 representing the available memory in bits on two memory sticks. 
There is currently a faulty program running that consumes an increasing amount of memory every second.

At the ith second (starting from 1), i bits of memory are allocated to the stick with more available memory (or from the first memory stick if both have the same available memory). 
If neither stick has at least i bits of available memory, the program crashes.

Return an array containing [crashTime, memory1crash, memory2crash], where crashTime is the time (in seconds) when the program crashed and memory1crash and memory2crash are the available bits of memory in the first and second sticks respectively.

 

Example 1:

Input: memory1 = 2, memory2 = 2
Output: [3,1,0]
Explanation: The memory is allocated as follows:
- At the 1st second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory.
- At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory.
- At the 3rd second, the program crashes. The sticks have 1 and 0 bits available respectively.
Example 2:

Input: memory1 = 8, memory2 = 11
Output: [6,0,4]
Explanation: The memory is allocated as follows:
- At the 1st second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory.
- At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory.
- At the 3rd second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory.
- At the 4th second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory.
- At the 5th second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory.
- At the 6th second, the program crashes. The sticks have 0 and 4 bits available respectively.
 

Constraints:

0 <= memory1, memory2 <= 231 - 1

class Solution 
{
public:
    vector<int> memLeak(int memory1, int memory2) 
    {
        int i=1;
        while(i<=memory1 || i<=memory2)
        {
            if(memory1>=memory2)
            {
                memory1-=i;
            }
            else
            {
                memory2-=i;
            }
            i++;
        }
        return {i,memory1,memory2};
    }
};


// Source https://leetcode.com/problems/rotating-the-box/

You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:

A stone '#'
A stationary obstacle '*'
Empty '.'
The box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. 
Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.

It is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.

Return an n x m matrix representing the box after the rotation described above.

 

Example 1:



Input: box = [["#",".","#"]]
Output: [["."],
         ["#"],
         ["#"]]
Example 2:



Input: box = [["#",".","*","."],
              ["#","#","*","."]]
Output: [["#","."],
         ["#","#"],
         ["*","*"],
         [".","."]]
Example 3:



Input: box = [["#","#","*",".","*","."],
              ["#","#","#","*",".","."],
              ["#","#","#",".","#","."]]
Output: [[".","#","#"],
         [".","#","#"],
         ["#","#","*"],
         ["#","*","."],
         ["#",".","*"],
         ["#",".","."]]
 

Constraints:

m == box.length
n == box[i].length
1 <= m, n <= 500
box[i][j] is either '#', '*', or '.'.

class Solution
{
public:
    vector<vector<char>> rotateTheBox(vector<vector<char>> &box)
    {
        int n = box.size();
        int m = box[0].size();
        vector<vector<char>>vec(m, vector<char>(n, '.'));

        for(int i = 0; i < n; i++)
        {
            for(int j = m - 1; j >= 0; j--)
            {
                if (box[i][j] == '.') continue;
                if (box[i][j] == '*')
                {
                    vec[j][n - 1 - i] = '*';
                    continue;
                }
                int k = j + 1;
                while(k < m && box[i][k] == '.')
                {
                    k++;
                }
                box[i][j] = '.';
                box[i][k - 1] = '#';
                vec[k - 1][n - 1 - i] = '#';
            }
        }
        return vec;
    }
};



// Source https://leetcode.com/problems/sum-of-floored-pairs/

Given an integer array nums, return the sum of floor(nums[i] / nums[j]) for all pairs of indices 0 <= i, j < nums.length in the array. Since the answer may be too large, return it modulo 109 + 7.

The floor() function returns the integer part of the division.

 

Example 1:

Input: nums = [2,5,9]
Output: 10
Explanation:
floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0
floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1
floor(5 / 2) = 2
floor(9 / 2) = 4
floor(9 / 5) = 1
We calculate the floor of the division for every pair of indices in the array then sum them up.
Example 2:

Input: nums = [7,7,7,7,7,7,7]
Output: 49
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105

class Solution
{
public:
    int sumOfFlooredPairs(vector<int> &nums)
    {
        const int mod = 1e9 + 7;
        vector<int> freq(1e5 + 1, 0);
        int mxVal = 0;
        for (auto val : nums)
        {
            mxVal = max(val, mxVal);
            ++freq[val];
        }

        vector<int> prefix_freq(mxVal + 1, 0);
        prefix_freq[0] = freq[0];
        for (int i = 1; i <= mxVal; i++)
            prefix_freq[i] = prefix_freq[i - 1] + freq[i];

        long res = 0;
        for (int den = 1; den <= mxVal; ++den)
        {
            if (!freq[den])
                continue;

            long mul = 1;
            int n0 = den;
            int n1 = 2 * den - 1;
            while (n0 <= mxVal)
            {
                int f0 = prefix_freq[n0 - 1];
                int f1 = prefix_freq[min(mxVal, n1)];

                res += mul * freq[den] * (f1 - f0);
                res %= mod;

                ++mul;
                n0 += den;
                n1 += den;
            }
        }

        return res;
    }
};


// Source https://leetcode.com/problems/sum-of-all-subset-xor-totals/

The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.

For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.

 

Example 1:

Input: nums = [1,3]
Output: 6
Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6
Example 2:

Input: nums = [5,1,6]
Output: 28
Explanation: The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
Example 3:

Input: nums = [3,4,5,6,7,8]
Output: 480
Explanation: The sum of all XOR totals for every subset is 480.
 

Constraints:

1 <= nums.length <= 12
1 <= nums[i] <= 20

class Solution
{
public:
    int n;
    int res;

    void generateSubsets(int i, vector<int> &nums, vector<int> &subset)
    {
        if(i >= n)
        {
            int xOR = 0;
            for(auto val : subset)
            {
                xOR = xOR ^ val;
            }
            res += xOR;
            return ;
        }
        subset.push_back(nums[i]);
        generateSubsets(i + 1, nums, subset);
        subset.pop_back();
        generateSubsets(i + 1, nums, subset);
    }

    int subsetXORSum(vector<int> &nums)
    {
        n = nums.size();
        res = 0;
        vector<int> subset;
        generateSubsets(0, nums, subset);
        return res;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/

Given a binary string s, return the minimum number of character swaps to make it alternating, or -1 if it is impossible.

The string is called alternating if no two adjacent characters are equal. For example, the strings "010" and "1010" are alternating, while the string "0100" is not.

Any two characters may be swapped, even if they are not adjacent.

 

Example 1:

Input: s = "111000"
Output: 1
Explanation: Swap positions 1 and 4: "111000" -> "101010"
The string is now alternating.
Example 2:

Input: s = "010"
Output: 0
Explanation: The string is already alternating, no swaps are needed.
Example 3:

Input: s = "1110"
Output: -1
 

Constraints:

1 <= s.length <= 1000
s[i] is either '0' or '1'.

class Solution
{
public:

    string getString(char c, int len)
    {
        string str = string(len, c);
        if (c == '1')
            c = '0';
        else
            c = '1';

        for (int i = 1; i < len; i += 2)
        {
            str[i] = c;
        }

        return str;
    }

    int diff(string &str, string &str2)
    {
        int len = str.size();
        int res = 0;
        for (int i = 0; i < len; i++)
        {
            if (str[i] != str2[i])
                res++;
        }
        return res;
    }

    int minSwaps(string s)
    {
        int len = s.size();
        int zeros = 0;
        int ones = 0;
        for (auto ch : s)
        {
            if (ch == '1')
                ones++;
            else
                zeros++;
        }

        if (abs(ones - zeros) > 1)
            return -1;

        auto str = getString('1', len);
        auto str2 = getString('0', len);

        auto d = diff(str, s);
        auto d2 = diff(str2, s);

        if (d % 2 == 1 && d2 % 2 == 1)
            return -1;

        if (d % 2 == 0 && d2 % 2 == 0)
            return min(d / 2, d2 / 2);
        else if (d % 2 == 0)
            return d / 2;
        else
            return d2 / 2;
    }
};


// Source https://leetcode.com/problems/finding-pairs-with-a-certain-sum/

You are given two integer arrays nums1 and nums2. You are tasked to implement a data structure that supports queries of two types:

Add a positive integer to an element of a given index in the array nums2.
Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given value (0 <= i < nums1.length and 0 <= j < nums2.length).
Implement the FindSumPairs class:

FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object with two integer arrays nums1 and nums2.
void add(int index, int val) Adds val to nums2[index], i.e., apply nums2[index] += val.
int count(int tot) Returns the number of pairs (i, j) such that nums1[i] + nums2[j] == tot.
 

Example 1:

Input
["FindSumPairs", "count", "add", "count", "count", "add", "add", "count"]
[[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]
Output
[null, 8, null, 2, 1, null, null, 11]

Explanation
FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);
findSumPairs.count(7);  // return 8; pairs (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) make 2 + 5 and pairs (5,1), (5,5) make 3 + 4
findSumPairs.add(3, 2); // now nums2 = [1,4,5,4,5,4]
findSumPairs.count(8);  // return 2; pairs (5,2), (5,4) make 3 + 5
findSumPairs.count(4);  // return 1; pair (5,0) makes 3 + 1
findSumPairs.add(0, 1); // now nums2 = [2,4,5,4,5,4]
findSumPairs.add(1, 1); // now nums2 = [2,5,5,4,5,4]
findSumPairs.count(7);  // return 11; pairs (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) make 2 + 5 and pairs (5,3), (5,5) make 3 + 4
 

Constraints:

1 <= nums1.length <= 1000
1 <= nums2.length <= 105
1 <= nums1[i] <= 109
1 <= nums2[i] <= 105
0 <= index < nums2.length
1 <= val <= 105
1 <= tot <= 109
At most 1000 calls are made to add and count each.

class FindSumPairs
{
public:
    vector<int> arr1;
    unordered_map<int, int> ump1;
    vector<int> arr2;
    unordered_map<int, int> ump2;

    FindSumPairs(vector<int> &nums1, vector<int> &nums2)
    {
        arr1 = nums1;
        arr2 = nums2;
        for(auto x : nums1)
        {
            ump1[x]++;
        }
        for(auto y : nums2)
        {
            ump2[y]++;
        }
    }

    void add(int index, int val)
    {
        ump2[arr2[index]]--;
        arr2[index] += val;
        ump2[arr2[index]]++;
    }

    int count(int tot)
    {
        int ans = 0;
        for(auto x : ump1)
        {
            if(x.first > tot)
                continue;
            int other = tot - x.first;
            if(ump2.count(other))
            {
                ans += (ump1[x.first] * ump2[other]);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/

There are n uniquely-sized sticks whose lengths are integers from 1 to n. You want to arrange the sticks such that exactly k sticks are visible from the left. 
A stick is visible from the left if there are no longer sticks to the left of it.

For example, if the sticks are arranged [1,3,2,5,4], then the sticks with lengths 1, 3, and 5 are visible from the left.
Given n and k, return the number of such arrangements. Since the answer may be large, return it modulo 109 + 7.

 

Example 1:

Input: n = 3, k = 2
Output: 3
Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible.
The visible sticks are underlined.
Example 2:

Input: n = 5, k = 5
Output: 1
Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible.
The visible sticks are underlined.
Example 3:

Input: n = 20, k = 11
Output: 647427950
Explanation: There are 647427950 (mod 109 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible.
 

Constraints:

1 <= n <= 1000
1 <= k <= n

dp[i][j]表示当前剩余i个sticks，高度分别为n-i+1, n-i+2, n-i+3, ... n，从左能够看到j个棍子的方案数目。
先考虑高度小的stick放哪个位置，再考虑高度大的stick放哪个位置
高度n-i+1的stick如果放在剩余可用位置的最左边，则它肯定可以被看到，因为它比先前已经放好的stick高度都大，
问题转化为剩余i-1个sticks，高度分别为n-i+2, n-i+3, ... n，从左能够看到j-1个棍子的方案数目。
高度n-i+1的stick如果放在剩余可用位置的其他位置(有i-1个)，此时剩余可用位置的最左边放的stick高度 in [n-i+2, n-i+3, ... n]，
这样高度n-i+1的stick就不会被看到（会被高度最左边放的stick挡住），问题转化为剩余i-1个sticks，高度分别为n-i+2, n-i+3, ... n，从左能够看到j个棍子的方案数目。

class Solution
{
public:
    long dp[1001][1001];
    const long mod = 1e9 + 7;
    
    long recur(int i, int j)
    {
        if(j > i) return 0;
        if(j == i) return 1;
        if(j == 0) return 0;
        if(dp[i][j] != -1) return dp[i][j];
        long res = recur(i - 1, j - 1);
        res = (res + ((i - 1) * recur(i - 1, j)) % mod) % mod;
        return dp[i][j] = res;
    }

    int rearrangeSticks(int n, int k)
    {
        memset(dp, -1, sizeof(dp));
        return recur(n, k);
    }
};


// Source https://leetcode.com/problems/longer-contiguous-segments-of-ones-than-zeros/

Given a binary string s, return true if the longest contiguous segment of 1's is strictly longer than the longest contiguous segment of 0's in s, or return false otherwise.

For example, in s = "110100010" the longest continuous segment of 1s has length 2, and the longest continuous segment of 0s has length 3.
Note that if there are no 0's, then the longest continuous segment of 0's is considered to have a length 0. The same applies if there is no 1's.

 

Example 1:

Input: s = "1101"
Output: true
Explanation:
The longest contiguous segment of 1s has length 2: "1101"
The longest contiguous segment of 0s has length 1: "1101"
The segment of 1s is longer, so return true.
Example 2:

Input: s = "111000"
Output: false
Explanation:
The longest contiguous segment of 1s has length 3: "111000"
The longest contiguous segment of 0s has length 3: "111000"
The segment of 1s is not longer, so return false.
Example 3:

Input: s = "110100010"
Output: false
Explanation:
The longest contiguous segment of 1s has length 2: "110100010"
The longest contiguous segment of 0s has length 3: "110100010"
The segment of 1s is not longer, so return false.
 

Constraints:

1 <= s.length <= 100
s[i] is either '0' or '1'.

class Solution
{
public:
    bool checkZeroOnes(string s)
    {
        int n = s.length();
        int m0 = 0;
        int cnt0 = 0;
        int m1 = 0;
        int cnt1 = 0;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == '0')
            {
                cnt0++;
                cnt1 = 0;
            }
            else
            {
                cnt1++;
                cnt0 = 0;
            }
            m0 = max(m0, cnt0);
            m1 = max(m1, cnt1);
        }
        if(m1 > m0) return true;
        return false;
    }
};


// Source https://leetcode.com/problems/minimum-speed-to-arrive-on-time/

You are given a floating-point number hour, representing the amount of time you have to reach the office. 
To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.

Each train can only depart at an integer hour, so you may need to wait in between each train ride.

For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.
Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.

Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.

 

Example 1:

Input: dist = [1,3,2], hour = 6
Output: 1
Explanation: At speed 1:
- The first train ride takes 1/1 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
- You will arrive at exactly the 6 hour mark.
Example 2:

Input: dist = [1,3,2], hour = 2.7
Output: 3
Explanation: At speed 3:
- The first train ride takes 1/3 = 0.33333 hours.
- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
- You will arrive at the 2.66667 hour mark.
Example 3:

Input: dist = [1,3,2], hour = 1.9
Output: -1
Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.
 

Constraints:

n == dist.length
1 <= n <= 105
1 <= dist[i] <= 105
1 <= hour <= 109
There will be at most two digits after the decimal point in hour.

class Solution
{
public:

    bool helper(vector<int> &dist, double hour, int speed)
    {
        double time = 0;
        for (auto d : dist)
        {
            time = ceil(time);
            time +=  (double) d / speed;
            if (time > hour) return false;
        }
        return true;
    }

    int minSpeedOnTime(vector<int> &dist, double hour)
    {
        int n = dist.size();
        if(hour <= (n - 1)) return -1;
        int l = 1, r = 1e7;
        while(l < r)
        {
            int mid = l + (r - l) / 2;
            if(helper(dist, hour, mid))
            {
                r = mid;
            }
            else
            {
                l = mid + 1;
            }
        }
        return l;
    }
};


// Source https://leetcode.com/problems/jump-game-vii/

You are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to '0'. 
You can move from index i to index j if the following conditions are fulfilled:

i + minJump <= j <= min(i + maxJump, s.length - 1), and
s[j] == '0'.
Return true if you can reach index s.length - 1 in s, or false otherwise.

 

Example 1:

Input: s = "011010", minJump = 2, maxJump = 3
Output: true
Explanation:
In the first step, move from index 0 to index 3. 
In the second step, move from index 3 to index 5.
Example 2:

Input: s = "01101110", minJump = 2, maxJump = 3
Output: false
 

Constraints:

2 <= s.length <= 105
s[i] is either '0' or '1'.
s[0] == '0'
1 <= minJump <= maxJump < s.length

class Solution
{
public:
    bool canReach(string s, int minJump, int maxJump)
    {
        int n = s.length();
        if(s[n - 1] == '1')
            return false;
        if(n == 1)
            return true;
        deque<int> dq;
        dq.push_back(0);
        for(int i = 1; i < n; i++)
        {
            if(s[i] == '0')
            {
                while(!dq.empty() && dq.front() + maxJump < i) dq.pop_front();
                if(!dq.empty() && dq.front() + minJump <= i) dq.push_back(i);
            }
        }
        return !dq.empty() && dq.back() == n - 1;
    }
};


// Source https://leetcode.com/problems/stone-game-viii/

Alice and Bob take turns playing a game, with Alice starting first.

There are n stones arranged in a row. On each player's turn, while the number of stones is more than one, they will do the following:

Choose an integer x > 1, and remove the leftmost x stones from the row.
Add the sum of the removed stones' values to the player's score.
Place a new stone, whose value is equal to that sum, on the left side of the row.
The game stops when only one stone is left in the row.

The score difference between Alice and Bob is (Alice's score - Bob's score). Alice's goal is to maximize the score difference, and Bob's goal is the minimize the score difference.

Given an integer array stones of length n where stones[i] represents the value of the ith stone from the left, return the score difference between Alice and Bob if they both play optimally.

 

Example 1:

Input: stones = [-1,2,-3,4,-5]
Output: 5
Explanation:
- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of
  value 2 on the left. stones = [2,-5].
- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on
  the left. stones = [-3].
The difference between their scores is 2 - (-3) = 5.
Example 2:

Input: stones = [7,-6,5,10,5,-2,-6]
Output: 13
Explanation:
- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a
  stone of value 13 on the left. stones = [13].
The difference between their scores is 13 - 0 = 13.
Example 3:

Input: stones = [-10,-12]
Output: -22
Explanation:
- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her
  score and places a stone of value -22 on the left. stones = [-22].
The difference between their scores is (-22) - 0 = -22.
 

Constraints:

n == stones.length
2 <= n <= 105
-104 <= stones[i] <= 104

class Solution
{
public:
    int n;
    vector<long> dp;

    int stoneGameVIII(vector<int> &stones)
    {
        n = stones.size();
        dp.resize(n + 1, -1e16);
        vector<long> prefix(n, 0);
        prefix[0] = stones[0];
        for(int i = 1; i < n; i++)
            prefix[i] = prefix[i - 1] + stones[i];
        return solve(1, prefix);
    }

    long solve(int i, vector<long> &prefix)
    {
        if(i == n - 1) return prefix[i];
        if(dp[i] != -1e16) return dp[i];
        long res = -1e16;
        res = max(res, prefix[i] - solve(i + 1, prefix));
        res = max(res, solve(i + 1, prefix));
        return dp[i] = res;
    }
};


// Source https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/

A string is good if there are no repeated characters.

Given a string s​​​​​, return the number of good substrings of length three in s​​​​​​.

Note that if there are multiple occurrences of the same substring, every occurrence should be counted.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: s = "xyzzaz"
Output: 1
Explanation: There are 4 substrings of size 3: "xyz", "yzz", "zza", and "zaz". 
The only good substring of length 3 is "xyz".
Example 2:

Input: s = "aababcabc"
Output: 4
Explanation: There are 7 substrings of size 3: "aab", "aba", "bab", "abc", "bca", "cab", and "abc".
The good substrings are "abc", "bca", "cab", and "abc".
 

Constraints:

1 <= s.length <= 100
s​​​​​​ consists of lowercase English letters.

class Solution
{
public:

    int countGoodSubstrings(string s)
    {
        int n = s.length();
        if(n < 3) return 0;
        int res = 0;
        for(int i = 0 ; i < n - 2 ; ++i)
        {
            if(s[i] != s[i + 1] && s[i + 1] != s[i + 2] && s[i] != s[i + 2] )
            {
                ++res;
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/

The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.

For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:

Each element of nums is in exactly one pair, and
The maximum pair sum is minimized.
Return the minimized maximum pair sum after optimally pairing up the elements.

 

Example 1:

Input: nums = [3,5,2,3]
Output: 7
Explanation: The elements can be paired up into pairs (3,3) and (5,2).
The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.
Example 2:

Input: nums = [3,5,4,2,4,6]
Output: 8
Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).
The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.
 
Constraints:

n == nums.length
2 <= n <= 105
n is even.
1 <= nums[i] <= 105

class Solution
{
public:
    int minPairSum(vector<int> &nums)
    {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        int res = 0;
        for(int i = 0; i < n / 2; i++)
        {
            res = max(res, nums[i] + nums[n - 1 - i]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/

You are given an m x n integer matrix grid​​​.

A rhombus sum is the sum of the elements that form the border of a regular rhombus shape in grid​​​. 
The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. 
Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each rhombus sum:


Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.

Return the biggest three distinct rhombus sums in the grid in descending order. If there are less than three distinct values, return all of them.

 

Example 1:


Input: grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]]
Output: [228,216,211]
Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.
- Blue: 20 + 3 + 200 + 5 = 228
- Red: 200 + 2 + 10 + 4 = 216
- Green: 5 + 200 + 4 + 2 = 211
Example 2:


Input: grid = [[1,2,3],[4,5,6],[7,8,9]]
Output: [20,9,8]
Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.
- Blue: 4 + 2 + 6 + 8 = 20
- Red: 9 (area 0 rhombus in the bottom right corner)
- Green: 8 (area 0 rhombus in the bottom middle)
Example 3:

Input: grid = [[7,7,7]]
Output: [7]
Explanation: All three possible rhombus sums are the same, so return [7].
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 50
1 <= grid[i][j] <= 105

the rhombus can have an area of 0
grid[i][j]为菱形中心点，菱形长度可以为0，1，2，...

class Solution
{
public:
    vector<int> getBiggestThree(vector<vector<int>> &grid)
    {
        int m = grid.size();
        int n = grid[0].size();
        int max1 = 0, max2 = 0, max3 = 0;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                int val = grid[i][j];
                if(val > max1)
                {
                    max3 = max2;
                    max2 = max1;
                    max1 = val;
                }
                else if(val > max2 && val < max1)
                {
                    max3 = max2;
                    max2 = val;
                }
                else if(val > max3 && val < max2)
                {
                    max3 = val;
                }
                if(i == 0 || j == 0 || i == m - 1 || j == n - 1) continue;
                int len = 1;
                while((i - len) >= 0 && (i + len) < m && (j - len) >= 0 && (j + len) < n)
                {
                    int sum = 0;
                    sum += grid[i + len][j];
                    sum += grid[i][j + len];
                    sum += grid[i - len][j];
                    sum += grid[i][j - len];
                    for(int k = 1; k < len; k++) // loop to get all the point along the edges
                    {
                        sum += grid[i + len - k][j + k]; //  从最低到最右
                        sum += grid[i - k][j + len - k];  // 从最右到最高
                        sum += grid[i - len + k][j - k];  // 从最高到最左
                        sum += grid[i + k][j - len + k]; // 从最左到最低
                    }
                    if(sum > max1)
                    {
                        max3 = max2;
                        max2 = max1;
                        max1 = sum;
                    }
                    else if(sum > max2 && sum < max1)
                    {
                        max3 = max2;
                        max2 = sum;
                    }
                    else if(sum > max3 && sum < max2)
                    {
                        max3 = sum;
                    }
                    ++len;
                }
            }
        }
        vector <int> ans;
        if (max1 != 0) ans.push_back(max1);
        if (max2 != 0) ans.push_back(max2);
        if (max3 != 0) ans.push_back(max3);
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/

You are given two integer arrays nums1 and nums2 of length n.

The XOR sum of the two integer arrays is (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) (0-indexed).

For example, the XOR sum of [1,2,3] and [3,2,1] is equal to (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4.
Rearrange the elements of nums2 such that the resulting XOR sum is minimized.

Return the XOR sum after the rearrangement.

 

Example 1:

Input: nums1 = [1,2], nums2 = [2,3]
Output: 2
Explanation: Rearrange nums2 so that it becomes [3,2].
The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.
Example 2:

Input: nums1 = [1,0,3], nums2 = [5,3,4]
Output: 8
Explanation: Rearrange nums2 so that it becomes [5,4,3]. 
The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.
 

Constraints:

n == nums1.length
n == nums2.length
1 <= n <= 14
0 <= nums1[i], nums2[i] <= 107

class Solution
{
public:
    int n;
    int dp[20][30000];

    int recur(vector<int> &nums1, vector<int> &nums2, int i, int mask)
    {
        if (i >= n) return 0;
        if(dp[i][mask] != -1) return dp[i][mask];
        int ans = INT_MAX;
        for(int j = 0; j < n; j++)
        {
            if(mask & (1 << j))
            {
                ans = min(ans, (nums1[i] ^ nums2[j]) + recur(nums1, nums2, i + 1, mask ^ (1 << j)));
            }
        }
        return dp[i][mask] = ans;
    }

    int minimumXORSum(vector<int> &nums1, vector<int> &nums2)
    {
        n = nums1.size();
        memset(dp, -1, sizeof(dp));
        int mask = (1 << n) - 1;
        return recur(nums1, nums2, 0, mask);
    }
};


// Source https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/

The letter value of a letter is its position in the alphabet starting from 0 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, etc.).

The numerical value of some string of lowercase English letters s is the concatenation of the letter values of each letter in s, which is then converted into an integer.

For example, if s = "acb", we concatenate each letter's letter value, resulting in "021". After converting it, we get 21.
You are given three strings firstWord, secondWord, and targetWord, each consisting of lowercase English letters 'a' through 'j' inclusive.

Return true if the summation of the numerical values of firstWord and secondWord equals the numerical value of targetWord, or false otherwise.

 

Example 1:

Input: firstWord = "acb", secondWord = "cba", targetWord = "cdb"
Output: true
Explanation:
The numerical value of firstWord is "acb" -> "021" -> 21.
The numerical value of secondWord is "cba" -> "210" -> 210.
The numerical value of targetWord is "cdb" -> "231" -> 231.
We return true because 21 + 210 == 231.
Example 2:

Input: firstWord = "aaa", secondWord = "a", targetWord = "aab"
Output: false
Explanation: 
The numerical value of firstWord is "aaa" -> "000" -> 0.
The numerical value of secondWord is "a" -> "0" -> 0.
The numerical value of targetWord is "aab" -> "001" -> 1.
We return false because 0 + 0 != 1.
Example 3:

Input: firstWord = "aaa", secondWord = "a", targetWord = "aaaa"
Output: true
Explanation: 
The numerical value of firstWord is "aaa" -> "000" -> 0.
The numerical value of secondWord is "a" -> "0" -> 0.
The numerical value of targetWord is "aaaa" -> "0000" -> 0.
We return true because 0 + 0 == 0.
 

Constraints:

1 <= firstWord.length, secondWord.length, targetWord.length <= 8
firstWord, secondWord, and targetWord consist of lowercase English letters from 'a' to 'j' inclusive.

class Solution
{
public:
    int convertNum(string &word)
    {
        int res = 0;
        for (char c : word)
        {
            res = (res * 10) + (c - 'a');
        }
        return res;
    }

    bool isSumEqual(string firstWord, string secondWord, string targetWord)
    {
        return (convertNum(firstWord) + convertNum(secondWord)) == convertNum(targetWord);
    }
};


// Source https://leetcode.com/problems/maximum-value-after-insertion/

You are given a very large integer n, represented as a string,​​​​​​ and an integer digit x. The digits in n and the digit x are in the inclusive range [1, 9], and n may represent a negative number.

You want to maximize n's numerical value by inserting x anywhere in the decimal representation of n​​​​​​. You cannot insert x to the left of the negative sign.

For example, if n = 73 and x = 6, it would be best to insert it between 7 and 3, making n = 763.
If n = -55 and x = 2, it would be best to insert it before the first 5, making n = -255.
Return a string representing the maximum value of n​​​​​​ after the insertion.

 

Example 1:

Input: n = "99", x = 9
Output: "999"
Explanation: The result is the same regardless of where you insert 9.
Example 2:

Input: n = "-13", x = 2
Output: "-123"
Explanation: You can make n one of {-213, -123, -132}, and the largest of those three is -123.
 

Constraints:

1 <= n.length <= 105
1 <= x <= 9
The digits in n​​​ are in the range [1, 9].
n is a valid representation of an integer.
In the case of a negative n,​​​​​​ it will begin with '-'.

class Solution
{
public:
    string maxValue(string s, int x)
    {
        int n = s.length();
        if(s[0] == '-')
        {
            for(int i = 1; i < n; i++)
            {
                if(s[i] - '0' > x)
                {
                    return (s.substr(0, i) + (char)(x + '0') + s.substr(i));
                }
            }
            return (s + (char)(x + '0'));
        }
        for(int i = 0; i < n; i++)
        {
            if(s[i] - '0' < x)
            {
                return (s.substr(0, i) + (char)(x + '0') + s.substr(i));
            }
        }
        return (s + (char)(x + '0'));
    }
};


// Source https://leetcode.com/problems/process-tasks-using-servers/

You are given two 0-indexed integer arrays servers and tasks of lengths n​​​​​​ and m​​​​​​ respectively. 
servers[i] is the weight of the i​​​​​​th​​​​ server, and tasks[j] is the time needed to process the j​​​​​​th​​​​ task in seconds.

Tasks are assigned to the servers using a task queue. Initially, all servers are free, and the queue is empty.

At second j, the jth task is inserted into the queue (starting with the 0th task being inserted at second 0). 
As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the smallest weight, 
and in case of a tie, it is assigned to a free server with the smallest index.

If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. 
If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.

A server that is assigned task j at second t will be free again at second t + tasks[j].

Build an array ans​​​​ of length m, where ans[j] is the index of the server the j​​​​​​th task will be assigned to.

Return the array ans​​​​.

 

Example 1:

Input: servers = [3,3,2], tasks = [1,2,3,2,1,2]
Output: [2,2,0,2,1,2]
Explanation: Events in chronological order go as follows:
- At second 0, task 0 is added and processed using server 2 until second 1.
- At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.
- At second 2, task 2 is added and processed using server 0 until second 5.
- At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.
- At second 4, task 4 is added and processed using server 1 until second 5.
- At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.
Example 2:

Input: servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]
Output: [1,4,1,4,1,3,2]
Explanation: Events in chronological order go as follows: 
- At second 0, task 0 is added and processed using server 1 until second 2.
- At second 1, task 1 is added and processed using server 4 until second 2.
- At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. 
- At second 3, task 3 is added and processed using server 4 until second 7.
- At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. 
- At second 5, task 5 is added and processed using server 3 until second 7.
- At second 6, task 6 is added and processed using server 2 until second 7.
 

Constraints:

servers.length == n
tasks.length == m
1 <= n, m <= 2 * 105
1 <= servers[i], tasks[j] <= 2 * 105


class Solution
{
public:

    struct Task
    {
        int id;
        int time_needed;
        Task(int id, int time_needed) : id(id), time_needed(time_needed) {}
    };

    struct Server
    {
        int id;
        int weight;
        int available_time;
        Server(int id, int weight) : id(id), weight(weight), available_time(-1) {}

        void schedule_task(Task task, int curr_time)
        {
            available_time = curr_time + task.time_needed;
        }
    };

    struct WeightComparator
    {
        bool operator()(Server const &lhs, Server const &rhs)
        {
            if (lhs.weight == rhs.weight) return lhs.id > rhs.id;
            return (lhs.weight > rhs.weight);
        }
    };

    struct AvailableComparator
    {
        bool operator()(Server const &lhs, Server const &rhs)
        {
            return (lhs.available_time > rhs.available_time);
        }
    };

    vector<int> assignTasks(vector<int> &servers, vector<int> &tasks)
    {
        int total_tasks = tasks.size();
        vector<int> ans(total_tasks, -1);
        priority_queue<Server, vector<Server>, WeightComparator> free_servers;
        priority_queue<Server, vector<Server>, AvailableComparator> busy_servers;
        queue<Task> task_queue;
        for (int i = 0; i < servers.size(); i++)
        {
            free_servers.push(Server{i, servers[i]});
        }
        int task_id = 0;
        int curr_time = 0;
        while (task_id < total_tasks || !task_queue.empty())
        {
            while (!busy_servers.empty() && busy_servers.top().available_time <= curr_time)
            {
                Server server = busy_servers.top();
                busy_servers.pop();
                free_servers.push(server);
            }
            while (!task_queue.empty() && !free_servers.empty())
            {
                Server server = free_servers.top();
                free_servers.pop();
                Task task = task_queue.front();
                task_queue.pop();
                server.schedule_task(task, curr_time);
                busy_servers.push(server);
                ans[task.id] = server.id;
            }
            if (task_id < total_tasks)
            {
                task_queue.push(Task{task_id, tasks[task_id]});
                ++task_id;
                ++curr_time;
            }
            else
            {
                curr_time = busy_servers.top().available_time;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-skips-to-arrive-at-meeting-on-time/

You are given an integer hoursBefore, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through n roads. 
The road lengths are given as an integer array dist of length n, where dist[i] describes the length of the ith road in kilometers. 
In addition, you are given an integer speed, which is the speed (in km/h) you will travel at.

After you travel road i, you must rest and wait for the next integer hour before you can begin traveling on the next road. 
Note that you do not have to rest after traveling the last road because you are already at the meeting.

For example, if traveling a road takes 1.4 hours, you must wait until the 2 hour mark before traveling the next road. If traveling a road takes exactly 2 hours, you do not need to wait.
However, you are allowed to skip some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. 
Note that this means you may finish traveling future roads at different hour marks.

For example, suppose traveling the first road takes 1.4 hours and traveling the second road takes 0.6 hours. 
Skipping the rest after the first road will mean you finish traveling the second road right at the 2 hour mark, letting you start traveling the third road immediately.
Return the minimum number of skips required to arrive at the meeting on time, or -1 if it is impossible.

 

Example 1:

Input: dist = [1,3,2], speed = 4, hoursBefore = 2
Output: 1
Explanation:
Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.
You can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.
Note that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.
Example 2:

Input: dist = [7,3,5,5], speed = 2, hoursBefore = 10
Output: 2
Explanation:
Without skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.
You can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.
Example 3:

Input: dist = [7,3,5,5], speed = 1, hoursBefore = 10
Output: -1
Explanation: It is impossible to arrive at the meeting on time even if you skip all the rests.
 

Constraints:

n == dist.length
1 <= n <= 1000
1 <= dist[i] <= 105
1 <= speed <= 106
1 <= hoursBefore <= 107


dp[i][j] 表示travel完成 前 i + 1 条路，dist[0] ... dist[i]，the number of skips 为 j，对应的distance最小值
After you travel road i, you must rest and wait for the next integer hour before you can begin traveling on the next road. 
you do not have to rest after traveling the last road because you are already at the meeting.
distance = speed * 总花费时间 （正常travel时间 + wait 时间）= speed的整数倍 + the length of the last road
j <= i，最多可以skip i 次
0th road 结束后可以 skip一次 直接开始 1th road，1th road 结束后可以 skip一次 直接开始 2th road，... , (i-1)th road 结束后可以 skip一次 直接开始 ith road

class Solution
{
public:
    long dp[1010][1010];

    long ll_ceil(long d, long speed)
    {
        if(d % speed == 0) return d;
        return d - d % speed + speed;
    }

    int minSkips(vector<int> &dist, int speed, int hoursBefore)
    {
        dp[0][0] = dist[0];
        int n = dist.size();
        for(int i = 1; i < n; i++)
        {
            long d = dist[i];
            // without skip, (i-1)th road 结束后先wait，再开始 ith road
            dp[i][0] = ll_ceil(dp[i - 1][0], speed) + d;
            // skip
            for(int j = 1; j <= i; j++)
            {
                long prev = 1e16;
                // (i-1)th road 结束后先wait，再开始 ith road
                if (j < i) prev = ll_ceil(dp[i - 1][j], speed) + d;
                // (i-1)th road 结束后skip一次 直接开始 ith road
                long curr = dp[i - 1][j - 1] + d;
                dp[i][j] = min(prev, curr);
            }
        }
        for(int i = 0; i < n; i++)
        {
            if(dp[n - 1][i] <= (long)speed * (long)hoursBefore)
                return i;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/

You are given two identical eggs and you have access to a building with n floors labeled from 1 to n.

You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break.

In each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. 
However, if the egg does not break, you may reuse it in future moves.

Return the minimum number of moves that you need to determine with certainty what the value of f is.

 

Example 1:

Input: n = 2
Output: 2
Explanation: We can drop the first egg from floor 1 and the second egg from floor 2.
If the first egg breaks, we know that f = 0.
If the second egg breaks but the first egg didn't, we know that f = 1.
Otherwise, if both eggs survive, we know that f = 2.
Example 2:

Input: n = 100
Output: 14
Explanation: One optimal strategy is:
- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.
- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.
- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.
Regardless of the outcome, it takes at most 14 drops to determine f.
 

Constraints:

1 <= n <= 1000

注意，题目求的是扔鸡蛋的次数

有K个鸡蛋，还有一栋共N层的大楼，有个临界点的层数F，任何鸡蛋在高于这个层数扔都会碎，低于等于这个层数就不会碎，
不管临界点的值是多少，我们都要能找到这个临界点，问最小需要多少操作，注意这里的操作只有当前还有没碎的鸡蛋才能进行。

dp[i][j] 表示当有i次操作，且有j个鸡蛋时能测出的最高的楼层，先使用1个鸡蛋测试第 dp[i-1][j-1]+1 层，有两种情况：

鸡蛋碎掉：剩余i-1次操作，j-1个鸡蛋，还可以测出 0, 1, 2, ..., dp[i-1][j-1] 。
鸡蛋没碎：那这个鸡蛋可以继续利用，此时可以测出 dp[i-1][j-1]+1, ..., dp[i-1][j-1]+1 + dp[i-1][j]
这样，通过i次操作和j个鸡蛋查找的层数范围是 [0, dp[i-1][j-1] + dp[i-1][j] + 1]，状态转移方程如下：

dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + 1

当 dp[i][K] 正好大于等于N的时候，i就是我们要求的最小操作次数了

在鸡蛋数足够的前提下
用1次操作，可以测出的临界点如下 0, 1
先在第1层扔鸡蛋

用2次操作，可以测出的临界点如下 0, 1, 2, 3
先在第2层扔鸡蛋，再在第1层，第3层扔鸡蛋

用3次操作，可以测出的临界点如下 0, 1, 2, 3, 4, 5, 6, 7
现在第4层扔鸡蛋，再在第2，6层扔鸡蛋，再在第1层，第3层，第5，7层扔鸡蛋

class Solution
{
public:

    int superEggDrop(int K, int N)
    {
        vector<int> dp(K + 1);
        int m = 0;
        while (dp[K] < N)
        {
            ++m;
            vector<int> temp(K + 1);
            for (int j = 1; j <= K; ++j)
            {
                temp[j] = dp[j - 1] + dp[j] + 1;
            }
            swap(dp, temp);
        }
        return m;
    }

    int twoEggDrop(int n)
    {
        return superEggDrop(2, n);
    }
};


// Source https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/

Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.

 

Example 1:


Input: mat = [[0,1],[1,0]], target = [[1,0],[0,1]]
Output: true
Explanation: We can rotate mat 90 degrees clockwise to make mat equal target.
Example 2:


Input: mat = [[0,1],[1,1]], target = [[1,0],[0,1]]
Output: false
Explanation: It is impossible to make mat equal to target by rotating mat.
Example 3:


Input: mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]
Output: true
Explanation: We can rotate mat 90 degrees clockwise two times to make mat equal target.
 

Constraints:

n == mat.length == target.length
n == mat[i].length == target[i].length
1 <= n <= 10
mat[i][j] and target[i][j] are either 0 or 1.

class Solution
{
public:
    bool findRotation(vector<vector<int>> &mat, vector<vector<int>> &target)
    {
        int n = mat.size();
        if(mat == target)
        {
            return true;
        }
        vector<vector<int>> vec(n, vector<int>(n, 0));
        int num = 0;
        while(num < 3)
        {
            for(int i = 0; i < n; i++)
            {
                for(int j = 0; j < n; j++)
                {
                   vec[j][n - 1 - i] = mat[i][j];
                }
            }
            if(vec == target) return true;
            swap(mat, vec);
            num++;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal/

Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

 

Example 1:

Input: nums = [5,1,3]
Output: 3
Explanation: It takes 3 operations to make all elements in nums equal:
1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].
Example 2:

Input: nums = [1,1,1]
Output: 0
Explanation: All elements in nums are already equal.
Example 3:

Input: nums = [1,1,2,2,3]
Output: 4
Explanation: It takes 4 operations to make all elements in nums equal:
1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].
2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].
3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].
4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].
 

Constraints:

1 <= nums.length <= 5 * 104
1 <= nums[i] <= 5 * 104

class Solution
{
public:
    int reductionOperations(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<int> cnt(n, 0);
        int count = 0;
        for (int i = 1; i < n; ++i)
        {
            if (nums[i] != nums[i-1]) ++count;
            cnt[i] = count;
        }
        int ans = accumulate(cnt.begin(), cnt.end(), 0);
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/

You are given a binary string s. You are allowed to perform two types of operations on the string in any sequence:

Type-1: Remove the character at the start of the string s and append it to the end of the string.
Type-2: Pick any character in s and flip its value, i.e., if its value is '0' it becomes '1' and vice-versa.
Return the minimum number of type-2 operations you need to perform such that s becomes alternating.

The string is called alternating if no two adjacent characters are equal.

For example, the strings "010" and "1010" are alternating, while the string "0100" is not.
 

Example 1:

Input: s = "111000"
Output: 2
Explanation: Use the first operation two times to make s = "100011".
Then, use the second operation on the third and sixth elements to make s = "101010".
Example 2:

Input: s = "010"
Output: 0
Explanation: The string is already alternating.
Example 3:

Input: s = "1110"
Output: 1
Explanation: Use the second operation on the second element to make s = "1010".
 

Constraints:

1 <= s.length <= 105
s[i] is either '0' or '1'.

p[i][0] 表示翻转s[0 ... i]中的若干个元素，使得翻转后s[0 ... i] alternating，且s[i]为'0'，对应的翻转次数
p[i][1] 表示翻转s[0 ... i]中的若干个元素，使得翻转后s[0 ... i] alternating，且s[i]为'1'，对应的翻转次数
s[i][0] 表示翻转s[i ... n-1]中的若干个元素，使得翻转后s[i ... n-1] alternating，且s[i]为'0'，对应的翻转次数
s[i][1] 表示翻转s[i ... n-1]中的若干个元素，使得翻转后s[i ... n-1] alternating，且s[i]为'1'，对应的翻转次数

1010 ... 10     长度为偶数，开始'1'与结尾'0'不同
1010 ... 101   长度为奇数，开始'1'与结尾'1'相同
0101 ... 01     长度为偶数，开始'0'与结尾'1'不同
0101 ... 010   长度为奇数，开始'0'与结尾'0'相同

class Solution
{
public:
    int minFlips(string t)
    {
        int n = t.length();
        int p[n][2], s[n][2];
        if(t[0] == '1')
        {
            p[0][0] = 1;
            p[0][1] = 0;
        }
        else
        {
            p[0][0] = 0;
            p[0][1] = 1;
        }
        for(int i = 1; i < n; i++)
        {
            if(t[i] == '1')
            {
                p[i][1] = p[i - 1][0];
                p[i][0] = 1 + p[i - 1][1];
            }
            else
            {
                p[i][0] = p[i - 1][1];
                p[i][1] = 1 + p[i - 1][0];
            }
        }

        if(t[n - 1] == '1')
        {
            s[n - 1][0] = 1;
            s[n - 1][1] = 0;
        }
        else
        {
            s[n - 1][1] = 1;
            s[n - 1][0] = 0;
        }

        for(int i = n - 2; i >= 0; i--)
        {
            if(t[i] == '1')
            {
                s[i][1] = s[i + 1][0];
                s[i][0] = 1 + s[i + 1][1];
            }
            else
            {
                s[i][0] = s[i + 1][1];
                s[i][1] = 1 + s[i + 1][0];
            }
        }

        int ans = min(s[0][0], s[0][1]);

        for(int i = 1; i < n; i++)
        {
            int part1 = s[i][1], part2 = s[i][0];
            if((n - i) % 2)
            {
                if(i % 2)
                {
                    ans = min({ans, part1 + p[i - 1][0]});   // 奇数长度 1010 ... 101 + 奇数长度 0101 ... 010
                    ans = min({ans, part2 + p[i - 1][1]});   // 奇数长度 0101 ... 010 + 奇数长度 1010 ... 101
                }
                else
                {
                    ans = min({ans, part1 + p[i - 1][1]});   // 奇数长度 1010 ... 101 + 偶数长度 0101 ... 01
                    ans = min({ans, part2 + p[i - 1][0]});   // 奇数长度 0101 ... 010 + 偶数长度 1010 ... 10
                }
            }
            else
            {
                if(i % 2)
                {
                    ans = min({ans, part1 + p[i - 1][1]});   // 偶数长度 1010 ... 10 + 奇数长度 1010 ... 101
                    ans = min({ans, part2 + p[i - 1][0]});   // 偶数长度 0101 ... 01 + 奇数长度 0101 ... 010
                }
                else
                {
                    ans = min({ans, part1 + p[i - 1][0]});   // 偶数长度 1010 ... 10 + 偶数长度 1010 ... 10
                    ans = min({ans, part2 + p[i - 1][1]});   // 偶数长度 0101 ... 01 + 偶数长度 0101 ... 01
                }
            }
        }

        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-space-wasted-from-packaging/

You have n packages that you are trying to place in boxes, one package in each box. There are m suppliers that each produce boxes of different sizes (with infinite supply). 
A package can be placed in a box if the size of the package is less than or equal to the size of the box.

The package sizes are given as an integer array packages, where packages[i] is the size of the ith package. 
The suppliers are given as a 2D integer array boxes, where boxes[j] is an array of box sizes that the jth supplier produces.

You want to choose a single supplier and use boxes from them such that the total wasted space is minimized. 
For each package in a box, we define the space wasted to be size of the box - size of the package. The total wasted space is the sum of the space wasted in all the boxes.

For example, if you have to fit packages with sizes [2,3,5] and the supplier offers boxes of sizes [4,8], 
you can fit the packages of size-2 and size-3 into two boxes of size-4 and the package with size-5 into a box of size-8. This would result in a waste of (4-2) + (4-3) + (8-5) = 6.
Return the minimum total wasted space by choosing the box supplier optimally, or -1 if it is impossible to fit all the packages inside boxes. 
Since the answer may be large, return it modulo 109 + 7.

 

Example 1:

Input: packages = [2,3,5], boxes = [[4,8],[2,8]]
Output: 6
Explanation: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box.
The total waste is (4-2) + (4-3) + (8-5) = 6.
Example 2:

Input: packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]
Output: -1
Explanation: There is no box that the package of size 5 can fit in.
Example 3:

Input: packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]
Output: 9
Explanation: It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes.
The total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.
 

Constraints:

n == packages.length
m == boxes.length
1 <= n <= 105
1 <= m <= 105
1 <= packages[i] <= 105
1 <= boxes[j].length <= 105
1 <= boxes[j][k] <= 105
sum(boxes[j].length) <= 105
The elements in boxes[j] are distinct.

class Solution
{
public:
    int n;
    const int mod = 1e9 + 7;

    int find(vector<int> &packages, int s, int x)
    {
        int res = -1;
        int i = s, j = n - 1;
        while(i <= j)
        {
            int mid = i + (j - i) / 2;
            if(packages[mid] <= x)
            {
                res = mid;
                i = mid + 1;
            }
            else
                j = mid - 1;
        }
        return res;
    }

    int minWastedSpace(vector<int> &packages, vector<vector<int>> &boxes)
    {
        n = packages.size();
        sort(packages.begin(), packages.end());
        vector<long long int> prefix(n + 1, 0);
        for(int i = 0; i < n; i++)
        {
            prefix[i + 1] = prefix[i] + packages[i];
        }
        long long int ans = 1e18;
        for(auto &v : boxes)
        {
            sort(v.begin(), v.end());
            int i = 0;
            long long int res = 0;
            for(auto x : v)
            {
                int idx = find(packages, i, x);
                if (idx != -1)
                {
                    long long int t = (long long int)(idx - i + 1) * x;
                    res = (res + t - prefix[idx + 1] + prefix[i]);
                    i = idx + 1;
                    if (i >= n) break;
                }
            }
            if(i == n) ans = min(ans, res);
        }
        return ans == 1e18 ? -1 : ans % mod;
    }
};


// Source https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/

You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi.

Return true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.

An integer x is covered by an interval ranges[i] = [starti, endi] if starti <= x <= endi.

 

Example 1:

Input: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
Output: true
Explanation: Every integer between 2 and 5 is covered:
- 2 is covered by the first range.
- 3 and 4 are covered by the second range.
- 5 is covered by the third range.
Example 2:

Input: ranges = [[1,10],[10,20]], left = 21, right = 21
Output: false
Explanation: 21 is not covered by any range.
 

Constraints:

1 <= ranges.length <= 50
1 <= starti <= endi <= 50
1 <= left <= right <= 50

class Solution
{
public:
    bool isCovered(vector<vector<int>> &ranges, int left, int right)
    {
        int arr[128] = {0};
        for (auto &v : ranges)
        {
            arr[v[0]]++;
            arr[v[1] + 1]--;
        }
        int sum = 0;
        for (int i = 1; i <left; ++i) sum += arr[i];
        for (int i = left; i <= right; ++i)
        {
            sum += arr[i];
            if (sum <= 0) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/

There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, 
and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.

You are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. 
When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. 
However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.

Return the index of the student that will replace the chalk.

 

Example 1:

Input: chalk = [5,1,5], k = 22
Output: 0
Explanation: The students go in turns as follows:
- Student number 0 uses 5 chalk, so k = 17.
- Student number 1 uses 1 chalk, so k = 16.
- Student number 2 uses 5 chalk, so k = 11.
- Student number 0 uses 5 chalk, so k = 6.
- Student number 1 uses 1 chalk, so k = 5.
- Student number 2 uses 5 chalk, so k = 0.
Student number 0 does not have enough chalk, so they will have to replace it.
Example 2:

Input: chalk = [3,4,1,2], k = 25
Output: 1
Explanation: The students go in turns as follows:
- Student number 0 uses 3 chalk so k = 22.
- Student number 1 uses 4 chalk so k = 18.
- Student number 2 uses 1 chalk so k = 17.
- Student number 3 uses 2 chalk so k = 15.
- Student number 0 uses 3 chalk so k = 12.
- Student number 1 uses 4 chalk so k = 8.
- Student number 2 uses 1 chalk so k = 7.
- Student number 3 uses 2 chalk so k = 5.
- Student number 0 uses 3 chalk so k = 2.
Student number 1 does not have enough chalk, so they will have to replace it.
 

Constraints:

chalk.length == n
1 <= n <= 105
1 <= chalk[i] <= 105
1 <= k <= 109

class Solution
{
public:
    int chalkReplacer(vector<int> &chalk, int k)
    {
        int n = chalk.size();
        long long total = accumulate(chalk.begin(), chalk.end(), 0LL);
        long long rem = (long long) k % total;
        for(int i = 0 ; i < n ; i++)
        {
            if(rem < chalk[i]) return i;
            rem -= chalk[i];            
        }
        return 0;
    }
};


// Source https://leetcode.com/problems/largest-magic-square/

A k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. 
The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square.

Given an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid.

 

Example 1:


Input: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]
Output: 3
Explanation: The largest magic square has a size of 3.
Every row sum, column sum, and diagonal sum of this magic square is equal to 12.
- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
- Diagonal sums: 5+4+3 = 6+4+2 = 12
Example 2:


Input: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]
Output: 2
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 50
1 <= grid[i][j] <= 106

class Solution
{
public:
    int rsum[100][100], csum[100][100], d1sum[100][100], d2sum[100][100];
    
    int largestMagicSquare(vector<vector<int>> &grid)
    {
        int m = grid.size(), n = grid[0].size();
        for (int i = 1; i <= m; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                rsum[i][j] = rsum[i][j - 1] + grid[i - 1][j - 1];
                csum[i][j] = csum[i - 1][j] + grid[i - 1][j - 1];
                d1sum[i][j] = d1sum[i - 1][j - 1] + grid[i - 1][j - 1];
                d2sum[i][j] = d2sum[i - 1][j + 1] + grid[i - 1][j - 1];
            }
        }

        for(int l = min(m, n); l > 1; --l)
        {
            for (int i = 1; i + l - 1 <= m; ++i)
            {
                for (int j = 1; j + l - 1 <= n; ++j)
                {
                    int d1 = d1sum[i + l - 1][j + l - 1] - d1sum[i - 1][j - 1];
                    int d2 = d2sum[i + l - 1][j] - d2sum[i - 1][j + l];
                    bool valid = d1 == d2;
                    for (int k = 0; k < l && valid; ++k)
                    {
                        valid &= d1 == rsum[i + k][j + l - 1] - rsum[i + k][j - 1];
                        valid &= d1 == csum[i + l - 1][j + k] - csum[i - 1][j + k];
                    }
                    if (valid) return l;
                }
            }
        }
        return 1;
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-change-the-final-value-of-expression/

You are given a valid boolean expression as a string expression consisting of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR operator),'(', and ')'.

For example, "()1|1" and "(1)&()" are not valid while "1", "(((1))|(0))", and "1|(0&(1))" are valid expressions.
Return the minimum cost to change the final value of the expression.

For example, if expression = "1|1|(0&0)&1", its value is 1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1. We want to apply operations so that the new expression evaluates to 0.
The cost of changing the final value of an expression is the number of operations performed on the expression. The types of operations are described as follows:

Turn a '1' into a '0'.
Turn a '0' into a '1'.
Turn a '&' into a '|'.
Turn a '|' into a '&'.
Note: '&' does not take precedence over '|' in the order of calculation. Evaluate parentheses first, then in left-to-right order.

 

Example 1:

Input: expression = "1&(0|1)"
Output: 1
Explanation: We can turn "1&(0|1)" into "1&(0&1)" by changing the '|' to a '&' using 1 operation.
The new expression evaluates to 0. 
Example 2:

Input: expression = "(0&0)&(0&0&0)"
Output: 3
Explanation: We can turn "(0&0)&(0&0&0)" into "(0|1)|(0&0&0)" using 3 operations.
The new expression evaluates to 1.
Example 3:

Input: expression = "(0|(1|0&1))"
Output: 1
Explanation: We can turn "(0|(1|0&1))" into "(0|(0|0&1))" using 1 operation.
The new expression evaluates to 0.
 

Constraints:

1 <= expression.length <= 105
expression only contains '1','0','&','|','(', and ')'
All parentheses are properly matched.
There will be no empty parentheses (i.e: "()" is not a substring of expression).

Result 表达式的解析结果，表达式的两端可以有括号，也可以不包含括号（不包含括号的表达式只有一个，就是最外层的表达式）
Result.v 表达式解析后的值，可以为0或1
Result.cost 表达式解析后的值要发生变化对应的the minimum cost，原来 0 变成 1 或者 原来 1 变成 0

class Solution
{
public:

    struct Result
    {
        bool v;
        int cost;
    };

    Result Parse(const char **p)
    {
        char op = '\0';
        bool first = true;
        Result res;
        while (**p != ')' && **p != '\0')
        {
            bool has_child = false;
            Result child;
            switch (**p)
            {
            case '0':
            case '1':
                child = {(**p - '0') == 1, 1};   // 1 change to 0 或者 0 change to 1, cost = 1
                has_child = true;
                break;
            case '&':
            case '|':
                op = **p;
                break;
            case '(':
                (*p)++;
                child = Parse(p);   // 递归返回后，*p 指向对应的 ')'
                has_child = true;
                break;
            }
            (*p)++;
            if (!has_child) continue;
            if (first)
            {
                res = child;
                first = false;
                continue;
            }
            if (op == '&' && child.v == 0)
            {
                if (res.v == 0)    // 0&0 change to 1，需要修改为1 | 0 或者 0 | 1，如果改为1 & 1，res.cost + child.cost >= min(res.cost + 1, child.cost + 1)
                {
                    res.cost = min(res.cost + 1, child.cost + 1);
                }
                else
                {
                    // 1&0 change to 1，需要修改为1 | 0
                    res.cost = 1;
                }
                res.v = 0;
            }
            else if (op == '&' && child.v == 1)
            {
                if (res.v == 0)   // 0&1 change to 1，需要修改为0 | 1
                {
                    res.cost = 1;
                }
                else
                {
                    res.cost = min(res.cost, child.cost);   // 1&1 change to 0，需要修改为1 & 0 或者 0 & 1
                }
            }
            else if (op == '|' && child.v == 0)
            {
                if (res.v == 0)    // 0|0 change to 1，需要修改为1 | 0 或者 0 | 1
                {
                    res.cost = min(res.cost, child.cost);
                }
                else
                {
                    res.cost = 1;   // 1|0 change to 0，需要修改为1 & 0
                }
            }
            else      // op == |, cv == 1
            {
                if (res.v == 0)   // 0|1 change to 0，需要修改为 0 & 1
                {
                    res.cost = 1;
                }
                else
                {
                    res.cost = min(res.cost + 1, child.cost + 1);   // 1|1 change to 0，需要修改为1 & 0 或者 0 & 1
                }
                res.v = 1;
            }
        }
        return res;
    }

    int minOperationsToFlip(string e)
    {
        const char *s = e.c_str();
        return Parse(&s).cost;
    }
};


// Source https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/

You are given an array of strings words (0-indexed).

In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].

Return true if you can make every string in words equal using any number of operations, and false otherwise.

 

Example 1:

Input: words = ["abc","aabc","bc"]
Output: true
Explanation: Move the first 'a' in words[1] to the front of words[2],
to make words[1] = "abc" and words[2] = "abc".
All the strings are now equal to "abc", so return true.
Example 2:

Input: words = ["ab","a"]
Output: false
Explanation: It is impossible to make all the strings equal using the operation.
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 100
words[i] consists of lowercase English letters.

class Solution
{
public:
    bool makeEqual(vector<string> &words)
    {
        int n = words.size();
        if (n <= 1) return true;
        int arr[26] = {0};
        for (auto &str : words)
        {
            for (auto ch : str) arr[ch - 'a']++;
        }
        for (int i = 0; i < 26; ++i)
        {
            if (arr[i] == 0) continue;
            if (arr[i] % n) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-removable-characters/

You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).

You want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. 
More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.

Return the maximum k you can choose such that p is still a subsequence of s after the removals.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

 

Example 1:

Input: s = "abcacb", p = "ab", removable = [3,1,0]
Output: 2
Explanation: After removing the characters at indices 3 and 1, "abcacb" becomes "accb".
"ab" is a subsequence of "accb".
If we remove the characters at indices 3, 1, and 0, "abcacb" becomes "ccb", and "ab" is no longer a subsequence.
Hence, the maximum k is 2.
Example 2:

Input: s = "abcbddddd", p = "abcd", removable = [3,2,1,4,5,6]
Output: 1
Explanation: After removing the character at index 3, "abcbddddd" becomes "abcddddd".
"abcd" is a subsequence of "abcddddd".
Example 3:

Input: s = "abcab", p = "abc", removable = [0,1,2,3,4]
Output: 0
Explanation: If you remove the first index in the array removable, "abc" is no longer a subsequence.
 

Constraints:

1 <= p.length <= s.length <= 105
0 <= removable.length < s.length
0 <= removable[i] < s.length
p is a subsequence of s.
s and p both consist of lowercase English letters.
The elements in removable are distinct.

class Solution
{
public:
    int n, m;

    bool check(string s, string p, vector<int> &removable, int k)
    {
        for(int i = 0; i < k; ++i)
        {
            s[removable[i]] = '.';
        }
        int j = 0;
        for(int i = 0; i < n && j < m; ++i)
        {
            if(s[i] == p[j]) ++j;
        }
        return j == m;
    }

    int maximumRemovals(string s, string p, vector<int> &removable)
    {
        n = s.length();
        m = p.length();
        int l = 0, r = removable.size();
        int ans = 0;
        while(l <= r)
        {
            int mid = l + (r - l) / 2;
            if(check(s, p, removable, mid))
            {
                ans = mid;
                l = mid + 1;
            }
            else
                r = mid - 1;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/merge-triplets-to-form-target-triplet/

A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. 
You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.

To obtain target, you may apply the following operation on triplets any number of times (possibly zero):

Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)].
For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5], triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5].
Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.

 

Example 1:

Input: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]
Output: true
Explanation: Perform the following operations:
- Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]]. Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4],[2,7,5]]
The target triplet [2,7,5] is now an element of triplets.
Example 2:

Input: triplets = [[3,4,5],[4,5,6]], target = [3,2,5]
Output: false
Explanation: It is impossible to have [3,2,5] as an element because there is no 2 in any of the triplets.
Example 3:

Input: triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]
Output: true
Explanation: Perform the following operations:
- Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]. Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]].
- Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]].
The target triplet [5,5,5] is now an element of triplets.
 

Constraints:

1 <= triplets.length <= 105
triplets[i].length == target.length == 3
1 <= ai, bi, ci, x, y, z <= 1000

class Solution
{
public:
    bool mergeTriplets(vector<vector<int>> &triplets, vector<int> &target)
    {
        vector<int> ans(3, 0);
        for (auto &v : triplets)
        {
            if(v[0] <= target[0] && v[1] <= target[1] && v[2] <= target[2])
            {
                ans[0] = max(v[0], ans[0]);
                ans[1] = max(v[1], ans[1]);
                ans[2] = max(v[2], ans[2]);
            }
        }
        if(ans == target) return true;
        return false;
    }
};


// Source https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/

There is a tournament where n players are participating. The players are standing in a single row and are numbered from 1 to n based on their initial standing position 
(player 1 is the first player in the row, player 2 is the second player in the row, etc.).

The tournament consists of multiple rounds (starting from round number 1). In each round, the ith player from the front of the row competes against the ith player from the end of the row, 
and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.

For example, if the row consists of players 1, 2, 4, 6, 7
Player 1 competes against player 7.
Player 2 competes against player 6.
Player 4 automatically advances to the next round.
After each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order).

The players numbered firstPlayer and secondPlayer are the best in the tournament. They can win against any other player before they compete against each other. 
If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round.

Given the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, 
the earliest possible round number and the latest possible round number in which these two players will compete against each other, respectively.

 

Example 1:

Input: n = 11, firstPlayer = 2, secondPlayer = 4
Output: [3,4]
Explanation:
One possible scenario which leads to the earliest round number:
First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
Second round: 2, 3, 4, 5, 6, 11
Third round: 2, 3, 4
One possible scenario which leads to the latest round number:
First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
Second round: 1, 2, 3, 4, 5, 6
Third round: 1, 2, 4
Fourth round: 2, 4
Example 2:

Input: n = 5, firstPlayer = 1, secondPlayer = 5
Output: [1,1]
Explanation: The players numbered 1 and 5 compete in the first round.
There is no way to make them compete in any other round.
 

Constraints:

2 <= n <= 28
1 <= firstPlayer < secondPlayer <= n

n 最大为28，i >= 0 && i <=27，mask 的第 i 位 为1表示 i + 1 对应的player参与第 round 轮比赛，mask 的第 i 位 为0 表示 i + 1 对应的player在第 round 轮比赛之前已经输掉
l 记录 参与第 round 轮比赛且还没有和其他人PK过，mask中位置 i 最大的选手
r 记录 参与第 round 轮比赛且还没有和其他人PK过，mask中位置 i 最小的选手

class Solution
{
public:
    int f, s;
    int maxRound, minRound;

    void dfs(int l, int r, int mask, int round)
    {
        if (l <= r)
        {
            dfs(1 << 27, mask & -mask, mask, round + 1);   // 第 round 轮比赛可以结束，开始第 round + 1 轮比赛，mask & -mask 求出 mask 中位置 i 最小的 1
        }
        else if (l & ~mask)
        {
            dfs(l >> 1, r, mask, round);   // 第 round 轮比赛，l 对应的选手在先前的比赛中已经输掉了，跳过当前的 l
        }
        else if (l & s && r & f)   //  第 round 轮比赛，l 对应 secondPlayer，r 对应 firstPlayer，更新maxans，minans，不用再进行后续的PK
        {
            maxRound = max(maxRound, round);
            minRound = min(minRound, round);
        }
        else
        {
            int rm = mask & ~((r << 1) - 1);   // 第 round 轮比赛，r 对应的选手，mask中位置 0 ... i 修改为0，把结果赋给rm（原先的mask并没有被修改）
            if (l & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ l, round);   // l不是firstPlayer，也不是secondPlayer，l >> 1 求出下一个要参与PK的 l，rm & -rm 求出下一个要参与PK的 r，mask ^ l 表示 l 输，r 赢
            if (r & ~(f | s)) dfs(l >> 1, rm & -rm, mask ^ r, round);   // r不是firstPlayer，也不是secondPlayer，l >> 1 求出下一个要参与PK的 l，rm & -rm 求出下一个要参与PK的 r，mask ^ r 表示 l 赢，r 输
        }
    }

    vector<int> earliestAndLatest(int n, int f, int s)
    {
        this->f = 1 << (f - 1), this->s = 1 << (s - 1);
        maxRound = INT_MIN;
        minRound = INT_MAX;
        dfs(1 << 27, 1, (1 << n) - 1, 1);
        return {minRound, maxRound};
    }
};


// Source https://leetcode.com/problems/find-a-peak-element-ii/

A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.

Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].

You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.

You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.

 

Example 1:



Input: mat = [[1,4],[3,2]]
Output: [0,1]
Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.
Example 2:



Input: mat = [[10,20,15],[21,30,14],[7,16,32]]
Output: [1,1]
Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 500
1 <= mat[i][j] <= 105
No two adjacent cells are equal.

class Solution
{
public:
    int visited[505][505];

    vector<int> findPeakGrid(vector<vector<int>> &mat)
    {
        int dx[4] = {1, 0, -1, 0};
        int dy[4] = {0, -1, 0, 1};
        priority_queue<pair<int, pair<int, int>>> pq;
        int rows = mat.size();
        int cols = mat[0].size();
        pq.push({mat[0][0], {0, 0}});
        visited[0][0] = 1;
        while(!pq.empty())
        {
            auto [val, p] = pq.top();
            auto [i, j] = p;
            int cnt = 0;
            for(int k = 0; k < 4; k++)
            {
                int x = i + dx[k];
                int y = j + dy[k];
                if(x < 0 || y < 0 || x >= rows || y >= cols || mat[x][y] < val)
                    continue;
                cnt++;
                if (visited[x][y] == 0)
                {
                    pq.push({mat[x][y], {x, y}});
                    visited[x][y] = 1;
                }
            }
            if(cnt == 0) return {i, j};
        }
        return {-1, -1};
    }
};


// Source https://leetcode.com/problems/largest-odd-number-in-string/

You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: num = "52"
Output: "5"
Explanation: The only non-empty substrings are "5", "2", and "52". "5" is the only odd number.
Example 2:

Input: num = "4206"
Output: ""
Explanation: There are no odd numbers in "4206".
Example 3:

Input: num = "35427"
Output: "35427"
Explanation: "35427" is already an odd number.
 

Constraints:

1 <= num.length <= 105
num only consists of digits and does not contain any leading zeros.

class Solution
{
public:
    string largestOddNumber(string num)
    {
        int n = num.length();
        for (int i = n - 1; i >= 0; --i)
        {
            if ((num[i] - '0') % 2) return num;
            num.pop_back();
        }
        return "";
    }
};


// Source https://leetcode.com/problems/the-number-of-full-rounds-you-have-played/

You are participating in an online chess tournament. There is a chess round that starts every 15 minutes. The first round of the day starts at 00:00, and after every 15 minutes, a new round starts.

For example, the second round starts at 00:15, the fourth round starts at 00:45, and the seventh round starts at 01:30.
You are given two strings loginTime and logoutTime where:

loginTime is the time you will login to the game, and
logoutTime is the time you will logout from the game.
If logoutTime is earlier than loginTime, this means you have played from loginTime to midnight and from midnight to logoutTime.

Return the number of full chess rounds you have played in the tournament.

Note: All the given times follow the 24-hour clock. That means the first round of the day starts at 00:00 and the last round of the day starts at 23:45.

 

Example 1:

Input: loginTime = "09:31", logoutTime = "10:14"
Output: 1
Explanation: You played one full round from 09:45 to 10:00.
You did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began.
You did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended.
Example 2:

Input: loginTime = "21:30", logoutTime = "03:00"
Output: 22
Explanation: You played 10 full rounds from 21:30 to 00:00 and 12 full rounds from 00:00 to 03:00.
10 + 12 = 22.
 

Constraints:

loginTime and logoutTime are in the format hh:mm.
00 <= hh <= 23
00 <= mm <= 59
loginTime and logoutTime are not equal.

class Solution
{
public:
    int numberOfRounds(string startTime, string finishTime)
    {
        int startHour, startMin, stopHour, stopMin;

        startHour = stoi(startTime.substr(0, 2));
        startMin = stoi(startTime.substr(3, 2));
        stopHour = stoi(finishTime.substr(0, 2));
        stopMin = stoi(finishTime.substr(3, 2));

        int start = startHour * 60 + startMin;
        int stop = stopHour * 60 + stopMin;

        if (start > stop)
        {
            stop += 24 * 60;
        }

        start = (start / 15) + (start % 15 > 0);
        stop /= 15;

        return max(stop - start, 0);
    }
};


// Source https://leetcode.com/problems/count-sub-islands/

You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). 
An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.

Return the number of islands in grid2 that are considered sub-islands.

 

Example 1:


Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
Output: 3
Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.
Example 2:


Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
Output: 2 
Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.
 

Constraints:

m == grid1.length == grid2.length
n == grid1[i].length == grid2[i].length
1 <= m, n <= 500
grid1[i][j] and grid2[i][j] are either 0 or 1.

class Solution
{
public:
    int m, n;

    void dfs(vector<vector<int>> &grid2, vector<vector<int>> &grid1, int i, int j, bool &status)
    {
        if(i < m && i >= 0 && j < n && j >= 0 && grid2[i][j] == 1)
        {
            if(grid1[i][j] == 0)
            {
                status = false;
            }
            grid2[i][j] = 0;
            dfs(grid2, grid1, i, j + 1, status);
            dfs(grid2, grid1, i, j - 1, status);
            dfs(grid2, grid1, i - 1, j, status);
            dfs(grid2, grid1, i + 1, j, status);
        }
    }

    int countSubIslands(vector<vector<int>> &grid1, vector<vector<int>> &grid2)
    {
        m = grid1.size();
        n = grid1[0].size();
        int count = 0;
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(grid2[i][j] == 1)
                {
                    bool status = true;
                    dfs(grid2, grid1, i, j, status);
                    if(status == true) count++;
                }
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/minimum-absolute-difference-queries/

The minimum absolute difference of an array a is defined as the minimum value of |a[i] - a[j]|, where 0 <= i < j < a.length and a[i] != a[j]. 
If all elements of a are the same, the minimum absolute difference is -1.

For example, the minimum absolute difference of the array [5,2,3,7,2] is |2 - 3| = 1. Note that it is not 0 because a[i] and a[j] must be different.
You are given an integer array nums and the array queries where queries[i] = [li, ri]. 
For each query i, compute the minimum absolute difference of the subarray nums[li...ri] containing the elements of nums between the 0-based indices li and ri (inclusive).

Return an array ans where ans[i] is the answer to the ith query.

A subarray is a contiguous sequence of elements in an array.

The value of |x| is defined as:

x if x >= 0.
-x if x < 0.
 

Example 1:

Input: nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]]
Output: [2,1,4,1]
Explanation: The queries are processed as follows:
- queries[0] = [0,1]: The subarray is [1,3] and the minimum absolute difference is |1-3| = 2.
- queries[1] = [1,2]: The subarray is [3,4] and the minimum absolute difference is |3-4| = 1.
- queries[2] = [2,3]: The subarray is [4,8] and the minimum absolute difference is |4-8| = 4.
- queries[3] = [0,3]: The subarray is [1,3,4,8] and the minimum absolute difference is |3-4| = 1.
Example 2:

Input: nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]]
Output: [-1,1,1,3]
Explanation: The queries are processed as follows:
- queries[0] = [2,3]: The subarray is [2,2] and the minimum absolute difference is -1 because all the
  elements are the same.
- queries[1] = [0,2]: The subarray is [4,5,2] and the minimum absolute difference is |4-5| = 1.
- queries[2] = [0,5]: The subarray is [4,5,2,2,7,10] and the minimum absolute difference is |4-5| = 1.
- queries[3] = [3,5]: The subarray is [2,7,10] and the minimum absolute difference is |7-10| = 3.
 

Constraints:

2 <= nums.length <= 105
1 <= nums[i] <= 100
1 <= queries.length <= 2 * 104
0 <= li < ri < nums.length

class Solution
{
public:
    vector<int> minDifference(vector<int> &nums, vector<vector<int>> &queries)
    {
        int n = nums.size();
        vector<set<int>> vec(110);
        for(int i = 0; i < n; i++)
        {
            vec[nums[i]].insert(i);
        }
        vector<int> ans;
        ans.reserve(queries.size());
        for(auto &query : queries)
        {
            int l = query[0];
            int r = query[1];
            int diff = INT_MAX;
            int prev = -1;
            for(int i = 1; i <= 100; i++)
            {
                auto itr = vec[i].lower_bound(l);
                if(itr != vec[i].end() && *itr <= r)
                {
                    if(prev == -1)
                    {
                        prev = i;
                    }
                    else
                    {
                        diff = min(diff, i - prev);
                        prev = i;
                    }
                }
            }
            if(diff == INT_MAX)
            {
                ans.push_back(-1);
            }
            else
            {
                ans.push_back(diff);
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/

Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true.

The array nums is strictly increasing if nums[i - 1] < nums[i] for each index (1 <= i < nums.length).

 

Example 1:

Input: nums = [1,2,10,5,7]
Output: true
Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].
[1,2,5,7] is strictly increasing, so return true.
Example 2:

Input: nums = [2,3,1,2]
Output: false
Explanation:
[3,1,2] is the result of removing the element at index 0.
[2,1,2] is the result of removing the element at index 1.
[2,3,2] is the result of removing the element at index 2.
[2,3,1] is the result of removing the element at index 3.
No resulting array is strictly increasing, so return false.
Example 3:

Input: nums = [1,1,1]
Output: false
Explanation: The result of removing any element is [1,1].
[1,1] is not strictly increasing, so return false.
 

Constraints:

2 <= nums.length <= 1000
1 <= nums[i] <= 1000

class Solution
{
public:
    bool canBeIncreasing(vector<int> &nums)
    {
        vector<int> lis;
        int count = 0;
        for(auto val : nums)
        {
            auto itr = lower_bound(lis.begin(), lis.end(), val);
            if(itr == lis.end())
            {
                lis.push_back(val);
            }
            else
            {
                *itr = val;
                if (++count > 1) return false;
            }            
        }
        return true;
    }
};


// Source https://leetcode.com/problems/remove-all-occurrences-of-a-substring/

Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed:

Find the leftmost occurrence of the substring part and remove it from s.
Return s after removing all occurrences of part.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: s = "daabcbaabcbc", part = "abc"
Output: "dab"
Explanation: The following operations are done:
- s = "daabcbaabcbc", remove "abc" starting at index 2, so s = "dabaabcbc".
- s = "dabaabcbc", remove "abc" starting at index 4, so s = "dababc".
- s = "dababc", remove "abc" starting at index 3, so s = "dab".
Now s has no occurrences of "abc".
Example 2:

Input: s = "axxxxyyyyb", part = "xy"
Output: "ab"
Explanation: The following operations are done:
- s = "axxxxyyyyb", remove "xy" starting at index 4 so s = "axxxyyyb".
- s = "axxxyyyb", remove "xy" starting at index 3 so s = "axxyyb".
- s = "axxyyb", remove "xy" starting at index 2 so s = "axyb".
- s = "axyb", remove "xy" starting at index 1 so s = "ab".
Now s has no occurrences of "xy".
 

Constraints:

1 <= s.length <= 1000
1 <= part.length <= 1000
s​​​​​​ and part consists of lowercase English letters.

class Solution
{
public:
    string removeOccurrences(string s, string part)
    {
        int len = part.length();
        int pos = s.find(part);
        while(pos != -1)
        {
            s.erase(pos, len);
            pos = s.find(part);
        }
        return s;
    }
};


// Source https://leetcode.com/problems/maximum-alternating-subsequence-sum/

The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices.

For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4.
Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence).

A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. 
For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not.

 

Example 1:

Input: nums = [4,2,5,3]
Output: 7
Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.
Example 2:

Input: nums = [5,6,7,8]
Output: 8
Explanation: It is optimal to choose the subsequence [8] with alternating sum 8.
Example 3:

Input: nums = [6,2,1,2,4,5]
Output: 10
Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105

dp0[i] 表示从nums[0 ... i] 中选择的子序列长度为偶数时的最大交替和
如果nums[i] 不参与到最佳子序列中，则dp0[i] = dp0[i-1]
如果nums[i] 参与到最佳子序列中，则dp0[i] = dp1[i-1] - nums[i]（此时nums[i]是最佳子序列的最后一个元素，最佳子序列长度为偶数时，最后一个元素下标为奇数）
dp0[i] = max(dp0[i-1], dp1[i-1] - nums[i])
dp1[i] 表示从nums[0 ... i] 中选择的子序列长度为奇数时的最大交替和
如果nums[i] 不参与到最佳子序列中，则dp1[i] = dp1[i-1]
如果nums[i] 参与到最佳子序列中，则dp1[i] = dp0[i-1] + nums[i]（此时nums[i]是最佳子序列的最后一个元素，最佳子序列长度为奇数时，最后一个元素下标为偶数）
dp1[i] = max(dp1[i-1], dp0[i-1] + nums[i])

dp0[0] = 0
dp1[0] = nums[0]

数组 [4,2,5,3] 的交替和为 4 - 2 + 5 - 3 

class Solution
{
public:
    long long maxAlternatingSum(vector<int> &nums)
    {
        int n = nums.size();
        vector<long long> dp0(n, 0),  dp1(n, 0);
        dp1[0] = nums[0];
        for(int i = 1; i < n; ++i)
        {
            dp0[i] = max(dp0[i - 1], dp1[i - 1] - nums[i]);
            dp1[i] = max(dp1[i - 1], dp0[i - 1] + nums[i]);
        }
        return max(dp0[n - 1], dp1[n - 1]);
    }
};


// Source https://leetcode.com/problems/design-movie-rental-system/

You have a movie renting company consisting of n shops. You want to implement a renting system that supports searching for, booking, and returning movies. 
The system should also support generating a report of the currently rented movies.

Each movie is given as a 2D integer array entries where entries[i] = [shopi, moviei, pricei] indicates that there is a copy of movie moviei at shop shopi with a rental price of pricei. 
Each shop carries at most one copy of a movie moviei.

The system should support the following functions:

Search: Finds the cheapest 5 shops that have an unrented copy of a given movie. The shops should be sorted by price in ascending order, 
and in case of a tie, the one with the smaller shopi should appear first. If there are less than 5 matching shops, then all of them should be returned. 
If no shop has an unrented copy, then an empty list should be returned.
Rent: Rents an unrented copy of a given movie from a given shop.
Drop: Drops off a previously rented copy of a given movie at a given shop.
Report: Returns the cheapest 5 rented movies (possibly of the same movie ID) as a 2D list res where res[j] = [shopj, moviej] describes that the jth cheapest rented movie moviej was rented from the shop shopj. 
The movies in res should be sorted by price in ascending order, and in case of a tie, the one with the smaller shopj should appear first, 
and if there is still tie, the one with the smaller moviej should appear first. If there are fewer than 5 rented movies, then all of them should be returned. 
If no movies are currently being rented, then an empty list should be returned.
Implement the MovieRentingSystem class:

MovieRentingSystem(int n, int[][] entries) Initializes the MovieRentingSystem object with n shops and the movies in entries.
List<Integer> search(int movie) Returns a list of shops that have an unrented copy of the given movie as described above.
void rent(int shop, int movie) Rents the given movie from the given shop.
void drop(int shop, int movie) Drops off a previously rented movie at the given shop.
List<List<Integer>> report() Returns a list of cheapest rented movies as described above.
Note: The test cases will be generated such that rent will only be called if the shop has an unrented copy of the movie, and drop will only be called if the shop had previously rented out the movie.

 

Example 1:

Input
["MovieRentingSystem", "search", "rent", "rent", "report", "drop", "search"]
[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]
Output
[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]

Explanation
MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);
movieRentingSystem.search(1);  // return [1, 0, 2], Movies of ID 1 are unrented at shops 1, 0, and 2. Shop 1 is cheapest; shop 0 and 2 are the same price, so order by shop number.
movieRentingSystem.rent(0, 1); // Rent movie 1 from shop 0. Unrented movies at shop 0 are now [2,3].
movieRentingSystem.rent(1, 2); // Rent movie 2 from shop 1. Unrented movies at shop 1 are now [1].
movieRentingSystem.report();   // return [[0, 1], [1, 2]]. Movie 1 from shop 0 is cheapest, followed by movie 2 from shop 1.
movieRentingSystem.drop(1, 2); // Drop off movie 2 at shop 1. Unrented movies at shop 1 are now [1,2].
movieRentingSystem.search(2);  // return [0, 1]. Movies of ID 2 are unrented at shops 0 and 1. Shop 0 is cheapest, followed by shop 1.
 

Constraints:

1 <= n <= 3 * 105
1 <= entries.length <= 105
0 <= shopi < n
1 <= moviei, pricei <= 104
Each shop carries at most one copy of a movie moviei.
At most 105 calls in total will be made to search, rent, drop and report.

class MovieRentingSystem
{
public:
    unordered_map<int, unordered_map<int, int>> shop;
    unordered_map<int, set<pair<int, int>>> movie;
    set<tuple<int, int, int>> drp;

    MovieRentingSystem(int n, vector<vector<int>> &entries)
    {
        for(auto &v : entries)
        {
            shop[v[0]][v[1]] = v[2];
            movie[v[1]].insert({v[2], v[0]});
        }
    }

    vector<int> search(int mv)
    {
        int a = movie[mv].size();
        int n = min(5, a);
        vector<int> ans;
        for(auto p : movie[mv])
        {
            if(n == 0)
            {
                break;
            }
            ans.push_back(p.second);
            n--;
        }
        return ans;
    }

    void rent(int shp, int mv)
    {
        int pr = shop[shp][mv];
        movie[mv].erase({pr, shp});
        drp.insert({pr, shp, mv});
    }

    void drop(int shp, int mv)
    {
        int pr = shop[shp][mv];
        drp.erase({pr, shp, mv});
        movie[mv].insert({pr, shp});
    }

    vector<vector<int>> report()
    {
        int a = drp.size();
        int n = min(5, a);
        vector<vector<int>> ans;
        for(auto t : drp)
        {
            if(n== 0)
            {
                break;
            }
            ans.push_back({get<1>(t), get<2>(t)});
            n--;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-product-difference-between-two-pairs/

The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).

For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

Return the maximum such product difference.

 

Example 1:

Input: nums = [5,6,2,7,4]
Output: 34
Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).
The product difference is (6 * 7) - (2 * 4) = 34.
Example 2:

Input: nums = [4,2,5,9,7,4,8]
Output: 64
Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).
The product difference is (9 * 8) - (2 * 4) = 64.
 

Constraints:

4 <= nums.length <= 104
1 <= nums[i] <= 104

class Solution
{
public:
    int maxProductDifference(vector<int> &nums)
    {
        sort(nums.begin(), nums.end());
        return nums[nums.size() - 1] * nums[nums.size() - 2] - nums[0] * nums[1];
    }
};


// Source https://leetcode.com/problems/cyclically-rotating-a-grid/

You are given an m x n integer matrix grid​​​, where m and n are both even integers, and an integer k.

The matrix is composed of several layers, which is shown in the below image, where each color is its own layer:



A cyclic rotation of the matrix is done by cyclically rotating each layer in the matrix. To cyclically rotate a layer once, 
each element in the layer will take the place of the adjacent element in the counter-clockwise direction. An example rotation is shown below:


Return the matrix after applying k cyclic rotations to it.

 

Example 1:


Input: grid = [[40,10],[30,20]], k = 1
Output: [[10,20],[40,30]]
Explanation: The figures above represent the grid at every state.
Example 2:

  
Input: grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2
Output: [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]
Explanation: The figures above represent the grid at every state.
 

Constraints:

m == grid.length
n == grid[i].length
2 <= m, n <= 50
Both m and n are even integers.
1 <= grid[i][j] <= 5000
1 <= k <= 109

class Solution
{
public:
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};

    vector<vector<int>> rotateGrid(vector<vector<int>> &grid, int k)
    {
        int m = grid.size(), n = grid[0].size();
        int i0 = 0, i1 = m - 1, j0 = 0, j1 = n - 1;
        while (i0 < i1 && j0 < j1)
        {
            rotate(grid, k, i0, i1, j0, j1);
            i0++, j0++, i1--, j1--;
        }
        return grid;
    }

    void rotate(vector<vector<int>> &grid, int k, int i0, int i1, int j0, int j1)
    {
        int period = (i1 - i0 + 1) * 2 + (j1 - j0 + 1) * 2 - 4;
        k %= period;
        vector<int> vec(period, 0);
        int i = i0, j = j0, d = 0;
        for (int f = 0; f < period; ++f)
        {
            vec[f] = grid[i][j];
            if (i + dx[d] < i0 || i + dx[d] > i1 || j + dy[d] < j0 || j + dy[d] > j1)
                d = (d + 1) % 4;
            i += dx[d], j += dy[d];
        }
        i = i0, j = j0, d = 0;
        for (int f = 0; f < period; ++f)
        {
            grid[i][j] = vec[k];
            if (i + dx[d] < i0 || i + dx[d] > i1 || j + dy[d] < j0 || j + dy[d] > j1)
                d = (d + 1) % 4;
            i += dx[d], j += dy[d];
            k = (k + 1) % period;
        }
    }
};


// Source https://leetcode.com/problems/number-of-wonderful-substrings/

A wonderful string is a string where at most one letter appears an odd number of times.

For example, "ccjjc" and "abab" are wonderful, but "ab" is not.
Given a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. 
If the same substring appears multiple times in word, then count each occurrence separately.

A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: word = "aba"
Output: 4
Explanation: The four wonderful substrings are underlined below:
- "aba" -> "a"
- "aba" -> "b"
- "aba" -> "a"
- "aba" -> "aba"
Example 2:

Input: word = "aabb"
Output: 9
Explanation: The nine wonderful substrings are underlined below:
- "aabb" -> "a"
- "aabb" -> "aa"
- "aabb" -> "aab"
- "aabb" -> "aabb"
- "aabb" -> "a"
- "aabb" -> "abb"
- "aabb" -> "b"
- "aabb" -> "bb"
- "aabb" -> "b"
Example 3:

Input: word = "he"
Output: 2
Explanation: The two wonderful substrings are underlined below:
- "he" -> "h"
- "he" -> "e"
 

Constraints:

1 <= word.length <= 105
word consists of lowercase English letters from 'a' to 'j'.

class Solution
{
public:
    long long wonderfulSubstrings(string word)
    {
        int mp[1024] = {0};
        mp[0] = 1;
        long long count = 0, mask = 0;
        for(auto ch : word)
        {
            mask ^= 1 << (ch - 'a');
            count += mp[mask];
            for(int i = 0; i < 10; i++) count += mp[mask ^ (1 << i)];
            mp[mask]++;
        }
        return count;
    }
};


// Source https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/

You are an ant tasked with adding n new rooms numbered 0 to n-1 to your colony. You are given the expansion plan as a 0-indexed integer array of length n, prevRoom, 
where prevRoom[i] indicates that you must build room prevRoom[i] before building room i, and these two rooms must be connected directly. 
Room 0 is already built, so prevRoom[0] = -1. The expansion plan is given such that once all the rooms are built, every room will be reachable from room 0.

You can only build one room at a time, and you can travel freely between rooms you have already built only if they are connected. 
You can choose to build any room as long as its previous room is already built.

Return the number of different orders you can build all the rooms in. Since the answer may be large, return it modulo 109 + 7.

 

Example 1:


Input: prevRoom = [-1,0,1]
Output: 1
Explanation: There is only one way to build the additional rooms: 0 → 1 → 2
Example 2:


Input: prevRoom = [-1,0,0,1,2]
Output: 6
Explanation:
The 6 ways are:
0 → 1 → 3 → 2 → 4
0 → 2 → 4 → 1 → 3
0 → 1 → 2 → 3 → 4
0 → 1 → 2 → 4 → 3
0 → 2 → 1 → 3 → 4
0 → 2 → 1 → 4 → 3
 

Constraints:

n == prevRoom.length
2 <= n <= 105
prevRoom[0] == -1
0 <= prevRoom[i] < n for all 1 <= i < n
Every room is reachable from room 0 once all the rooms are built.

ans[root] 表示构建以root为根节点的树（包含root对应的room和依赖于root的其他rooms）的方法数量
假设root的子节点有ch1, ch2, ... , ch9，sz[root] = m + 1，size[ch1] + size[ch2] + ... + size[ch9] = m
则ans[root] = 1 * ans[ch1] * ans[ch2] * ... * ans[ch9] * C(m, size[ch1]) * C(m-size[ch1], size[ch2]) * ... * C(size[ch9], size[ch9])
C(m, size[ch1]) 表示从m个位置中挑出size[ch1]个位置来放置以ch1为根节点的树

class Solution
{
public:
    const int mod = 1e9 + 7;

    vector<vector<int> > tree;
    vector<int> sz;
    vector<long long> fact, ans;

    void pre(int n)
    {
        fact.resize(n, 1);
        for(int i = 2; i < n; i++)
        {
            fact[i] = (fact[i - 1] * i) % mod;
        }
    }

    long long powmod(long long base, long long exponent)
    {
        long long ans = 1;
        while(exponent > 0)
        {
            if(exponent & 1) ans = (ans * base) % mod;
            base = (base * base) % mod;
            exponent >>= 1;
        }
        return ans;
    }

    void dfs(int root)
    {
        sz[root] = 1;
        long long prod1 = 1, prod2 = 1;
        for(auto ch : tree[root])
        {
            dfs(ch);
            sz[root] += sz[ch];
            ans[root] = (ans[root] * ans[ch]) % mod;
            prod1 = (prod1 * fact[sz[ch]]) % mod;
        }
        prod2 = fact[sz[root] - 1];
        ans[root] = (ans[root] * prod2) % mod;
        ans[root] = (ans[root] * powmod(prod1, mod - 2)) % mod;
    }

    int waysToBuildRooms(vector<int> &prevRoom)
    {
        int n = prevRoom.size();
        pre(n);
        tree.resize(n);
        ans.resize(n, 1);
        sz.resize(n, 0);
        for(int i = 1; i < n; i++)
        {
            int parent = prevRoom[i];
            tree[parent].push_back(i);
        }
        dfs(0);
        return ans[0];
    }
};


// Source https://leetcode.com/problems/build-array-from-permutation/

Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.

A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).

 

Example 1:

Input: nums = [0,2,1,5,3,4]
Output: [0,1,2,4,5,3]
Explanation: The array ans is built as follows: 
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]
Example 2:

Input: nums = [5,0,1,2,3,4]
Output: [4,5,0,1,2,3]
Explanation: The array ans is built as follows:
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
 

Constraints:

1 <= nums.length <= 1000
0 <= nums[i] < nums.length
The elements in nums are distinct.

class Solution
{
public:
    vector<int> buildArray(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> vec(n);
        for(int i = 0; i < n; i++)
        {
            vec[i] = nums[nums[i]];
        }
        return vec;
    }
};


// Source https://leetcode.com/problems/eliminate-maximum-number-of-monsters/

You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, 
where dist[i] is the initial distance in kilometers of the ith monster from the city.

The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, 
where speed[i] is the speed of the ith monster in kilometers per minute.

You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge.The weapon is fully charged at the very start.

You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, 
and the game ends before you can use your weapon.

Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.

 

Example 1:

Input: dist = [1,3,4], speed = [1,1,1]
Output: 3
Explanation:
In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.
After a minute, the distances of the monsters are [X,X,2]. You eliminate the thrid monster.
All 3 monsters can be eliminated.
Example 2:

Input: dist = [1,1,2,3], speed = [1,1,1,1]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,1,2], so you lose.
You can only eliminate 1 monster.
Example 3:

Input: dist = [3,2,4], speed = [5,3,2]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,2], so you lose.
You can only eliminate 1 monster.
 

Constraints:

n == dist.length == speed.length
1 <= n <= 105
1 <= dist[i], speed[i] <= 105

class Solution
{
public:
    int eliminateMaximum(vector<int> &dist, vector<int> &speed)
    {
        int n = dist.size();
        vector<double> time(n);
        for(int i = 0; i < n; i++)
        {
            time[i] = (double)dist[i] / speed[i];
        }
        sort(time.begin(), time.end());
        int count = 0;
        double currTime = 0.0;
        for(int i = 0; i < n; i++)
        {
            if(time[i] > currTime)
                count++;
            else
                return count;
            currTime += 1.0;
        }
        return count;
    }
};


// Source https://leetcode.com/problems/count-good-numbers/

A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).

For example, "2582" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. 
However, "3245" is not good because 3 is at an even index but is not even.
Given an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.

A digit string is a string consisting of digits 0 through 9 that may contain leading zeros.

 

Example 1:

Input: n = 1
Output: 5
Explanation: The good numbers of length 1 are "0", "2", "4", "6", "8".
Example 2:

Input: n = 4
Output: 400
Example 3:

Input: n = 50
Output: 564908303
 

Constraints:

1 <= n <= 1015

class Solution
{
public:
    const int mod = 1e9 + 7;

    long powmod(long a, long b)
    {
        long res = 1;
        while (b > 0)
        {
            if (b & 1) res = (res * a) % mod;
            a = (a * a) % mod;
            b >>= 1;
        }
        return res;
    }

    int countGoodNumbers(long long n)
    {
        return (powmod(4, n / 2) * powmod(5, (n + 1) / 2)) % mod;
    }
};


// Source https://leetcode.com/problems/longest-common-subpath/

There is a country of n cities numbered from 0 to n - 1. In this country, there is a road connecting every pair of cities.

There are m friends numbered from 0 to m - 1 who are traveling through the country. Each one of them will take a path consisting of some cities. 
Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively.

Given an integer n and a 2D integer array paths where paths[i] is an integer array representing the path of the ith friend, 
return the length of the longest common subpath that is shared by every friend's path, or 0 if there is no common subpath at all.

A subpath of a path is a contiguous sequence of cities within that path.

 

Example 1:

Input: n = 5, paths = [[0,1,2,3,4],
                       [2,3,4],
                       [4,0,1,2,3]]
Output: 2
Explanation: The longest common subpath is [2,3].
Example 2:

Input: n = 3, paths = [[0],[1],[2]]
Output: 0
Explanation: There is no common subpath shared by the three paths.
Example 3:

Input: n = 5, paths = [[0,1,2,3,4],
                       [4,3,2,1,0]]
Output: 1
Explanation: The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1.
 

Constraints:

1 <= n <= 105
m == paths.length
2 <= m <= 105
sum(paths[i].length) <= 105
0 <= paths[i][j] < n
The same city is not listed multiple times consecutively in paths[i].

class Solution
{
public:
    int longestCommonSubpath(int n, vector<vector<int>> &paths)
    {
        const int mod = 1e9 + 7;
        int ans = 0;
        int l = 1;
        int r = INT_MAX;
        for (auto &path : paths) r = min(r, (int)path.size());
        int base = 100001;
        while (l <= r)
        {
            int m = l + (r - l) / 2;
            unordered_map<int, vector<int>> hs;
            long long d = 1;
            for (int i = 0; i < m; ++i) { d = d * base % mod; }
            for (int i = 0; i < paths.size() && (i == 0 || !hs.empty()); ++i)
            {
                long long hash = 0;
                unordered_map<int, vector<int>> hs1;
                for (int j = 0; j < paths[i].size(); ++j)
                {
                    hash = (hash * base + paths[i][j]) % mod;
                    if (j >= m)
                    {
                        hash = (mod + hash - d * paths[i][j - m] % mod) % mod;
                    }
                    if (j >= m - 1)
                    {
                        if (i == 0)
                        {
                            hs1[hash].push_back(j + 1 - m);
                        }
                        else
                        {
                            if (hs.count(hash))
                            {
                                for (auto pos : hs[hash])
                                {
                                    if (equal(paths[0].begin() + pos, paths[0].begin() + pos + m, paths[i].begin() + j + 1 - m))
                                    {
                                        hs1[hash].push_back(pos);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                swap(hs, hs1);
            }
            if (hs.empty())
            {
                r = m - 1;
            }
            else
            {
                ans = m;
                l = m + 1;
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/count-square-sum-triples/

A square triple (a,b,c) is a triple where a, b, and c are integers and a2 + b2 = c2.

Given an integer n, return the number of square triples such that 1 <= a, b, c <= n.

 

Example 1:

Input: n = 5
Output: 2
Explanation: The square triples are (3,4,5) and (4,3,5).
Example 2:

Input: n = 10
Output: 4
Explanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).
 

Constraints:

1 <= n <= 250

class Solution
{
public:
    int countTriples(int n)
    {
        int count = 0;
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= n; j++)
            {
                double d = sqrt(pow(i, 2) + pow(j, 2));
                if(d == int(d) && d <= n)
                    count++;
            }
        }
        return count;
    }
};


// Source https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/

You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). 
You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.

In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. 
Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.

Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.

 

Example 1:


Input: maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
Output: 1
Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].
Initially, you are at the entrance cell [1,2].
- You can reach [1,0] by moving 2 steps left.
- You can reach [0,2] by moving 1 step up.
It is impossible to reach [2,3] from the entrance.
Thus, the nearest exit is [0,2], which is 1 step away.
Example 2:


Input: maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
Output: 2
Explanation: There is 1 exit in this maze at [1,2].
[1,0] does not count as an exit since it is the entrance cell.
Initially, you are at the entrance cell [1,0].
- You can reach [1,2] by moving 2 steps right.
Thus, the nearest exit is [1,2], which is 2 steps away.
Example 3:


Input: maze = [[".","+"]], entrance = [0,0]
Output: -1
Explanation: There are no exits in this maze.
 

Constraints:

maze.length == m
maze[i].length == n
1 <= m, n <= 100
maze[i][j] is either '.' or '+'.
entrance.length == 2
0 <= entrancerow < m
0 <= entrancecol < n
entrance will always be an empty cell.

class Solution
{
public:
    int visited[100][100];

    bool isValid(int i, int j, int m, int n)
    {
        if(i < 0 || j < 0 || i >= m || j >= n) return false;
        return true;
    }

    bool isExit(int i, int j, int m, int n)
    {
        if(i == 0 || i == m - 1 || j == 0 || j == n - 1) return true;
        return false;
    }

    int nearestExit(vector<vector<char>> &maze, vector<int> &entrance)
    {
        int m = maze.size();
        int n = maze[0].size();
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};
        queue<pair<int, int>> q;
        q.push({entrance[0], entrance[1]});
        visited[entrance[0]][entrance[1]] = 1;
        int ans = 0;
        while(!q.empty())
        {
            int sz = q.size();
            for(int i = 0; i < sz; ++i)
            {
                auto p = q.front();
                q.pop();
                int x = p.first;
                int y = p.second;
                for (int dir = 0; dir < 4; ++dir)
                {
                    int row = x + dx[dir];
                    int col = y + dy[dir];
                    if(isValid(row, col, m, n) && maze[row][col] == '.' && visited[row][col] == 0)
                    {
                        if(isExit(row, col, m, n)) return ans + 1;
                        visited[row][col] = 1;
                        q.push({row, col});
                    }
                }
            }
            ++ans;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/sum-game/

Alice and Bob take turns playing a game, with Alice starting first.

You are given a string num of even length consisting of digits and '?' characters. On each turn, a player will do the following if there is still at least one '?' in num:

Choose an index i where num[i] == '?'.
Replace num[i] with any digit between '0' and '9'.
The game ends when there are no more '?' characters in num.

For Bob to win, the sum of the digits in the first half of num must be equal to the sum of the digits in the second half. For Alice to win, the sums must not be equal.

For example, if the game ended with num = "243801", then Bob wins because 2+4+3 = 8+0+1. If the game ended with num = "243803", then Alice wins because 2+4+3 != 8+0+3.
Assuming Alice and Bob play optimally, return true if Alice will win and false if Bob will win.

 

Example 1:

Input: num = "5023"
Output: false
Explanation: There are no moves to be made.
The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3.
Example 2:

Input: num = "25??"
Output: true
Explanation: Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal.
Example 3:

Input: num = "?3295???"
Output: false
Explanation: It can be proven that Bob will always win. One possible outcome is:
- Alice replaces the first '?' with '9'. num = "93295???".
- Bob replaces one of the '?' in the right half with '9'. num = "932959??".
- Alice replaces one of the '?' in the right half with '2'. num = "9329592?".
- Bob replaces the last '?' in the right half with '7'. num = "93295927".
Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.
 

Constraints:

2 <= num.length <= 105
num.length is even.
num consists of only digits and '?'.

先统计字符串前、后一半的sum及问号数，然后分类讨论：
如果前后问号数相同，则当某个人把某一边的一个问号替换为x，另一个人可以把另一边的一个问号也替换为x
1、如果统计的前、后一半的sum相等则 Bob 胜（Alice starting first，每次Bob按照上述方法使得前、后一半的sum保持相等）
2、如果统计的前、后一半的sum不相等则 Alice 胜利
Alice starting first，最开始那次Alice在sum更大的那边加9，之后，中间每次Bob选择一个问号替换为x后，Alice选择把另一边的一个问号也替换为x，
Bob最后的那一次无论选择0到9中的哪一个，sum更大的那边还是更大

如果前后问号数不同，且前后问号数相加为奇数，则是Alice选择最后一个问号
1、如果选择最后一个问号时字符串前、后一半的sum已经相等，则最后那个问号可以替换为1到9中的任一个，然后字符串前、后一半的sum变为不相等，则 Alice 胜利
2、如果选择最后一个问号时字符串前、后一半的sum不相等，则最后那个问号可以替换为0，然后字符串前、后一半的sum仍然不相等，则 Alice 胜利

如果前后问号数不同，且前后问号数相加为偶数（相减也为偶数），则是Bob选择最后一个问号
1、数值和大的一侧问号数也多，前后不可能相等，Alice胜
Alice starting first，最开始那次Alice在sum更大问号数也多的那边加9，之后，中间每次Bob选择一个问号替换为x后，Alice选择把另一边的一个问号也替换为x，
剩余的那些问号无论选择0到9中的哪一个，sum更大的那边还是更大
2、数值和大的一侧问号数少，数值和小的一侧问号数多
当某个人把某一边的一个问号替换为x，另一个人可以把另一边的一个问号也替换为x，最后只剩下问号数多的那边还有问号（数值和小的那侧）
此时Alice把剩下的一个问号替换为x，Bob可以把剩下的另一个问号替换为9-x，最终数值和小的那侧增加cnt * 9，
a、如果diff == (cnt * 9)，则 Bob 胜
除了最开始的那次，中间每次Bob选择一个问号替换为x后，Alice选择另一个问号替换为9-x，则增加了(cnt - 1) * 9，现在考虑Alice最开始的那一次，Bob最后的那一次选择的值
b、如果diff > (cnt * 9)，则Alice最开始的那一次选择0，最终数值和小的那侧增加 0 + (cnt - 1) * 9 + m，其中m >=0 && m <= 9，可以看出增加的值 小于 diff，则 Alice 胜利
c、如果diff < (cnt * 9)，则Alice最开始的那一次选择9，最终数值和小的那侧增加 9 + (cnt - 1) * 9 + m，其中m >=0 && m <= 9，可以看出增加的值 大于 diff，则 Alice 胜利

9 - x + x= 9

class Solution
{
public:
    bool sumGame(string num)
    {
        int n = num.length();
        int lDigitSum = 0;
        int lQCount = 0;
        int rDigitSum = 0;
        int rQCount = 0;
        for(int i = 0; i < n / 2; ++i)
        {
            if(isdigit(num[i]))
            {
                lDigitSum += (num[i] - '0');
            }
            else
            {
                ++lQCount;
            }
        }

        for(int i = n / 2; i < n; ++i)
        {
            if(isdigit(num[i]))
            {
                rDigitSum += (num[i] - '0');
            }
            else
            {
                ++rQCount;
            }
        }

        if(lQCount == rQCount)
        {
            return (lDigitSum != rDigitSum);
        }

        if((lQCount + rQCount) % 2 == 1)
        {
            return true;
        }

        if( (lDigitSum > rDigitSum && lQCount > rQCount) &&
                (lDigitSum < rDigitSum && lQCount < rQCount) )
        {
            return true;
        }

        int cnt;
        int diff;
        if(lQCount > rQCount)
        {
            cnt = (lQCount - rQCount) / 2;
            diff = (rDigitSum - lDigitSum);
        }
        else
        {
            cnt = (rQCount - lQCount) / 2;
            diff = (lDigitSum - rDigitSum);
        }
        return (diff != (cnt * 9));
    }
};


// Source https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/

There is a country of n cities numbered from 0 to n - 1 where all the cities are connected by bi-directional roads. 
The roads are represented as a 2D integer array edges where edges[i] = [xi, yi, timei] denotes a road between cities xi and yi that takes timei minutes to travel. 
There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.

Each time you pass through a city, you must pay a passing fee. This is represented as a 0-indexed integer array passingFees of length n 
where passingFees[j] is the amount of dollars you must pay when you pass through city j.

In the beginning, you are at city 0 and want to reach city n - 1 in maxTime minutes or less. 
The cost of your journey is the summation of passing fees for each city that you passed through at some moment of your journey (including the source and destination cities).

Given maxTime, edges, and passingFees, return the minimum cost to complete your journey, or -1 if you cannot complete it within maxTime minutes.

 

Example 1:



Input: maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
Output: 11
Explanation: The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.
Example 2:



Input: maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
Output: 48
Explanation: The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.
You cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.
Example 3:

Input: maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3]
Output: -1
Explanation: There is no way to reach city 5 from city 0 within 25 minutes.
 

Constraints:

1 <= maxTime <= 1000
n == passingFees.length
2 <= n <= 1000
n - 1 <= edges.length <= 1000
0 <= xi, yi <= n - 1
1 <= timei <= 1000
1 <= passingFees[j] <= 1000 
The graph may contain multiple edges between two nodes.
The graph does not contain self loops.

class Solution
{
public:
    int minCost(int maxTime, vector<vector<int>> &edges, vector<int> &passingFees)
    {
        int n = passingFees.size();
        vector<vector<pair<int, int>>> adj(n);
        for(auto &e : edges)
        {
            adj[e[0]].push_back({e[1], e[2]});
            adj[e[1]].push_back({e[0], e[2]});
        }
        vector<int> dist(n, 1e9);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, n - 1});
        dist[n - 1] = 0;
        while(!pq.empty())
        {
            auto [time, node] = pq.top();
            pq.pop();
            if(dist[node] < time) continue;
            for(auto [prev, d] : adj[node])
            {
                if(time + d < dist[prev])
                {
                    dist[prev] = time + d;
                    pq.push({dist[prev], prev});
                }
            }
        }
        vector<pair<int, int>> cost(n, pair<int, int>(1e9, 1e9));//时间   费用
        queue<array<int, 3>> q;//点， 时间， 费用
        cost[0] = {0, passingFees[0]};
        q.push({0, 0, passingFees[0]});
        int res = 1e9;
        while(!q.empty())
        {
            auto s = q.front();
            q.pop();
            if(s[0] == n - 1 && s[1] <= maxTime) res = min(res, s[2]);
            for(auto [next, d] : adj[s[0]])
            {
                if((s[2] + passingFees[next] < cost[next].second || s[1] + d < cost[next].first) && s[1] + d + dist[next] <= maxTime)
                {
                    cost[next].first = min(cost[next].first, s[1] + d);
                    cost[next].second = min(cost[next].second, s[2] + passingFees[next]);
                    q.push({next, s[1] + d, s[2] + passingFees[next]});
                }
            }
        }
        if(res == 1e9) return -1;
        return res;
    }
};


// Source https://leetcode.com/problems/concatenation-of-array/

Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).

Specifically, ans is the concatenation of two nums arrays.

Return the array ans.

 

Example 1:

Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
Example 2:

Input: nums = [1,3,2,1]
Output: [1,3,2,1,1,3,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
 

Constraints:

n == nums.length
1 <= n <= 1000
1 <= nums[i] <= 1000

class Solution
{
public:
    vector<int> getConcatenation(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> vec(nums);
        vec.reserve(n + n);
        for(int i = 0; i < n; i++)
        {
            vec.push_back(nums[i]);
        }
        return vec;
    }
};


// Source https://leetcode.com/problems/unique-length-3-palindromic-subsequences/

Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".
 

Example 1:

Input: s = "aabca"
Output: 3
Explanation: The 3 palindromic subsequences of length 3 are:
- "aba" (subsequence of "aabca")
- "aaa" (subsequence of "aabca")
- "aca" (subsequence of "aabca")
Example 2:

Input: s = "adc"
Output: 0
Explanation: There are no palindromic subsequences of length 3 in "adc".
Example 3:

Input: s = "bbcbaba"
Output: 4
Explanation: The 4 palindromic subsequences of length 3 are:
- "bbb" (subsequence of "bbcbaba")
- "bcb" (subsequence of "bbcbaba")
- "bab" (subsequence of "bbcbaba")
- "aba" (subsequence of "bbcbaba")
 

Constraints:

3 <= s.length <= 105
s consists of only lowercase English letters.


palindromes of length three
第一个字符和第三个字符必须相同，第二个字符可以为任一字符
Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

class Solution
{
public:
    int countPalindromicSubsequence(string s)
    {
        int n = s.length();
        vector<int> first(26, -1);
        vector<int> last(26, -1);
        for(int i = 0; i < n; i++)
        {
            if(first[s[i] - 'a'] == -1)
                first[s[i] - 'a'] = i;
            last[s[i] - 'a'] = i;
        }
        int res = 0;
        for(int i = 0; i < 26; i++)
        {
            if(first[i] == -1) continue;
            int cnt = 0;
            vector<int> freq(26, 0);
            for(int j = first[i] + 1; j < last[i]; j++)
            {
                if(freq[s[j] - 'a'] == 0)
                {
                    freq[s[j] - 'a'] = 1;
                    cnt++;
                }
            }
            res += cnt;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/painting-a-grid-with-three-different-colors/

You are given two integers m and n. Consider an m x n grid where each cell is initially white. You can paint each cell red, green, or blue. All cells must be painted.

Return the number of ways to color the grid with no two adjacent cells having the same color. Since the answer can be very large, return it modulo 109 + 7.

 

Example 1:


Input: m = 1, n = 1
Output: 3
Explanation: The three possible colorings are shown in the image above.
Example 2:


Input: m = 1, n = 2
Output: 6
Explanation: The six possible colorings are shown in the image above.
Example 3:

Input: m = 5, n = 5
Output: 580986
 

Constraints:

1 <= m <= 5
1 <= n <= 1000

class Solution
{
public:
    vector<string>v;
    vector<vector<int>>adj;
    const int mod = 1e9 + 7;
    const string colors = "RGB";

    void get(int m, char prev, string s)
    {
        if(m == 0)
        {
            v.emplace_back(std::move(s));
            return;
        }
        for(auto c : colors)
        {
            if(prev != c)
                get(m - 1, c, s + c);
        }
    }

    int dp[250][1001];

    int recur(int i, int n)
    {
        if(n == 0) return 1;
        if(dp[i][n] != -1) return dp[i][n];
        int res = 0;
        for(auto j : adj[i])
        {
            res = (res + recur(j, n - 1)) % mod;
        }
        return dp[i][n] = res;
    }

    int colorTheGrid(int m, int n)
    {
        get(m, '$', "");
        int N = v.size();
        adj.resize(N);
        for(int i = 0; i < N; i++)
        {
            for(int j = i + 1; j < N; j++)
            {
                bool flag = true;
                for(int k = 0; k < m; k++)
                {
                    if(v[i][k] == v[j][k]) { flag = false; break; }
                }
                if(flag)
                {
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }
        int res = 0;
        memset(dp, -1, sizeof(dp));
        for(int i = 0; i < N; i++)
        {
            res = (res + recur(i, n - 1)) % mod;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/merge-bsts-to-create-single-bst/

You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. 
In one operation, you can:

Select two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j].
Replace the leaf node in trees[i] with trees[j].
Remove trees[j] from trees.
Return the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST.

A BST (binary search tree) is a binary tree where each node satisfies the following property:

Every node in the node's left subtree has a value strictly less than the node's value.
Every node in the node's right subtree has a value strictly greater than the node's value.
A leaf is a node that has no children.

 

Example 1:


Input: trees = [[2,1],[3,2,5],[5,4]]
Output: [3,2,5,1,null,4]
Explanation:
In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1].
Delete trees[0], so trees = [[3,2,5,1],[5,4]].

In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0].
Delete trees[1], so trees = [[3,2,5,1,null,4]].

The resulting tree, shown above, is a valid BST, so return its root.
Example 2:


Input: trees = [[5,3,8],[3,2,6]]
Output: []
Explanation:
Pick i=0 and j=1 and merge trees[1] into trees[0].
Delete trees[1], so trees = [[5,3,8,2,6]].

The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null.
Example 3:


Input: trees = [[5,4],[3]]
Output: []
Explanation: It is impossible to perform any operations.
 

Constraints:

n == trees.length
1 <= n <= 5 * 104
The number of nodes in each tree is in the range [1, 3].
Each node in the input may have children but no grandchildren.
No two roots of trees have the same value.
All the trees in the input are valid BSTs.
1 <= TreeNode.val <= 5 * 104.

class Solution
{
public:
    unordered_map<int, TreeNode *> rootmap;
    unordered_set<int> leafmap;

    TreeNode *canMerge(vector<TreeNode *> &trees)
    {
        for(auto it : trees)
        {
            rootmap[it->val] = it;
            if(it->left)
                leafmap.insert(it->left->val);
            if(it->right)
                leafmap.insert(it->right->val);
        }
        TreeNode *root = nullptr;
        for(auto it : trees)
        {
            if(leafmap.find(it->val) == leafmap.end())
                root = it;
        }
        if(helper(root, INT_MIN, INT_MAX))
        {
            if(rootmap.size() == 1)
                return root;
        }
        return nullptr;
    }

    bool helper(TreeNode *root, int low, int high)
    {
        if(!root)
            return true;
        if(root->val > high || root->val < low)
            return false;
        if(root->left)
        {
            int cur = root->left->val;
            if(rootmap.find(cur) != rootmap.end())
            {
                root->left = rootmap[cur];
                rootmap.erase(cur);
            }
        }

        if(root->right)
        {
            int cur = root->right->val;
            if(rootmap.find(cur) != rootmap.end())
            {
                root->right = rootmap[cur];
                rootmap.erase(cur);
            }
        }

        if(!helper(root->left, low, root->val - 1))
            return false;

        if(!helper(root->right, root->val + 1, high))
            return false;

        return true;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-words-you-can-type/

There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.

Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, 
return the number of words in text you can fully type using this keyboard.

 

Example 1:

Input: text = "hello world", brokenLetters = "ad"
Output: 1
Explanation: We cannot type "world" because the 'd' key is broken.
Example 2:

Input: text = "leet code", brokenLetters = "lt"
Output: 1
Explanation: We cannot type "leet" because the 'l' and 't' keys are broken.
Example 3:

Input: text = "leet code", brokenLetters = "e"
Output: 0
Explanation: We cannot type either word because the 'e' key is broken.
 

Constraints:

1 <= text.length <= 104
0 <= brokenLetters.length <= 26
text consists of words separated by a single space without any leading or trailing spaces.
Each word only consists of lowercase English letters.
brokenLetters consists of distinct lowercase English letters.

class Solution
{
public:
    int canBeTypedWords(string text, string brokenLetters)
    {
        int arr[26] = {0};
        for (auto ch : brokenLetters) arr[ch - 'a'] = 1;
        stringstream ss(text);
        string t;
        int ans = 0;
        while (ss >> t)
        {
            bool flag = true;
            for (auto ch: t)
            {
                if (arr[ch - 'a']) { flag = false; break; }
            }
            if (flag) ++ans;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/add-minimum-number-of-rungs/

You are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung.

You are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. 
You are able to insert rungs at any positive integer height if a rung is not already there.

Return the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung.

 

Example 1:

Input: rungs = [1,3,5,10], dist = 2
Output: 2
Explanation:
You currently cannot reach the last rung.
Add rungs at heights 7 and 8 to climb this ladder. 
The ladder will now have rungs at [1,3,5,7,8,10].
Example 2:

Input: rungs = [3,6,8,10], dist = 3
Output: 0
Explanation:
This ladder can be climbed without adding additional rungs.
Example 3:

Input: rungs = [3,4,6,7], dist = 2
Output: 1
Explanation:
You currently cannot reach the first rung from the ground.
Add a rung at height 1 to climb this ladder.
The ladder will now have rungs at [1,3,4,6,7].
 

Constraints:

1 <= rungs.length <= 105
1 <= rungs[i] <= 109
1 <= dist <= 109
rungs is strictly increasing.

class Solution
{
public:
    int addRungs(vector<int> &rungs, int dist)
    {
        int n = rungs.size();
        int res = 0;
        for(int i = 1; i < n; ++i)
        {
            if(rungs[i] - rungs[i - 1] > dist)
                res += (rungs[i] - 1 - rungs[i - 1]) / dist;
        }
        if(rungs[0] > dist)
            res += (rungs[0] - 1) / dist;
        return res;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-points-with-cost/

You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix.

To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score.

However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. 
For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.

Return the maximum number of points you can achieve.

abs(x) is defined as:

x for x >= 0.
-x for x < 0.
 

Example 1:


Input: points = [[1,2,3],[1,5,1],[3,1,1]]
Output: 9
Explanation:
The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).
You add 3 + 5 + 3 = 11 to your score.
However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.
Your final score is 11 - 2 = 9.
Example 2:


Input: points = [[1,5],[2,3],[4,2]]
Output: 11
Explanation:
The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).
You add 5 + 3 + 4 = 12 to your score.
However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.
Your final score is 12 - 1 = 11.
 

Constraints:

m == points.length
n == points[r].length
1 <= m, n <= 105
1 <= m * n <= 105
0 <= points[r][c] <= 105

dp[i][j] 表示已经pick 前 i + 1 行（points[0] 到 points[i]），points[i] pick points[i][j]，the maximum number of points
dp[i][j] = points[i][j] + dp[i-1][k] - abs(j-k)
如果j >=k，则dp[i][j] = points[i][j] - j + dp[i-1][k] + k
如果j <=k，则dp[i][j] = points[i][j] + j + dp[i-1][k] - k

class Solution
{
public:

    long long maxPoints(vector<vector<int>> &points)
    {
        long long n = points.size();
        long long m = points[0].size();

        vector<vector<long long>> dp(n, vector<long long> (m, INT_MIN));
        for(int i = 0; i < m; i++)
        {
            dp[0][i] = points[0][i];
        }
        for(int i = 1; i < n; i++)
        {
            long long val1 = INT_MIN;
            long long val2 = INT_MIN;

            // 如果j >=k，则dp[i][j] = points[i][j] - j + dp[i-1][k] + k
            for(int j = 0; j < m; j++)
            {
                if(dp[i - 1][j] + j > val1)
                {
                    val1 = dp[i - 1][j] + j;
                }
                if(points[i][j] - j + val1 > dp[i][j])
                {
                    dp[i][j] = points[i][j] - j + val1;
                }
            }

            // 如果j <=k，则dp[i][j] = points[i][j] + j + dp[i-1][k] - k
            // right to left (checking for the max points that can be obtained using only right side values) and updating the dp array
            for(int j = m - 1; j >= 0; j--)
            {
                if(dp[i - 1][j] - j > val2)
                {
                    val2 = dp[i - 1][j] - j;
                }
                if(points[i][j] + j + val2 > dp[i][j])
                {
                    dp[i][j] = points[i][j] + j + val2;
                }
            }
        }

        long long ans = INT_MIN;
        for(int i = 0; i < m; i++)
        {
            if(dp[n - 1][i] > ans)
            {
                ans = dp[n - 1][i];
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/maximum-genetic-difference-query/

There is a rooted tree consisting of n nodes numbered 0 to n - 1. Each node's number denotes its unique genetic value (i.e. the genetic value of node x is x). 
The genetic difference between two genetic values is defined as the bitwise-XOR of their values. You are given the integer array parents, where parents[i] is the parent for node i. 
If node x is the root of the tree, then parents[x] == -1.

You are also given the array queries where queries[i] = [nodei, vali]. For each query i, find the maximum genetic difference between vali and pi, 
where pi is the genetic value of any node that is on the path between nodei and the root (including nodei and the root). More formally, you want to maximize vali XOR pi.

Return an array ans where ans[i] is the answer to the ith query.

 

Example 1:


Input: parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]]
Output: [2,3,7]
Explanation: The queries are processed as follows:
- [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2.
- [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3.
- [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.
Example 2:


Input: parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]]
Output: [6,14,7]
Explanation: The queries are processed as follows:
- [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6.
- [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14.
- [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7.
 

Constraints:

2 <= parents.length <= 105
0 <= parents[i] <= parents.length - 1 for every node i that is not the root.
parents[root] == -1
1 <= queries.length <= 3 * 104
0 <= nodei <= parents.length - 1
0 <= vali <= 2 * 105

prefixes[(1 << (n - i)) - 1 + (x >> i)] 记录x的前 1 位，前2位，前3位，前4位，前5位，前6位，... ，前n位

prefixes[0] 和 prefixes[(1 << (n+1)) - 1] 没使用

prefixes[(1 << (n   )) - 1 + (x >> 0)] -> prefixes[(1 << (n   )) - 1 + 0] 到 prefixes[(1 << (n   )) - 1 + (1 << (n   )) - 1] 
prefixes[(1 << (n-1)) - 1 + (x >> 1)] -> prefixes[(1 << (n-1)) - 1 + 0] 到 prefixes[(1 << (n-1)) - 1 + (1 << (n-1)) - 1] 
prefixes[(1 << (n-2)) - 1 + (x >> 2)] -> prefixes[(1 << (n-2)) - 1 + 0] 到 prefixes[(1 << (n-2)) - 1 + (1 << (n-2)) - 1] 
...
prefixes[(1 << (6)) - 1 + (x >> (n-6))] -> prefixes[63 + 0] 到 prefixes[63 + 63] 
prefixes[(1 << (5)) - 1 + (x >> (n-5))] -> prefixes[31 + 0] 到 prefixes[31 + 31] 
prefixes[(1 << (4)) - 1 + (x >> (n-4))] -> prefixes[15 + 0] 到 prefixes[15 + 15] 
prefixes[(1 << (3)) - 1 + (x >> (n-3))] -> prefixes[7 + 0] 到 prefixes[7 + 7] 
prefixes[(1 << (2)) - 1 + (x >> (n-2))] -> prefixes[3 + 0] 到 prefixes[3 + 3] 
prefixes[(1 << (1)) - 1 + (x >> (n-1))] -> prefixes[1 + 0] 到 prefixes[1 + 1] 


template<int n>
class BitTrie
{
public:
    int prefixes[1 << (n + 1)];

    void add(int x)
    {
        for (int i = 0; i < n; ++i)
            ++prefixes[(1 << (n - i)) - 1 + (x >> i)];
    }

    void remove(int x)
    {
        for (int i = 0; i < n; ++i)
            --prefixes[(1 << (n - i)) - 1 + (x >> i)];
    }

    // 查找当前BitTrie中与x差异最小的数
    // i = n-1，对应x的前1位（从最高位开始）
    // i = n-2，对应x的前2位
    // ...
    // i = 0，对应x的前n位
    int match(int x)
    {
        for (int i = n - 1; i >= 0; --i)
        {
            if (prefixes[(1 << (n - i)) - 1 + (x >> i)] == 0)
                x ^= 1 << i;
        }
        return x;
    }
};

class Solution
{
public:

    static constexpr int n = 18, m = (1 << n) - 1;

    BitTrie<n> trie;
    vector<vector<int>> tree;
    vector<vector<pair<int, int>>> values;
    vector<int> result;

    void search(int parent)
    {
        trie.add(parent);
        for (auto [query, value] : values[parent])
            result[query] = value ^ trie.match(value ^ m);
        for (int child : tree[parent])
            search(child);
        trie.remove(parent);
    }

    vector<int> maxGeneticDifference(vector<int> &parents, vector<vector<int>> &queries)
    {
        result.resize(queries.size());
        tree.resize(parents.size());
        values.resize(parents.size());
        int root = -1;
        for (int i = 0; i < parents.size(); ++i)
        {
            if (parents[i] != -1)
                tree[parents[i]].push_back(i);
            else
                root = i;
        }
        for (int i = 0; i < queries.size(); ++i)
        {
            values[queries[i][0]].push_back({ i, queries[i][1] });
        }
        search(root);
        return result;
    }
};


// Source https://leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/

Given a string s, return true if s is a good string, or false otherwise.

A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency).

 

Example 1:

Input: s = "abacbc"
Output: true
Explanation: The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s.
Example 2:

Input: s = "aaabb"
Output: false
Explanation: The characters that appear in s are 'a' and 'b'.
'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times.
 

Constraints:

1 <= s.length <= 1000
s consists of lowercase English letters.

class Solution
{
public:
    bool areOccurrencesEqual(string s)
    {
        int n = s.length();
        int freq[26] = {0};
        for(int i = 0; i < n; i++)
        {
            freq[s[i]-'a']++;
        }
        int i;
        int cnt;
        for (i = 0; i < 26; ++i)
        {
            if(freq[i] > 0) {cnt = freq[i]; break; }
        }
        for (; i < 26; ++i)
        {
            if(freq[i] > 0 && freq[i] != cnt) return false;
        }
        return true;
    }
};


// Source https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/

There is a party where n friends numbered from 0 to n - 1 are attending. There is an infinite number of chairs in this party that are numbered from 0 to infinity. 
When a friend arrives at the party, they sit on the unoccupied chair with the smallest number.

For example, if chairs 0, 1, and 5 are occupied when a friend comes, they will sit on chair number 2.
When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair.

You are given a 0-indexed 2D integer array times where times[i] = [arrivali, leavingi], indicating the arrival and leaving times of the ith friend respectively, 
and an integer targetFriend. All arrival times are distinct.

Return the chair number that the friend numbered targetFriend will sit on.

 

Example 1:

Input: times = [[1,4],[2,3],[4,6]], targetFriend = 1
Output: 1
Explanation: 
- Friend 0 arrives at time 1 and sits on chair 0.
- Friend 1 arrives at time 2 and sits on chair 1.
- Friend 1 leaves at time 3 and chair 1 becomes empty.
- Friend 0 leaves at time 4 and chair 0 becomes empty.
- Friend 2 arrives at time 4 and sits on chair 0.
Since friend 1 sat on chair 1, we return 1.
Example 2:

Input: times = [[3,10],[1,5],[2,6]], targetFriend = 0
Output: 2
Explanation: 
- Friend 1 arrives at time 1 and sits on chair 0.
- Friend 2 arrives at time 2 and sits on chair 1.
- Friend 0 arrives at time 3 and sits on chair 2.
- Friend 1 leaves at time 5 and chair 0 becomes empty.
- Friend 2 leaves at time 6 and chair 1 becomes empty.
- Friend 0 leaves at time 10 and chair 2 becomes empty.
Since friend 0 sat on chair 2, we return 2.
 

Constraints:

n == times.length
2 <= n <= 104
times[i].length == 2
1 <= arrivali < leavingi <= 105
0 <= targetFriend <= n - 1
Each arrivali time is distinct.

class Solution
{
public:
    int smallestChair(vector<vector<int>> &times, int targetFriend)
    {
        int n = times.size();
        vector<int>v = times[targetFriend];
        sort(times.begin(), times.end());
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        priority_queue<int, vector<int>, greater<int>> pq2;
        int next = 0;
        for(int i = 0; i < n; i++)
        {
            while(!pq.empty() && pq.top().first <= times[i][0])
            {
                pq2.push(pq.top().second);
                pq.pop();
            }
            if (!pq2.empty())
            {
                int chair = pq2.top();
                pq2.pop();
                if(times[i] == v)
                {
                    return chair;
                }
                pq.push({times[i][1], chair});
            }
            else
            {
                if(times[i] == v)
                {
                    return next;
                }
                pq.push({times[i][1], next});
                ++next;
            }
        }
        return 0;
    }
};


// Source https://leetcode.com/problems/describe-the-painting/

There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a unique color. 
You are given a 2D integer array segments, where segments[i] = [starti, endi, colori] represents the half-closed segment [starti, endi) with colori as the color.

The colors in the overlapping segments of the painting were mixed when it was painted. When two or more colors mix, they form a new color that can be represented as a set of mixed colors.

For example, if colors 2, 4, and 6 are mixed, then the resulting mixed color is {2,4,6}.
For the sake of simplicity, you should only output the sum of the elements in the set rather than the full set.

You want to describe the painting with the minimum number of non-overlapping half-closed segments of these mixed colors. 
These segments can be represented by the 2D array painting where painting[j] = [leftj, rightj, mixj] describes a half-closed segment [leftj, rightj) with the mixed color sum of mixj.

For example, the painting created with segments = [[1,4,5],[1,7,7]] can be described by painting = [[1,4,12],[4,7,7]] because:
[1,4) is colored {5,7} (with a sum of 12) from both the first and second segments.
[4,7) is colored {7} from only the second segment.
Return the 2D array painting describing the finished painting (excluding any parts that are not painted). You may return the segments in any order.

A half-closed segment [a, b) is the section of the number line between points a and b including point a and not including point b.

 

Example 1:


Input: segments = [[1,4,5],[4,7,7],[1,7,9]]
Output: [[1,4,14],[4,7,16]]
Explanation: The painting can be described as follows:
- [1,4) is colored {5,9} (with a sum of 14) from the first and third segments.
- [4,7) is colored {7,9} (with a sum of 16) from the second and third segments.
Example 2:


Input: segments = [[1,7,9],[6,8,15],[8,10,7]]
Output: [[1,6,9],[6,7,24],[7,8,15],[8,10,7]]
Explanation: The painting can be described as follows:
- [1,6) is colored 9 from the first segment.
- [6,7) is colored {9,15} (with a sum of 24) from the first and second segments.
- [7,8) is colored 15 from the second segment.
- [8,10) is colored 7 from the third segment.
Example 3:


Input: segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]]
Output: [[1,4,12],[4,7,12]]
Explanation: The painting can be described as follows:
- [1,4) is colored {5,7} (with a sum of 12) from the first and second segments.
- [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.
Note that returning a single segment [1,7) is incorrect because the mixed color sets are different.
 

Constraints:

1 <= segments.length <= 2 * 104
segments[i].length == 3
1 <= starti < endi <= 105
1 <= colori <= 109
Each colori is distinct.

class Solution
{
public:
    vector<vector<long long>> splitPainting(vector<vector<int>> &segments)
    {
        vector<pair<int, int>> p;
        for(int i = 0; i < segments.size(); i++)
        {
            p.push_back({segments[i][0], segments[i][2]});
            p.push_back({segments[i][1], -segments[i][2]});
        }
        sort(p.begin(), p.end(),
             [](const pair<int, int> &a, const pair<int, int> &b) -> bool
        {
            return a.first < b.first;
        });
        vector<vector<long long>> res;
        long long sum = p[0].second;
        for(int i = 1; i < p.size(); i++)
        {
            if (p[i - 1].first != p[i].first && sum != 0)
                res.push_back({p[i - 1].first, p[i].first, sum});
            sum += p[i].second;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/number-of-visible-people-in-a-queue/

There are n people standing in a queue, and they numbered from 0 to n - 1 in left to right order. 
You are given an array heights of distinct integers where heights[i] represents the height of the ith person.

A person can see another person to their right in the queue if everybody in between is shorter than both of them. 
More formally, the ith person can see the jth person if i < j and min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1]).

Return an array answer of length n where answer[i] is the number of people the ith person can see to their right in the queue.

 

Example 1:



Input: heights = [10,6,8,5,11,9]
Output: [3,1,2,1,1,0]
Explanation:
Person 0 can see person 1, 2, and 4.
Person 1 can see person 2.
Person 2 can see person 3 and 4.
Person 3 can see person 4.
Person 4 can see person 5.
Person 5 can see no one since nobody is to the right of them.
Example 2:

Input: heights = [5,1,2,3,10]
Output: [4,1,1,1,0]
 

Constraints:

n == heights.length
1 <= n <= 105
1 <= heights[i] <= 105
All the values of heights are unique.

class Solution
{
public:
    vector<int> canSeePersonsCount(vector<int> &heights)
    {
        int n = heights.size();
        vector<int> ans(n, 0);
        stack<int> st;
        st.push(heights[n - 1]);
        for(int i = n - 2; i >= 0; --i)
        {
            int curr_height = heights[i];
            int cnt = 0;
            while(!st.empty() && curr_height > st.top())
            {
                st.pop();
                cnt++;
            }
            if (!st.empty()) ++cnt;
            ans[i] = cnt;
            st.push(curr_height);
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/sum-of-digits-of-string-after-convert/

You are given a string s consisting of lowercase English letters, and an integer k.

First, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). 
Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.

For example, if s = "zbax" and k = 2, then the resulting integer would be 8 by the following operations:

Convert: "zbax" ➝ "(26)(2)(1)(24)" ➝ "262124" ➝ 262124
Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17
Transform #2: 17 ➝ 1 + 7 ➝ 8
Return the resulting integer after performing the operations described above.

 

Example 1:

Input: s = "iiii", k = 1
Output: 36
Explanation: The operations are as follows:
- Convert: "iiii" ➝ "(9)(9)(9)(9)" ➝ "9999" ➝ 9999
- Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36
Thus the resulting integer is 36.
Example 2:

Input: s = "leetcode", k = 2
Output: 6
Explanation: The operations are as follows:
- Convert: "leetcode" ➝ "(12)(5)(5)(20)(3)(15)(4)(5)" ➝ "12552031545" ➝ 12552031545
- Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33
- Transform #2: 33 ➝ 3 + 3 ➝ 6
Thus the resulting integer is 6.
Example 3:

Input: s = "zbax", k = 2
Output: 8
 

Constraints:

1 <= s.length <= 100
1 <= k <= 10
s consists of lowercase English letters.

class Solution
{
public:
    int getLucky(string s, int k)
    {
        vector<int> sumDig(27, 0);
        for(int i = 1; i <= 26; i++)
        {
            sumDig[i] = (i / 10) + (i % 10);
        }
        int ans = 0;
        for(char c : s)
        {
            ans += sumDig[c - 'a' + 1];
        }
        if (k == 1) return ans;
        --k;
        while (k > 0)
        {
            string num = to_string(ans);
            ans = 0;
            for(char c : num)
            {
                ans += (c - '0');
            }
            --k;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/largest-number-after-mutating-substring/

You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. 
More formally, digit d maps to digit change[d].

You may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).

Return a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.

A substring is a contiguous sequence of characters within the string.

 

Example 1:

Input: num = "132", change = [9,8,5,0,3,6,4,2,6,8]
Output: "832"
Explanation: Replace the substring "1":
- 1 maps to change[1] = 8.
Thus, "132" becomes "832".
"832" is the largest number that can be created, so return it.
Example 2:

Input: num = "021", change = [9,4,3,5,7,2,1,9,0,6]
Output: "934"
Explanation: Replace the substring "021":
- 0 maps to change[0] = 9.
- 2 maps to change[2] = 3.
- 1 maps to change[1] = 4.
Thus, "021" becomes "934".
"934" is the largest number that can be created, so return it.
Example 3:

Input: num = "5", change = [1,4,7,5,3,2,5,6,9,4]
Output: "5"
Explanation: "5" is already the largest number that can be created, so return it.
 

Constraints:

1 <= num.length <= 105
num consists of only digits 0-9.
change.length == 10
0 <= change[d] <= 9

class Solution
{
public:
    string maximumNumber(string num, vector<int> &change)
    {
        int n = num.length();
        int i;
        for(i = 0; i < n; i++)
        {
            int d = num[i] - '0';
            if(change[d] > d)
            {
                break;
            }
        }
        for(; i < n; i++)
        {
            int d = num[i] - '0';
            if(change[d] < d)
            {
                break;
            }
            num[i] = change[d] + '0';
        }
        return num;
    }
};


// Source https://leetcode.com/problems/maximum-compatibility-score-sum/

There is a survey that consists of n questions where each question's answer is either 0 (no) or 1 (yes).

The survey was given to m students numbered from 0 to m - 1 and m mentors numbered from 0 to m - 1. 
The answers of the students are represented by a 2D integer array students where students[i] is an integer array that contains the answers of the ith student (0-indexed). 
The answers of the mentors are represented by a 2D integer array mentors where mentors[j] is an integer array that contains the answers of the jth mentor (0-indexed).

Each student will be assigned to one mentor, and each mentor will have one student assigned to them. 
The compatibility score of a student-mentor pair is the number of answers that are the same for both the student and the mentor.

For example, if the student's answers were [1, 0, 1] and the mentor's answers were [0, 0, 1], then their compatibility score is 2 because only the second and the third answers are the same.
You are tasked with finding the optimal student-mentor pairings to maximize the sum of the compatibility scores.

Given students and mentors, return the maximum compatibility score sum that can be achieved.

 

Example 1:

Input: students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]
Output: 8
Explanation: We assign students to mentors in the following way:
- student 0 to mentor 2 with a compatibility score of 3.
- student 1 to mentor 0 with a compatibility score of 2.
- student 2 to mentor 1 with a compatibility score of 3.
The compatibility score sum is 3 + 2 + 3 = 8.
Example 2:

Input: students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]
Output: 0
Explanation: The compatibility score of any student-mentor pair is 0.
 

Constraints:

m == students.length == mentors.length
n == students[i].length == mentors[j].length
1 <= m, n <= 8
students[i][k] is either 0 or 1.
mentors[j][k] is either 0 or 1.

class Solution
{
public:
    int m, n;
    int scores[10][10];
    int ans;

    int compatScore(vector<int> &student, vector<int> &mentor)
    {
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            if(student[i] == mentor[i])
            {
                ans++;
            }
        }
        return ans;
    }

    void backtrack(vector<bool> &seen, int curr, int sindex)
    {
        if(sindex == m)
        {
            ans = max(ans, curr);
            return;
        }
        for(int i = 0; i < m; i++)
        {
            if(!seen[i])
            {
                seen[i] = true;
                backtrack(seen, curr + scores[sindex][i], sindex + 1);
                seen[i] = false;
            }
        }
    }

    int maxCompatibilitySum(vector<vector<int>> &students, vector<vector<int>> &mentors)
    {
        ans = 0;
        m = students.size();
        n = students[0].size();
        for(int i = 0; i < m; i++)
        {
            for(int j = 0; j < m; j++)
            {
                scores[i][j] = compatScore(students[i], mentors[j]);
            }
        }
        vector<bool>seen(m);
        backtrack(seen, 0, 0);
        return ans;
    }
};


// Source https://leetcode.com/problems/delete-duplicate-folders-in-system/

Due to a bug, there are many duplicate folders in a file system. You are given a 2D array paths, where paths[i] is an array representing an absolute path to the ith folder in the file system.

For example, ["one", "two", "three"] represents the path "/one/two/three".
Two folders (not necessarily on the same level) are identical if they contain the same non-empty set of identical subfolders and underlying subfolder structure. 
The folders do not need to be at the root level to be identical. If two or more folders are identical, then mark the folders as well as all their subfolders.

For example, folders "/a" and "/b" in the file structure below are identical. They (as well as their subfolders) should all be marked:
/a
/a/x
/a/x/y
/a/z
/b
/b/x
/b/x/y
/b/z
However, if the file structure also included the path "/b/w", then the folders "/a" and "/b" would not be identical. 
Note that "/a/x" and "/b/x" would still be considered identical even with the added folder.
Once all the identical folders and their subfolders have been marked, the file system will delete all of them. 
The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted.

Return the 2D array ans containing the paths of the remaining folders after deleting all the marked folders. The paths may be returned in any order.

 

Example 1:


Input: paths = [["a"],["c"],["d"],["a","b"],["c","b"],["d","a"]]
Output: [["d"],["d","a"]]
Explanation: The file structure is as shown.
Folders "/a" and "/c" (and their subfolders) are marked for deletion because they both contain an empty
folder named "b".
Example 2:


Input: paths = [["a"],["c"],["a","b"],["c","b"],["a","b","x"],["a","b","x","y"],["w"],["w","y"]]
Output: [["c"],["c","b"],["a"],["a","b"]]
Explanation: The file structure is as shown. 
Folders "/a/b/x" and "/w" (and their subfolders) are marked for deletion because they both contain an empty folder named "y".
Note that folders "/a" and "/c" are identical after the deletion, but they are not deleted because they were not marked beforehand.
Example 3:


Input: paths = [["a","b"],["c","d"],["c"],["a"]]
Output: [["c"],["c","d"],["a"],["a","b"]]
Explanation: All folders are unique in the file system.
Note that the returned array can be in a different order as the order does not matter.
 

Constraints:

1 <= paths.length <= 2 * 104
1 <= paths[i].length <= 500
1 <= paths[i][j].length <= 10
1 <= sum(paths[i][j].length) <= 2 * 105
path[i][j] consists of lowercase English letters.
No two paths lead to the same folder.
For any folder not at the root level, its parent folder will also be in the input.

先把paths转换为以root为根节点的树状结构，再dfs(root)，使用tree_map和content_map来排重，同时mark重复的节点

class Solution
{
public:

    struct Node
    {
        string val;
        bool skip = false;
        unordered_map<string, Node *> next;
        Node() = default;
        Node(string v) : val{std::move(v)} {};
    };

    int count;
    unordered_map<string, pair<int, Node *>> tree_map;
    unordered_map<string, Node *> content_map;
    vector<vector<string>> ans;

    int dfs(Node *n)
    {
        vector<int> ids;
        for(auto p : n->next) ids.push_back(dfs(p.second));
        sort(ids.begin(), ids.end());
        string tree_key = n->val;
        string content_key;
        for(auto id : ids) content_key.append("," + to_string(id));
        tree_key.append(content_key);
        // 指向被插入元素，或若不发生插入则为既存元素的迭代器，和指代插入是否发生的 bool （若发生插入则为 true ，否则为 false ）
        auto [it, ins] = tree_map.try_emplace(tree_key, make_pair(count, n));
        if(ins) ++count;
        if(!ids.empty())
        {
            // 指向被插入元素，或若不发生插入则为既存元素的迭代器，和指代插入是否发生的 bool （若发生插入则为 true ，否则为 false ）
            auto [it2, ins2] = content_map.try_emplace(content_key, n);
            if(!ins2)
            {
                n->skip = true;
                it2->second->skip = true;
            }
        }
        return it->second.first;
    }

    void get_paths(Node *n, vector<string> &path)
    {
        if(n->skip) return;
        path.emplace_back(std::move(n->val));
        ans.push_back(path);
        for(auto p : n->next) get_paths(p.second, path);
        path.pop_back();
    }

    vector<vector<string>> deleteDuplicateFolder(vector<vector<string>> &paths)
    {
        auto root = new Node();
        for(auto &v : paths)
        {
            auto curr = root;
            for(auto k : v)
            {
                if(curr->next.find(k) == curr->next.end()) curr->next[k] = new Node(k);
                curr = curr->next[k];
            }
        }
        count = 1;
        dfs(root);
        vector<string> path;
        for(auto p : root->next) get_paths(p.second, path);
        return ans;
    }
};


// Source https://leetcode.com/problems/three-divisors/

Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.

An integer m is a divisor of n if there exists an integer k such that n = k * m.

 

Example 1:

Input: n = 2
Output: false
Explantion: 2 has only two divisors: 1 and 2.
Example 2:

Input: n = 4
Output: true
Explantion: 4 has three divisors: 1, 2, and 4.
 

Constraints:

1 <= n <= 104

class Solution
{
public:

    bool isThree(int n)
    {
        int num_divs = 0;
        for (int i = 1; i <= n; i++)
        {
            if (n % i == 0)
            {
                num_divs++;
            }
        }
        return num_divs == 3;
    }
};


// Source https://leetcode.com/problems/maximum-number-of-weeks-for-which-you-can-work/

There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has.

You can work on the projects following these two rules:

Every week, you will finish exactly one milestone of one project. You must work every week.
You cannot work on two milestones from the same project for two consecutive weeks.
Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. 
Note that you may not be able to finish every project's milestones due to these constraints.

Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above.

 

Example 1:

Input: milestones = [1,2,3]
Output: 6
Explanation: One possible scenario is:
​​​​- During the 1st week, you will work on a milestone of project 0.
- During the 2nd week, you will work on a milestone of project 2.
- During the 3rd week, you will work on a milestone of project 1.
- During the 4th week, you will work on a milestone of project 2.
- During the 5th week, you will work on a milestone of project 1.
- During the 6th week, you will work on a milestone of project 2.
The total number of weeks is 6.
Example 2:

Input: milestones = [5,2,1]
Output: 7
Explanation: One possible scenario is:
- During the 1st week, you will work on a milestone of project 0.
- During the 2nd week, you will work on a milestone of project 1.
- During the 3rd week, you will work on a milestone of project 0.
- During the 4th week, you will work on a milestone of project 1.
- During the 5th week, you will work on a milestone of project 0.
- During the 6th week, you will work on a milestone of project 2.
- During the 7th week, you will work on a milestone of project 0.
The total number of weeks is 7.
Note that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules.
Thus, one milestone in project 0 will remain unfinished.
 

Constraints:

n == milestones.length
1 <= n <= 105
1 <= milestones[i] <= 109

class Solution
{
public:
    long long numberOfWeeks(vector<int> &milestones)
    {
        int n = milestones.size();
        long long sum = 0, mxVal = 0;
        for(int i = 0; i < n; i++)
        {
            sum += milestones[i];
            if(mxVal < milestones[i]) mxVal = milestones[i];
        }
        long long rem = sum - mxVal;
        if(mxVal > rem) return (1 + 2 * rem);
        return sum;
    }
};


// Source https://leetcode.com/problems/minimum-garden-perimeter-to-collect-enough-apples/

In a garden represented as an infinite 2D grid, there is an apple tree planted at every integer coordinate. The apple tree planted at an integer coordinate (i, j) has |i| + |j| apples growing on it.

You will buy an axis-aligned square plot of land that is centered at (0, 0).

Given an integer neededApples, return the minimum perimeter of a plot such that at least neededApples apples are inside or on the perimeter of that plot.

The value of |x| is defined as:

x if x >= 0
-x if x < 0
 

Example 1:


Input: neededApples = 1
Output: 8
Explanation: A square plot of side length 1 does not contain any apples.
However, a square plot of side length 2 has 12 apples inside (as depicted in the image above).
The perimeter is 2 * 4 = 8.
Example 2:

Input: neededApples = 13
Output: 16
Example 3:

Input: neededApples = 1000000000
Output: 5040
 

Constraints:

1 <= neededApples <= 1015

正方形边长为2n，四个顶点 [-n, n], [n, n], [-n, -n], [n, -n]

正方形包含的所有点的横坐标和纵坐标绝对值之和都是(1 + 2 + ... + n) * (2n + 1) * 2 
(1 + 2 + ... + n) * (2n + 1) * 2  + (1 + 2 + ... + n) * (2n + 1) * 2  = n * (n + 1) / 2 * (2n+1) * 2 * 2 = n * (n + 1) * (2n+1) * 2


class Solution
{
public:

    long long getApples(long long s)
    {
        s = s / 2;
        return 2 * (s * (s + 1) * (2 * s + 1));
    }

    long long minimumPerimeter(long long neededApples)
    {
        long long n = 1;
        long long sum = 0;
        while(sum < neededApples)
        {
            n *= 2;
            sum = getApples(n);
        }
        long long l = n / 2, r = n;
        while(l < r)
        {
            long long mid = l + (r - l) / 2;
            long long apples = getApples(mid);
            if(apples == neededApples) return mid * 4;
            else if(apples > neededApples) r = mid;
            else l = mid + 1;
        }
        return l * 4;
    }
};


// Source https://leetcode.com/problems/count-number-of-special-subsequences/

A sequence is special if it consists of a positive number of 0s, followed by a positive number of 1s, then a positive number of 2s.

For example, [0,1,2] and [0,0,1,1,1,2] are special.
In contrast, [2,1,0], [1], and [0,1,2,0] are not special.
Given an array nums (consisting of only integers 0, 1, and 2), return the number of different subsequences that are special. Since the answer may be very large, return it modulo 109 + 7.

A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. 
Two subsequences are different if the set of indices chosen are different.

 

Example 1:

Input: nums = [0,1,2,2]
Output: 3
Explanation: The special subsequences are bolded [0,1,2,2], [0,1,2,2], and [0,1,2,2].
Example 2:

Input: nums = [2,2,0,0]
Output: 0
Explanation: There are no special subsequences in [2,2,0,0].
Example 3:

Input: nums = [0,1,2,0,1,2]
Output: 7
Explanation: The special subsequences are bolded:
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
- [0,1,2,0,1,2]
 

Constraints:

1 <= nums.length <= 105
0 <= nums[i] <= 2

// From left to right, lets keep track of the number of special subsequences that end in 0 and end in 1, and end in 2.
// At the end, we will return the number of special subsequences that end in 2.
// Left to right:
// when we visit a 0, this creates 1 more subsequence that ends in 0 and we can also add this 0 to every other subsequence that ended with 0.
// Thus, dp[0] = 2*dp[0] + 1.
// when we visit a 1, we can add this 1 to every subsequence that ends in 0 and ends in 1.
// Thus, dp[1] = 2*dp[1] + dp[0]
// when we visist a 2, we can add this 2 to every subsequence that ends in 1 and ends in 2.
// Thus, dp[2] = 2*dp[2] + dp[1]
// return dp[2]

class Solution
{
public:
    int countSpecialSubsequences(vector<int> &nums)
    {
        const long mod = 1e9 + 7;
        vector<long> dp(3, 0);
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
            if(nums[i] == 0)
            {
                dp[0] = (2 * dp[0] + 1) % mod;
            }
            else if(nums[i] == 1)
            {
                dp[1] = (2 * dp[1] + dp[0]) % mod;
            }
            else
            {
                dp[2] = (2 * dp[2] + dp[1]) % mod;
            }
        }
        return dp[2];
    }
};


// Source https://leetcode.com/problems/delete-characters-to-make-fancy-string/

A fancy string is a string where no three consecutive characters are equal.

Given a string s, delete the minimum possible number of characters from s to make it fancy.

Return the final string after the deletion. It can be shown that the answer will always be unique.

 

Example 1:

Input: s = "leeetcode"
Output: "leetcode"
Explanation:
Remove an 'e' from the first group of 'e's to create "leetcode".
No three consecutive characters are equal, so return "leetcode".
Example 2:

Input: s = "aaabaaaa"
Output: "aabaa"
Explanation:
Remove an 'a' from the first group of 'a's to create "aabaaaa".
Remove two 'a's from the second group of 'a's to create "aabaa".
No three consecutive characters are equal, so return "aabaa".
Example 3:

Input: s = "aab"
Output: "aab"
Explanation: No three consecutive characters are equal, so return "aab".
 

Constraints:

1 <= s.length <= 105
s consists only of lowercase English letters.

class Solution
{
public:

    string makeFancyString(string s)
    {
        int n = s.length();
        if (n < 3) return s;
        string res;
        res.reserve(n);
        res.push_back(s[0]);
        res.push_back(s[1]);
        for (int i = 2; i < n; ++i)
        {
            if (s[i] == s[i - 1] && s[i] == s[i - 2])
            {
                continue;
            }
            res.push_back(s[i]);
        }
        return res;
    }
};

// Source https://leetcode.com/problems/check-if-move-is-legal/

You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents the cell (r, c) on a game board. 
On the board, free cells are represented by '.', white cells are represented by 'W', and black cells are represented by 'B'.

Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). 
However, a move is only legal if, after changing it, the cell becomes the endpoint of a good line (horizontal, vertical, or diagonal).

A good line is a line of three or more cells (including the endpoints) where the endpoints of the line are one color, 
and the remaining cells in the middle are the opposite color (no cells in the line are free). You can find examples for good lines in the figure below:


Given two integers rMove and cMove and a character color representing the color you are playing as (white or black), 
return true if changing cell (rMove, cMove) to color color is a legal move, or false if it is not legal.

 

Example 1:


Input: board = [[".",".",".","B",".",".",".","."],[".",".",".","W",".",".",".","."],[".",".",".","W",".",".",".","."],[".",".",".","W",".",".",".","."],["W","B","B",".","W","W","W","B"],[".",".",".","B",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","W",".",".",".","."]], rMove = 4, cMove = 3, color = "B"
Output: true
Explanation: '.', 'W', and 'B' are represented by the colors blue, white, and black respectively, and cell (rMove, cMove) is marked with an 'X'.
The two good lines with the chosen cell as an endpoint are annotated above with the red rectangles.
Example 2:


Input: board = [[".",".",".",".",".",".",".","."],[".","B",".",".","W",".",".","."],[".",".","W",".",".",".",".","."],[".",".",".","W","B",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".","B","W",".","."],[".",".",".",".",".",".","W","."],[".",".",".",".",".",".",".","B"]], rMove = 4, cMove = 4, color = "W"
Output: false
Explanation: While there are good lines with the chosen cell as a middle cell, there are no good lines with the chosen cell as an endpoint.
 

Constraints:

board.length == board[r].length == 8
0 <= rMove, cMove < 8
board[rMove][cMove] == '.'
color is either 'B' or 'W'.

class Solution
{
public:
    bool checkMove(vector<vector<char>> &board, int rMove, int cMove, char color)
    {
        int m = board.size();
        int n = board[0].size();
        int dx[8] = {0, 0, 1, -1, 1, -1, -1, 1};
        int dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};
        for(int i = 0; i < 8; i++)
        {
            int x = rMove + dx[i], y = cMove + dy[i];
            bool flag = false;
            int c = 0;
            while(x < m && x >= 0 && y < n && y >= 0)
            {
                if(board[x][y] == '.') break;
                if(board[x][y] == color)
                {
                    if (c >= 1) flag = true;
                    break;
                }
                c++;
                x = x + dx[i], y = y + dy[i];
            }
            if (flag) return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/minimum-total-space-wasted-with-k-resizing-operations/

You are currently designing a dynamic array. You are given a 0-indexed integer array nums, where nums[i] is the number of elements that will be in the array at time i. 
In addition, you are given an integer k, the maximum number of times you can resize the array (to any size).

The size of the array at time t, sizet, must be at least nums[t] because there needs to be enough space in the array to hold all the elements. 
The space wasted at time t is defined as sizet - nums[t], and the total space wasted is the sum of the space wasted across every time t where 0 <= t < nums.length.

Return the minimum total space wasted if you can resize the array at most k times.

Note: The array can have any size at the start and does not count towards the number of resizing operations.

 

Example 1:

Input: nums = [10,20], k = 0
Output: 10
Explanation: size = [20,20].
We can set the initial size to be 20.
The total wasted space is (20 - 10) + (20 - 20) = 10.
Example 2:

Input: nums = [10,20,30], k = 1
Output: 10
Explanation: size = [20,20,30].
We can set the initial size to be 20 and resize to 30 at time 2. 
The total wasted space is (20 - 10) + (20 - 20) + (30 - 30) = 10.
Example 3:

Input: nums = [10,20,15,30,20], k = 2
Output: 15
Explanation: size = [10,20,20,30,30].
We can set the initial size to 10, resize to 20 at time 1, and resize to 30 at time 3.
The total wasted space is (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15.
 

Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 106
0 <= k <= nums.length - 1

class Solution
{
public:
    int n;
    int dp[205][205];

    int recur(vector<int> &nums, int i, int k)
    {
        if(i == n) return 0;
        if(k <= 0) return 1e9;
        if(dp[i][k] != -1) return dp[i][k];
        int ans = 1e9;
        int mxVal = INT_MIN;
        int total = 0;
        for(int j = i; j < n; j++)
        {
            mxVal = max(mxVal, nums[j]);
            total += nums[j];
            int waste = (mxVal * (j - i + 1)) - total;
            ans = min(ans, waste + recur(nums, j + 1, k - 1));
        }
        return dp[i][k] = ans;
    }

    int minSpaceWastedKResizing(vector<int> &nums, int k)
    {
        n = nums.size();
        memset(dp, -1, sizeof(dp));
        return recur(nums, 0, k + 1);
    }
};


// Source https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/

You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized.

More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive.

Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings.

A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.

 

Example 1:

Input: s = "ababbb"
Output: 9
Explanation: Substrings "aba" and "bbb" are palindromes with odd length. product = 3 * 3 = 9.
Example 2:

Input: s = "zaaaxbbby"
Output: 9
Explanation: Substrings "aaa" and "bbb" are palindromes with odd length. product = 3 * 3 = 9.
 

Constraints:

2 <= s.length <= 105
s consists of lowercase English letters.


len[i] 表示以下标 i 为中心点，向左、向右构成palindromic substrings of odd length，最长的回文子字符串长度
s[i] = d, s[i-3 ... i ... i+3] = abcdcba -> len[i] = 4
len[i] >= 1
p + len[p] - 1 对应以下标 p 为中心点，最长的回文子字符串右边界下标
p + len[p]      对应以下标 p 为中心点，最长的回文子字符串右边界下标 + 1
p - len[p] + 1 对应以下标 p 为中心点，最长的回文子字符串左边界下标

如果 i < mx + len[mx]，则 下标 i 对应 mx左边的 下标 mx - (i - mx) = 2 * mx - i，len[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i)

left[i] 表示 s[0 ... i] 中 最长的回文子字符串长度，根据下标 i 是否作为最长的回文子字符串右边界下标有两种情况
left[i] = max(left[i - 1], 2 * (i - p) + 1);

right[i] 表示 s[i ... n-1] 中 最长的回文子字符串长度，根据下标 i 是否作为最长的回文子字符串左边界下标有两种情况
right[i] = max(right[i + 1], 2 * (p - i) + 1);

class Solution
{
public:
    long long maxProduct(string s)
    {
        int n = s.length();
        vector<long long> len(n);
        int mx = 0;
        for (int i = 0; i < n; i++)
        {
            if (i < mx + len[mx])
            {
                len[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i);
            }

            while (i - len[i] >= 0 && i + len[i] < n && s[i - len[i]] == s[i + len[i]])
            {
                len[i]++;
            }

            if (mx + len[mx] < i + len[i])
            {
                mx = i;
            }
        }

        vector<int> left(n), right(n);

        left[0] = 1;
        for (int i = 1, p = 0; i < n; ++i)
        {
            while ((p + len[p]) <= i) ++p;
            left[i] = max(left[i - 1], 2 * (i - p) + 1);
        }

        right[n - 1] = 1;
        for (int i = n - 2, p = n - 1; i >= 0; --i)
        {
            while (p - len[p] >= i) --p;
            right[i] = max(right[i + 1], 2 * (p - i) + 1);
        }

        long long ret = 0;
        for (int i = 0; i < n - 1; ++i)
            ret = max(ret, 1ll * left[i] * right[i + 1]);
        return ret;
    }
};


// Source https://leetcode.com/problems/check-if-string-is-a-prefix-of-array/

Given a string s and an array of strings words, determine whether s is a prefix string of words.

A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.

Return true if s is a prefix string of words, or false otherwise.

 

Example 1:

Input: s = "iloveleetcode", words = ["i","love","leetcode","apples"]
Output: true
Explanation:
s can be made by concatenating "i", "love", and "leetcode" together.
Example 2:

Input: s = "iloveleetcode", words = ["apples","i","love","leetcode"]
Output: false
Explanation:
It is impossible to make s using a prefix of arr.
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 20
1 <= s.length <= 1000
words[i] and s consist of only lowercase English letters.

class Solution
{
public:
    bool isPrefixString(string s, vector<string> &words)
    {
        int n = s.length();
        string ans = "";
        ans.reserve(n);
        const char * ptr = s.c_str();
        for(auto &word : words)
        {
            ans.append(word);
            int len = ans.length();
            if(len > n) return false;
            string_view sv1(ptr, len);
            string_view sv2 = ans;
            if (sv1.compare(sv2) != 0) return false;
            if(len == n) return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/remove-stones-to-minimize-the-total/

You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:

Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
Notice that you can apply the operation on the same pile more than once.

Return the minimum possible total number of stones remaining after applying the k operations.

floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).

 

Example 1:

Input: piles = [5,4,9], k = 2
Output: 12
Explanation: Steps of a possible scenario are:
- Apply the operation on pile 2. The resulting piles are [5,4,5].
- Apply the operation on pile 0. The resulting piles are [3,4,5].
The total number of stones in [3,4,5] is 12.
Example 2:

Input: piles = [4,3,6,7], k = 3
Output: 12
Explanation: Steps of a possible scenario are:
- Apply the operation on pile 2. The resulting piles are [4,3,3,7].
- Apply the operation on pile 3. The resulting piles are [4,3,3,4].
- Apply the operation on pile 0. The resulting piles are [2,3,3,4].
The total number of stones in [2,3,3,4] is 12.
 

Constraints:

1 <= piles.length <= 105
1 <= piles[i] <= 104
1 <= k <= 105

class Solution
{
public:
    int minStoneSum(vector<int> &piles, int k)
    {
        int total = 0;
        priority_queue<int> pq;
        for (int pile : piles)
        {
            pq.push(pile);
            total += pile;
        }
        while (k > 0)
        {
            int val = pq.top();
            pq.pop();
            total -= val / 2;
            int rem = val - val / 2;
            pq.push(rem);
            --k;
        }
        return total;
    }
};


// Source https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/

You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.

A string is called balanced if and only if:

It is the empty string, or
It can be written as AB, where both A and B are balanced strings, or
It can be written as [C], where C is a balanced string.
You may swap the brackets at any two indices any number of times.

Return the minimum number of swaps to make s balanced.

 

Example 1:

Input: s = "][]["
Output: 1
Explanation: You can make the string balanced by swapping index 0 with index 3.
The resulting string is "[[]]".
Example 2:

Input: s = "]]][[["
Output: 2
Explanation: You can do the following to make the string balanced:
- Swap index 0 with index 4. s = "[]][][".
- Swap index 1 with index 5. s = "[[][]]".
The resulting string is "[[][]]".
Example 3:

Input: s = "[]"
Output: 0
Explanation: The string is already balanced.
 

Constraints:

n == s.length
2 <= n <= 106
n is even.
s[i] is either '[' or ']'.
The number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.

]] [[ -> [] [] 一次交换减少2对unpair
] [ -> [] 一次交换减少1对unpair

class Solution
{
public:
    int minSwaps(string s)
    {
        int n = s.length();
        int unpaired = 0;
        int balance = 0;
        for(int i = 0; i < n; i++)
        {
            if (s[i] == '[') ++balance;
            else --balance;
            if(balance == -1)
            {
                unpaired++;
                balance = 0;
            }
        }

        return (unpaired + 1) / 2;
    }
};


// Source https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/

You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.

For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:

You choose any number of obstacles between 0 and i inclusive.
You must include the ith obstacle in the course.
You must put the chosen obstacles in the same order as they appear in obstacles.
Every obstacle (except the first) is taller than or the same height as the obstacle immediately before it.
Return an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.

 

Example 1:

Input: obstacles = [1,2,3,2]
Output: [1,2,3,3]
Explanation: The longest valid obstacle course at each position is:
- i = 0: [1], [1] has length 1.
- i = 1: [1,2], [1,2] has length 2.
- i = 2: [1,2,3], [1,2,3] has length 3.
- i = 3: [1,2,3,2], [1,2,2] has length 3.
Example 2:

Input: obstacles = [2,2,1]
Output: [1,2,1]
Explanation: The longest valid obstacle course at each position is:
- i = 0: [2], [2] has length 1.
- i = 1: [2,2], [2,2] has length 2.
- i = 2: [2,2,1], [1] has length 1.
Example 3:

Input: obstacles = [3,1,5,6,4,2]
Output: [1,1,2,3,2,2]
Explanation: The longest valid obstacle course at each position is:
- i = 0: [3], [3] has length 1.
- i = 1: [3,1], [1] has length 1.
- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.
- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.
- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.
- i = 5: [3,1,5,6,4,2], [1,2] has length 2.
 

Constraints:

n == obstacles.length
1 <= n <= 105
1 <= obstacles[i] <= 107

class Solution
{
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int> &obstacles)
    {
        int n = obstacles.size();
        vector<int> dp(n, 1e9);
        vector<int> ans(n);
        for (int i = 0; i < n; ++i)
        {
            auto itr = upper_bound(dp.begin(), dp.end(), obstacles[i]);
            *itr = obstacles[i];
            ans[i] = (itr - dp.begin()) + 1;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/

Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word.

A substring is a contiguous sequence of characters within a string.

 

Example 1:

Input: patterns = ["a","abc","bc","d"], word = "abc"
Output: 3
Explanation:
- "a" appears as a substring in "abc".
- "abc" appears as a substring in "abc".
- "bc" appears as a substring in "abc".
- "d" does not appear as a substring in "abc".
3 of the strings in patterns appear as a substring in word.
Example 2:

Input: patterns = ["a","b","c"], word = "aaaaabbbbb"
Output: 2
Explanation:
- "a" appears as a substring in "aaaaabbbbb".
- "b" appears as a substring in "aaaaabbbbb".
- "c" does not appear as a substring in "aaaaabbbbb".
2 of the strings in patterns appear as a substring in word.
Example 3:

Input: patterns = ["a","a","a"], word = "ab"
Output: 3
Explanation: Each of the patterns appears as a substring in word "ab".
 

Constraints:

1 <= patterns.length <= 100
1 <= patterns[i].length <= 100
1 <= word.length <= 100
patterns[i] and word consist of lowercase English letters.

class Solution
{
public:
    int numOfStrings(vector<string> &patterns, string word)
    {
        int res = 0;
        for(auto &str : patterns)
        {
            if(word.find(str) != string::npos) ++res;
        }
        return res;
    }
};


// Source https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/

You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.

More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].

Return any rearrangement of nums that meets the requirements.

 

Example 1:

Input: nums = [1,2,3,4,5]
Output: [1,2,4,5,3]
Explanation:
When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.
When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.
When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.

1 5 2 4 3

Example 2:

Input: nums = [6,2,0,9,7]
Output: [9,7,6,2,0]
Explanation:
When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.
When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.
When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3.

0 9 2 7 6

Constraints:

3 <= nums.length <= 105
0 <= nums[i] <= 105

小 大 小 大 小

class Solution
{
public:
    vector<int> rearrangeArray(vector<int> &nums)
    {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<int> ans(n);
        int low = 0;
        int high = n - 1;
        int index = 0;
        while(index < n)
        {
            if(index % 2 == 0)
            {
                ans[index] = nums[low];
                low++;
            }
            else
            {
                ans[index] = nums[high];
                high--;
            }
            index++;
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-non-zero-product-of-the-array-elements/

You are given a positive integer p. Consider an array nums (1-indexed) that consists of the integers in the inclusive range [1, 2^p - 1] in their binary representations. 
You are allowed to do the following operation any number of times:

Choose two elements x and y from nums.
Choose a bit in x and swap it with its corresponding bit in y. Corresponding bit refers to the bit that is in the same position in the other integer.
For example, if x = 1101 and y = 0011, after swapping the 2nd bit from the right, we have x = 1111 and y = 0001.

Find the minimum non-zero product of nums after performing the above operation any number of times. Return this product modulo 109 + 7.

Note: The answer should be the minimum product before the modulo operation is done.

 

Example 1:

Input: p = 1
Output: 1
Explanation: nums = [1].
There is only one element, so the product equals that element.
Example 2:

Input: p = 2
Output: 6
Explanation: nums = [01, 10, 11].
Any swap would either make the product 0 or stay the same.
Thus, the array product of 1 * 2 * 3 = 6 is already minimized.
Example 3:

Input: p = 3
Output: 1512
Explanation: nums = [001, 010, 011, 100, 101, 110, 111]
- In the first operation we can swap the leftmost bit of the second and fifth elements.
    - The resulting array is [001, 110, 011, 100, 001, 110, 111].
- In the second operation we can swap the middle bit of the third and fourth elements.
    - The resulting array is [001, 110, 001, 110, 001, 110, 111].
The array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512, which is the minimum possible product.
 

Constraints:

1 <= p <= 60

根据数学规律，两数之和为固定值 sum 的 2 个数，它们的最小非零乘积为 (sum - 1) * 1 = sum - 1。

To get the minimum product but not zero, we want to convert as many numbers as we can to 1.
The range of our numbers is pow(2, p) minus 1.
We can convert range/2 numbers to 1.
In this way, range/2 numbers will be 1 and range/2 numbers will be range-1.
The last number in the array - which binary representation will be all 1's - will remain the same.
Example 1:
Let's take example 3 from the problem itself.
p = 3 --> range = 7
array nums: [001, 010, 011, 100, 101, 110, 111]
Can be converted to: [001, 110, 001, 110, 001, 110, 111] --> [1, 6, 1, 6, 1, 6, 7]
product is: 1 * 6 * 1 * 6 * 1 * 6 * 7 = 6 * 6 * 6 * 7 = pow(6, 3) * 7 = pow(range - 1, range/2) * range

001 110 不变
010 101 -> 110 001
011 100 -> 001 110
111 不变

Example 2:
p = 4 --> range = 15
array nums: [0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111]
Can be converted to: [0001, 1110, 0001, 1110, 0001, 1110, 0001, 1110, 0001, 1110, 0001, 1110, 0001, 1110, 1111] --> [1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 15]
product is: 1 * 14 * 1 * 14 * 1 * 14 * 1 * 14 * 1 * 14 * 1 * 14 * 1 * 14 * 15 = 14 * 14 * 14 * 14 * 14 * 14 * 14 * 15 = pow(14, 7) * 15 = pow(range - 1, range/2) * range

0001 1110 不变
0010 1101 -> 1110 0001
0011 1100 -> 1110 0001
0100 1011 -> 1110 0001
0101 1010 -> 1110 0001
0110 1001 -> 1110 0001
0111 1000 -> 1110 0001
1111 不变

Formula: pow(range - 1, range/2) * range
We can do this formula and we're done. But, we are using very large numbers so we have to implement a special pow function which mods the results to make them smaller.

class Solution
{
public:
    const long mod = 1e9 + 7;

    long powmod(long base, long exponent)
    {
        if (exponent == 0) return 1;
        if (exponent == 1) return base % mod;
        long tmp = powmod(base, exponent / 2);
        if (exponent % 2 == 0)
        {
            return (tmp * tmp) % mod;
        }
        else
        {
            tmp = tmp * tmp % mod;
            base %= mod;
            return (tmp * base) % mod;
        }
    }

    int minNonZeroProduct(int p)
    {
        long range = (1LL << p) - 1;
        long tmp = powmod(range - 1, range / 2);
        return (tmp * (range % mod)) % mod;
    }
};


// Source https://leetcode.com/problems/last-day-where-you-can-still-cross/

There is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively.

Initially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. 
You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water 
(i.e., changed to 1).

You want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. 
You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down).

Return the last day where it is possible to walk from the top to the bottom by only walking on land cells.

 

Example 1:


Input: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
Output: 2
Explanation: The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 2.
Example 2:


Input: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
Output: 1
Explanation: The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 1.
Example 3:


Input: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]
Output: 3
Explanation: The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 3.
 

Constraints:

2 <= row, col <= 2 * 104
4 <= row * col <= 2 * 104
cells.length == row * col
1 <= ri <= row
1 <= ci <= col
All the values of cells are unique.


0 represents land and 1 represents water
cells.length == row * col
第n天，所有的cell都为1，第n-1天，有1个cell为0（陆地），... ，第0天所有的cell都为0
从第 n - 1 天往回追溯，将当天变为水域的格子重新变回陆地，结合并查集判断第一行与最后一行的连通性，直至二者打通。
往回追溯时两行连通的当天，就是正向时间轴内它们能够连通的最后一天

class Solution
{
public:

    struct DSU
    {
        vector<int> parent;
        vector<int> size;

        DSU(int n)
        {
            parent = vector<int>(n);
            size = vector<int>(n, 1);
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }

        int count(int x)
        {
            return size[x];
        }
    };

    int latestDayToCross(int row, int col, vector<vector<int>> &cells)
    {
        DSU dsu(row * col + 2);
        int top = row * col; // roof与所有顶层cell相连
        int bottom = row * col + 1; // floor与所有底层cell相连
        vector<vector<int>> mat(row, vector<int>(col, 1));
        int directs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
        for (int d = cells.size() - 1; d >= 0; --d)
        {
            int i = cells[d][0] - 1, j = cells[d][1] - 1;
            mat[i][j] = 0;
            int id = i * col + j;
            if (i == 0) dsu.join(id, top);
            if (i == row - 1) dsu.join(id, bottom);
            for (int k = 0; k < 4; ++k)
            {
                int i_ngb = i + directs[k][0];
                int j_ngb = j + directs[k][1];
                if (i_ngb < 0 || i_ngb >= row || j_ngb < 0 || j_ngb >= col) continue;
                if (mat[i_ngb][j_ngb] == 1) continue;
                int id_ngb = i_ngb * col + j_ngb;
                dsu.join(id, id_ngb);
            }
            if (dsu.find(top) == dsu.find(bottom)) return d;
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/find-if-path-exists-in-graph/

There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). 
The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. 
Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.

You want to determine if there is a valid path that exists from vertex source to vertex destination.

Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.

 

Example 1:


Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
Output: true
Explanation: There are two paths from vertex 0 to vertex 2:
- 0 → 1 → 2
- 0 → 2
Example 2:


Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
Output: false
Explanation: There is no path from vertex 0 to vertex 5.
 

Constraints:

1 <= n <= 2 * 105
0 <= edges.length <= 2 * 105
edges[i].length == 2
0 <= ui, vi <= n - 1
ui != vi
0 <= source, destination <= n - 1
There are no duplicate edges.
There are no self edges.

class Solution
{
public:

    struct DSU
    {
        vector<int> parent;
        vector<int> size;

        DSU(int n)
        {
            parent = vector<int>(n);
            size = vector<int>(n, 1);
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }

        int count(int x)
        {
            return size[x];
        }
    };


    bool validPath(int n, vector<vector<int>> &edges, int start, int end)
    {
        DSU dsu(n);
        for (auto &v : edges)
        {
            dsu.join(v[0], v[1]);
        }
        return dsu.find(start) == dsu.find(end);
    }
};


// Source https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/

There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. 
The pointer is initially pointing to the character 'a'.


Each second, you may perform one of the following operations:

Move the pointer one character counterclockwise or clockwise.
Type the character the pointer is currently on.
Given a string word, return the minimum number of seconds to type out the characters in word.

 

Example 1:

Input: word = "abc"
Output: 5
Explanation: 
The characters are printed as follows:
- Type the character 'a' in 1 second since the pointer is initially on 'a'.
- Move the pointer clockwise to 'b' in 1 second.
- Type the character 'b' in 1 second.
- Move the pointer clockwise to 'c' in 1 second.
- Type the character 'c' in 1 second.
Example 2:

Input: word = "bza"
Output: 7
Explanation:
The characters are printed as follows:
- Move the pointer clockwise to 'b' in 1 second.
- Type the character 'b' in 1 second.
- Move the pointer counterclockwise to 'z' in 2 seconds.
- Type the character 'z' in 1 second.
- Move the pointer clockwise to 'a' in 1 second.
- Type the character 'a' in 1 second.
Example 3:

Input: word = "zjpc"
Output: 34
Explanation:
The characters are printed as follows:
- Move the pointer counterclockwise to 'z' in 1 second.
- Type the character 'z' in 1 second.
- Move the pointer clockwise to 'j' in 10 seconds.
- Type the character 'j' in 1 second.
- Move the pointer clockwise to 'p' in 6 seconds.
- Type the character 'p' in 1 second.
- Move the pointer counterclockwise to 'c' in 13 seconds.
- Type the character 'c' in 1 second.
 

Constraints:

1 <= word.length <= 100
word consists of lowercase English letters.

class Solution
{
public:
    int minTimeToType(string word)
    {
        int ret = 0;
        int pointer = int('a');
        for(char c : word)
        {
            int val = int(c);
            int cnt = abs(val - pointer);
            ret += min(cnt, 26-cnt);
            pointer = val;
            ret++;
        }
        return ret;
    }
};


// Source https://leetcode.com/problems/maximum-matrix-sum/

You are given an n x n integer matrix. You can do the following operation any number of times:

Choose any two adjacent elements of matrix and multiply each of them by -1.
Two elements are considered adjacent if and only if they share a border.

Your goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.

 

Example 1:


Input: matrix = [[1,-1],[-1,1]]
Output: 4
Explanation: We can follow the following steps to reach sum equals 4:
- Multiply the 2 elements in the first row by -1.
- Multiply the 2 elements in the first column by -1.
Example 2:


Input: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
Output: 16
Explanation: We can follow the following step to reach sum equals 16:
- Multiply the 2 last elements in the second row by -1.
 

Constraints:

n == matrix.length == matrix[i].length
2 <= n <= 250
-105 <= matrix[i][j] <= 105

通过一次或多次操作，可使得分散在各处的负元素与相邻元素交换符号，最后所有负元素聚集在一起
如果负元素个数为偶数，则负元素可以全部变为正数
如果负元素个数为奇数，则将绝对值最小的元素保留为负，其他负元素可以全部变为正数

class Solution
{
public:
    long long maxMatrixSum(vector<vector<int>> &matrix)
    {
        int cnt = 0, mnVal = INT_MAX;
        long sum = 0;
        for(auto &row : matrix)
        {
            for(auto x : row)
            {
                int val = abs(x);
                sum += val;
                mnVal = min(mnVal, val);
                if (x < 0) ++cnt;
            }
        }
        if (cnt % 2) return sum - (2 * mnVal);
        return sum;
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/

You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. 
The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.

You are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. 
You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.

Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7.

 

Example 1:


Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
Output: 4
Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.
The four ways to get there in 7 minutes are:
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6
Example 2:

Input: n = 2, roads = [[1,0,10]]
Output: 1
Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.
 

Constraints:

1 <= n <= 200
n - 1 <= roads.length <= n * (n - 1) / 2
roads[i].length == 3
0 <= ui, vi <= n - 1
1 <= timei <= 109
ui != vi
There is at most one road connecting any two intersections.
You can reach any intersection from any other intersection.

class Solution
{
public:
    const long mod = 1e9 + 7;

    int countPaths(int n, vector<vector<int>> &roads)
    {
        vector<vector<pair<int, int>>> adj(n);
        for(auto &v : roads)
        {
            adj[v[0]].push_back({v[1], v[2]});
            adj[v[1]].push_back({v[0], v[2]});
        }
        vector<long> dis(n, 1e16);
        vector<long> path(n, 0);
        priority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> pq;
        path[0] = 1;
        dis[0] = 0;
        pq.push({0, 0});
        while(!pq.empty())
        {
            auto [cost, node] = pq.top();
            pq.pop();
            if (cost > dis[node]) continue;
            for(auto [next, time] : adj[node])
            {
                if(dis[next] > dis[node] + time)
                {
                    dis[next] = dis[node] + time;
                    path[next] = path[node];
                    path[next] %= mod;
                    pq.push({dis[next], next});
                }
                else if(dis[next] == dis[node] + time)
                {
                    path[next] += path[node];
                    path[next] %= mod;
                }
            }
        }
        return path[n - 1];
    }
};


// Source https://leetcode.com/problems/number-of-ways-to-separate-numbers/

You wrote down many positive integers in a string called num. However, you realized that you forgot to add commas to seperate the different numbers. 
You remember that the list of integers was non-decreasing and that no integer had leading zeros.

Return the number of possible lists of integers that you could have written down to get the string num. Since the answer may be large, return it modulo 109 + 7.

 

Example 1:

Input: num = "327"
Output: 2
Explanation: You could have written down the numbers:
3, 27
327
Example 2:

Input: num = "094"
Output: 0
Explanation: No numbers can have leading zeros and all numbers must be positive.
Example 3:

Input: num = "0"
Output: 0
Explanation: No numbers can have leading zeros and all numbers must be positive.
 

Constraints:

1 <= num.length <= 3500
num consists of digits '0' through '9'.

std::basic_string<CharT,Traits,Allocator>::compare
int compare( size_type pos1, size_type count1,
             const basic_string& str,
             size_type pos2, size_type count2 ) const;
比较此 string 的 [pos1, pos1+count1) 子串与 str 的子串 [pos2, pos2+count2) 。若 count1 > size() - pos1 则第一子串为 [pos1, size()) 。
类似地若 count2 > str.size() - pos2 则第二子串为 [pos2, str.size()) 。

dp[i][j] 表示num[i ... n-1] 划分成若干个（j > 0 则 表示划分成至少2个，j = 0 则表示可以划分成1个) non-decreasing 正整数，并且第1个正整数的长度>= j，number of solutions
如果j > 0 && j > (n-i) / 2，此时num[i ... n-1]不可能划分成至少2个non-decreasing，因为 j > 剩余的长度(n -i - j)，则dp[i][j] = 0
如果 j > 0 && j <= (n-i)/ 2 && j > (n-i) / 3 ，此时num[i ... n-1]只能划分成2个，如果 j 刚好等于 剩余的长度(n -i - j)，还要进一步判读两个数的大小关系
如果 j > 0 && j <= (n-i) / 3 ，此时num[i ... n-1] 可以划分成2个、3个等等，第2个正整数的长度与第1个正整数的长度相等时，还要进一步判读两个数的大小关系
如果j = 0，可以划分成1个

如果 j > 0 && j <= (n-i)/ 2 ，dp[i-1][j] = 1 + dp[i-1][j+1] + dp[i-1+j][j]
subtotal 对应 dp[i-1][j+1]
1 对应划分成2个，第1个正整数的长度为j，另一个正整数的长度为剩余所有的长度
dp[i-1+j][j] 对应划分成至少3个，第1个正整数的长度为j

class Solution
{
public:
    int numberOfCombinations(string num)
    {
        if(num[0] == '0') return 0;
        int n = num.size();
        if (n == 1) return 1;
        const int mod = 1e9 + 7;
        vector<vector<int>> dp(n, vector<int>((n / 2) + 1, 0));
        dp[n - 1][0] = 1;
        for(int i = n - 2; i >= 0; --i)
        {
            if(num[i] == '0') continue;
            int len = (n - i);
            int j = len / 2;
            int subtotal = 0;
            if (len % 2 == 0)
            {
                if (num.compare(i, len / 2, num, i + len / 2, len / 2) <= 0)
                {
                    dp[i][j] = 1;
                    subtotal = 1;
                }
                --j;
            }
            for(; j > 0; --j)
            {
                if (num[i + j] == '0')
                {
                    dp[i][j] = subtotal;
                    continue;
                }
                if(j > len / 3)
                {
                    subtotal = (subtotal + 1) % mod;
                    dp[i][j] = subtotal;
                }
                else if(num.compare(i, j, num, i + j, j) <= 0)
                {
                    subtotal = (subtotal + 1 + dp[i + j][j]) % mod;
                    dp[i][j] = subtotal;
                }
                else
                {
                    if(j + 1 <= (n / 2))
                        subtotal = (subtotal + 1 + dp[i + j][j + 1]) % mod;
                    else
                        subtotal = (subtotal + 1) % mod;
                    dp[i][j] = subtotal;
                }
            }
            dp[i][0] = (subtotal + 1) % mod;
        }
        return dp[0][0];
    }
};


// Source https://leetcode.com/problems/find-greatest-common-divisor-of-array/

Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.

 

Example 1:

Input: nums = [2,5,6,9,10]
Output: 2
Explanation:
The smallest number in nums is 2.
The largest number in nums is 10.
The greatest common divisor of 2 and 10 is 2.
Example 2:

Input: nums = [7,5,6,8,3]
Output: 1
Explanation:
The smallest number in nums is 3.
The largest number in nums is 8.
The greatest common divisor of 3 and 8 is 1.
Example 3:

Input: nums = [3,3]
Output: 3
Explanation:
The smallest number in nums is 3.
The largest number in nums is 3.
The greatest common divisor of 3 and 3 is 3.
 

Constraints:

2 <= nums.length <= 1000
1 <= nums[i] <= 1000

class Solution
{
public:
    int findGCD(vector<int> &nums)
    {
        int mxVal = INT_MIN;
        int mnVal = INT_MAX;
        for (auto val : nums)
        {
            mxVal = max(mxVal, val);
            mnVal = min(mnVal, val);
        }
        return __gcd(mxVal, mnVal);
    }
};


// Source https://leetcode.com/problems/find-unique-binary-string/

Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. 
If there are multiple answers, you may return any of them.

 

Example 1:

Input: nums = ["01","10"]
Output: "11"
Explanation: "11" does not appear in nums. "00" would also be correct.
Example 2:

Input: nums = ["00","01"]
Output: "11"
Explanation: "11" does not appear in nums. "10" would also be correct.
Example 3:

Input: nums = ["111","011","001"]
Output: "101"
Explanation: "101" does not appear in nums. "000", "010", "100", and "110" would also be correct.
 

Constraints:

n == nums.length
1 <= n <= 16
nums[i].length == n
nums[i] is either '0' or '1'.
All the strings of nums are unique.

class Solution
{
public:
    string ans;

    bool recur(int n, unordered_set<string> &st, string &curr, int idx)
    {
        if(idx >= n)
        {
            if(st.find(curr) == st.end())
            {
                ans = curr;
                return true;
            }
            return false;
        }
        curr.push_back('0');
        if (recur(n, st, curr, idx + 1)) return true;
        curr.pop_back();
        curr.push_back('1');
        if (recur(n, st, curr, idx + 1)) return true;
        curr.pop_back();
        return false;
    }

    string findDifferentBinaryString(vector<string> &nums)
    {
        unordered_set<string> st(nums.begin(), nums.end());
        int n = nums[0].size();
        string curr = "";
        curr.reserve(n);
        ans = "";
        recur(n, st, curr, 0);
        return ans;
    }
};


// Source https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/

You are given an m x n integer matrix mat and an integer target.

Choose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized.

Return the minimum absolute difference.

The absolute difference between two numbers a and b is the absolute value of a - b.

 

Example 1:


Input: mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13
Output: 0
Explanation: One possible choice is to:
- Choose 1 from the first row.
- Choose 5 from the second row.
- Choose 7 from the third row.
The sum of the chosen elements is 13, which equals the target, so the absolute difference is 0.
Example 2:


Input: mat = [[1],[2],[3]], target = 100
Output: 94
Explanation: The best possible choice is to:
- Choose 1 from the first row.
- Choose 2 from the second row.
- Choose 3 from the third row.
The sum of the chosen elements is 6, and the absolute difference is 94.
Example 3:


Input: mat = [[1,2,9,8,7]], target = 6
Output: 1
Explanation: The best choice is to choose 7 from the first row.
The absolute difference is 1.
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 70
1 <= mat[i][j] <= 70
1 <= target <= 800

class Solution
{
public:
    int m, n;
    int dp[71][6000];

    int recur(vector<vector<int>> &mat, int target, int index, int sum)
    {
        if(index == m) return abs(sum - target);
        if(dp[index][sum] != -1) return dp[index][sum];
        int res = 1e9;
        if(sum < target)
        {
            for(int i = 0; i < n; i++)
                res = min(res, recur(mat, target, index + 1, sum + mat[index][i]));
        }
        else
        {
            res = min(res, recur(mat, target, index + 1, sum + *min_element(mat[index].begin(), mat[index].end())));
        }
        return dp[index][sum] = res;
    }

    int minimizeTheDifference(vector<vector<int>> &mat, int target)
    {
        m = mat.size();
        n = mat[0].size();
        memset(dp, -1, sizeof(dp));
        return recur(mat, target, 0, 0);
    }
};


// Source https://leetcode.com/problems/find-array-given-subset-sums/

You are given an integer n representing the length of an unknown array that you are trying to recover. 
You are also given an array sums containing the values of all 2^n subset sums of the unknown array (in no particular order).

Return the array ans of length n representing the unknown array. If multiple answers exist, return any of them.

An array sub is a subset of an array arr if sub can be obtained from arr by deleting some (possibly zero or all) elements of arr. 
The sum of the elements in sub is one possible subset sum of arr. The sum of an empty array is considered to be 0.

Note: Test cases are generated such that there will always be at least one correct answer.

 

Example 1:

Input: n = 3, sums = [-3,-2,-1,0,0,1,2,3]
Output: [1,2,-3]
Explanation: [1,2,-3] is able to achieve the given subset sums:
- []: sum is 0
- [1]: sum is 1
- [2]: sum is 2
- [1,2]: sum is 3
- [-3]: sum is -3
- [1,-3]: sum is -2
- [2,-3]: sum is -1
- [1,2,-3]: sum is 0
Note that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted.
Example 2:

Input: n = 2, sums = [0,0,0,0]
Output: [0,0]
Explanation: The only correct answer is [0,0].
Example 3:

Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]
Output: [0,-1,4,5]
Explanation: [0,-1,4,5] is able to achieve the given subset sums.
 

Constraints:

1 <= n <= 15
sums.length == 2n
-104 <= sums[i] <= 104


This can be solved using 2 facts.
Fact 1:
Suppose that we have a array A and its corresponding subset sum array be B. Now lets introduce element x in the array A, 
then the subset sum array of this newly formed array will be {b1, b2 , ..., bn , b1+x, b2+x, ....., bn+x}.

Fact 2:
let x=最小的 element in subarray sum array and y= 第二小的 element in subarray sum array.
Then one of the element of the original array will be (x-y) or (y-x).

按照升序排序数组 sums ，那么 sums[1] 对应的集合与sums[0] 对应的集合的不同之处是选择或不选择一个绝对值最小的数 x（这样，两者变化量最小） 。

Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]
Output: [0,-1,4,5]

0 0 5 5 4 4 -1 -1 9 9 4 3 4 8 3 8 排序前
-1 -1 0 0 3 3 4 4 4 4 5 5 8 8 9 9 排序后 一个元素为0（f2 加x的y推导出了-1，4，5，证明加x等价于不选择-x，则元素为负数或0）

-1 0 3 4 4 5 8 9 f1
-1 0 3 4 4 5 8 9 f2 一个元素为-1（f2 加x的y推导出了4，5，证明加x等价于不选择-x，则元素为负数或0）

-1 3 4 8 f1
0  4 5 9 f2    一个元素为4（f1 不加x的y推导出了5，证明不加x等价于不选择x，则元素为正数或0）

-1 4 f1 不合理
3 8 f2  不合理
0 5 f1  一个元素为5（两个元素，至少一个元素为0 对应 任何元素都不选择的subset sum，如果两个都为0，则这个剩下的元素也为0，如果一个不为0，则不为0的值就是对应的一个元素的值）
4 9 f2  不合理

不选择第1个元素，再不选择第2个元素，再不选择第3个元素，...
每次递归，都要不选择一个绝对值最小的数

class Solution
{
public:
    vector<int> ans;

    int ch[20009];
    int ls[20009];

    int fun(vector<int> &a)
    {
        int n = a.size();

        if(n == 2)
        {
            if(a[0] != 0 && a[1] != 0)
            {
                return 0;
            }

            if(a[0] == 0)
            {
                ans.push_back(a[1]);
                return 1;
            }
            else
            {
                ans.push_back(a[0]);
                return 1;
            }
        }

        int x = a[1] - a[0];

        for(int i=0; i<n ;i++)
        {
            ls[a[i] + 10000]++;
        }

        vector<int > f1, f2;

        int u = 0;

        for(int i=0; i<n ;i++)
        {
            if(ch[a[i] + 10000] != 0) // ch[a[i] + 10000] 对应 ch[y + x + 10000]，避免f1和f2重复push_back
            {
                ch[a[i] + 10000]--;
                continue;
            }

            int y = a[i];

            if(ls[y + x + 10000] != 0)
            {
                f1.push_back(y);
                f2.push_back(y + x);
                ls[y + 10000]--;
                ls[y + x + 10000]--;
                ch[y + x + 10000]++;
            }
            else
            {
                u = 1;
                break;
            }
        }

        for(int i=0; i<n ;i++)
        {
            ch[a[i] + 10000] = 0;
            ls[a[i] + 10000] = 0;
        }

        if(u == 1)
        {
            return 0;
        }

        bool x1 = fun(f1);

        if(x1 == 1)
        {
            ans.push_back(x);
            return 1;
        }

        bool x2 = fun(f2);

        if(x2 == 1)
        {
            ans.push_back(-1 * x);
            return 1;
        }

        return 0;
    }

    vector<int> recoverArray(int n, vector<int> &sums)
    {
        sort(sums.begin(), sums.end());
        ans.clear();
        fun(sums);
        return ans;
    }
};


// Source https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/

You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.

Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.

Return the minimum possible difference.

 

Example 1:

Input: nums = [90], k = 1
Output: 0
Explanation: There is one way to pick score(s) of one student:
- [90]. The difference between the highest and lowest score is 90 - 90 = 0.
The minimum possible difference is 0.
Example 2:

Input: nums = [9,4,1,7], k = 2
Output: 2
Explanation: There are six ways to pick score(s) of two students:
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.
- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.
The minimum possible difference is 2.
 

Constraints:

1 <= k <= nums.length <= 1000
0 <= nums[i] <= 105

class Solution
{
public:
    int minimumDifference(vector<int> &nums, int k)
    {
        int n = nums.size();
        if(n == 1) return 0;
        sort(nums.begin(), nums.end());
        int res = INT_MAX;
        for(int i = 0; i <= n - k; i++)
        {
            res = min(res, nums[i + k - 1] - nums[i]);
        }
        return res;
    }
};


// Source https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/

You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.

Return the string that represents the kth largest integer in nums.

Note: Duplicate numbers should be counted distinctly. For example, if nums is ["1","2","2"], "2" is the first largest integer, "2" is the second-largest integer, and "1" is the third-largest integer.

 

Example 1:

Input: nums = ["3","6","7","10"], k = 4
Output: "3"
Explanation:
The numbers in nums sorted in non-decreasing order are ["3","6","7","10"].
The 4th largest integer in nums is "3".
Example 2:

Input: nums = ["2","21","12","1"], k = 3
Output: "2"
Explanation:
The numbers in nums sorted in non-decreasing order are ["1","2","12","21"].
The 3rd largest integer in nums is "2".
Example 3:

Input: nums = ["0","0"], k = 2
Output: "0"
Explanation:
The numbers in nums sorted in non-decreasing order are ["0","0"].
The 2nd largest integer in nums is "0".
 

Constraints:

1 <= k <= nums.length <= 104
1 <= nums[i].length <= 100
nums[i] consists of only digits.
nums[i] will not have any leading zeros.

class Solution
{
public:
    string kthLargestNumber(vector<string> &nums, int k)
    {
        auto cmp = [](string &s1, string &s2) -> bool {
            if (s1.length() == s2.length()) return s1 > s2;
            return s1.length() > s2.length();
        };
        priority_queue<string, vector<string>, decltype(cmp)> pq(cmp);
        for (auto &str : nums)
        {
            pq.push(str);
            if (pq.size() > k) pq.pop();
        }
        return pq.top();
    }
};


// Source https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/

There are n tasks assigned to you. The task times are represented as an integer array tasks of length n, where the ith task takes tasks[i] hours to finish. 
A work session is when you work for at most sessionTime consecutive hours and then take a break.

You should finish the given tasks in a way that satisfies the following conditions:

If you start a task in a work session, you must complete it in the same work session.
You can start a new task immediately after finishing the previous one.
You may complete the tasks in any order.
Given tasks and sessionTime, return the minimum number of work sessions needed to finish all the tasks following the conditions above.

The tests are generated such that sessionTime is greater than or equal to the maximum element in tasks[i].

 

Example 1:

Input: tasks = [1,2,3], sessionTime = 3
Output: 2
Explanation: You can finish the tasks in two work sessions.
- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.
- Second work session: finish the third task in 3 hours.
Example 2:

Input: tasks = [3,1,3,1,1], sessionTime = 8
Output: 2
Explanation: You can finish the tasks in two work sessions.
- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.
- Second work session: finish the last task in 1 hour.
Example 3:

Input: tasks = [1,2,3,4,5], sessionTime = 15
Output: 1
Explanation: You can finish all the tasks in one work session.
 

Constraints:

n == tasks.length
1 <= n <= 14
1 <= tasks[i] <= 10
max(tasks[i]) <= sessionTime <= 15

class Solution
{
public:
    int n;
    int mask;
    short dp[16][16500];

    short recur(int session, int completedTasks, vector<int> &tasks, int sessionTime)
    {
        if(completedTasks == mask) return 1;
        if(dp[session][completedTasks] != -1) return dp[session][completedTasks];
        bool isAvail = false;
        short res = 1e3;
        for(int i = 0; i < n; i++)
        {
            if((completedTasks & (1 << i)) == 0 && tasks[i] <= session)
            {
                isAvail = true;
                res = min(res, recur(session - tasks[i], completedTasks | (1 << i), tasks, sessionTime));
            }
        }

        if(!isAvail)
        {
            res = 1 + recur(sessionTime, completedTasks, tasks, sessionTime);
        }

        return dp[session][completedTasks] = res;
    }

    int minSessions(vector<int> &tasks, int sessionTime)
    {
        n = tasks.size();
        mask = (1 << n) - 1;
        memset(dp, -1, sizeof(dp));
        int completedTasks = 0;
        return recur(sessionTime, completedTasks, tasks, sessionTime);
    }
};


// Source https://leetcode.com/problems/number-of-unique-good-subsequences/

You are given a binary string binary. A subsequence of binary is considered good if it is not empty and has no leading zeros (with the exception of "0").

Find the number of unique good subsequences of binary.

For example, if binary = "001", then all the good subsequences are ["0", "0", "1"], so the unique good subsequences are "0" and "1". Note that subsequences "00", "01", and "001" are not good because they have leading zeros.
Return the number of unique good subsequences of binary. Since the answer may be very large, return it modulo 109 + 7.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

 

Example 1:

Input: binary = "001"
Output: 2
Explanation: The good subsequences of binary are ["0", "0", "1"].
The unique good subsequences are "0" and "1".
Example 2:

Input: binary = "11"
Output: 2
Explanation: The good subsequences of binary are ["1", "1", "11"].
The unique good subsequences are "1" and "11".
Example 3:

Input: binary = "101"
Output: 5
Explanation: The good subsequences of binary are ["1", "0", "1", "10", "11", "101"]. 
The unique good subsequences are "0", "1", "10", "11", and "101".
 

Constraints:

1 <= binary.length <= 105
binary consists of only '0's and '1's.


dp[i][j] 表示 binary[0 ... i] 中以字符 1 开始，以 j（0或1） 结尾的不同好子序列的个数

1001
dp[i-1][0] -> 10 100                  末尾为1个0，末尾为至少2个0
dp[i-1][1] -> 1 11 101 1001       末尾为1个1，末尾为至少2个1

1001 0
dp[i][0] -> 10 100 1000 110 1010 10010 末尾为1 + 0 = 末尾为1个0，末尾为1个0 + 0 = 末尾为2个0，末尾为至少2个0 + 0 = 末尾为至少3个0
新的末尾为1个0 包括了 原来的末尾为1个0，因为末尾为1个0，这个0的前1位必须为1，因此去掉原来的末尾为1个0中的那个0，剩下的部分属于dp[i-1][1] 末尾为1中的一部分
原来的末尾为1个0 + 0 包括了 原来的末尾为2个0，原来的末尾为2个0 + 0 包括了 原来的末尾为3个0，...

dp[i][0] = dp[i - 1][0] + dp[i - 1][1]

dp[i][1] -> 1 11 101 1001

dp[i][1] = dp[i - 1][1]


1001 1
dp[i][0] -> 10 100 

dp[i][0] = dp[i - 1][0]

dp[i][1] -> 1 11 101 1001 111 1011 10011 末尾为0 + 1 = 末尾为1个1，末尾为1个1 + 1 = 末尾为2个1，末尾为至少2个1 + 1 = 末尾为至少3个1
新的末尾为1个1 包括了 原来的末尾为1个1（单个1除外），因为末尾为1个1，这个1的前1位必须为0或为空，因此去掉原来的末尾为1个1中的那个1，剩下的不为空的部分属于dp[i-1][0] 末尾为0中的一部分
原来的末尾为1个1 + 1 包括了 原来的末尾为2个1，原来的末尾为2个1 + 1 包括了 原来的末尾为3个1，...

dp[i][1] = dp[i - 1][0] + dp[i - 1][1] + 1（单个1）

1010
dp[i-1][0] -> 10 100 110 1010
dp[i-1][1] -> 1 11 101

1010 0
dp[i][0] -> 10 100 110 1010 1000 1100 10100 末尾为1 + 0 = 末尾为1个0，末尾为1个0 + 0 = 末尾为2个0，末尾为至少2个0 + 0 = 末尾为至少3个0
新的末尾为1个0 包括了 原来的末尾为1个0，因为末尾为1个0，这个0的前1位必须为1，因此去掉原来的末尾为1个0中的那个0，剩下的部分属于dp[i-1][1] 末尾为1中的一部分
原来的末尾为1个0 + 0 包括了 原来的末尾为2个0，原来的末尾为2个0 + 0 包括了 原来的末尾为3个0，...

dp[i][0] = dp[i - 1][0] + dp[i - 1][1]

dp[i][1] -> 1 11 101

dp[i][1] = dp[i - 1][1]


1010 1
dp[i][0] -> 10 100 110 1010

dp[i][0] = dp[i - 1][0]

dp[i][1] -> 1 11 101 111 1011 1001 1101 10101 末尾为0 + 1 = 末尾为1个1，末尾为1个1 + 1 = 末尾为2个1，末尾为至少2个1 + 1 = 末尾为至少3个1
新的末尾为1个1 包括了 原来的末尾为1个1（单个1除外），因为末尾为1个1，这个1的前1位必须为0或为空，因此去掉原来的末尾为1个1中的那个1，剩下的不为空的部分属于dp[i-1][0] 末尾为0中的一部分
原来的末尾为1个1 + 1 包括了 原来的末尾为2个1，原来的末尾为2个1 + 1 包括了 原来的末尾为3个1，...

dp[i][1] = dp[i - 1][0] + dp[i - 1][1] + 1（单个1）

endswith[0] 表示以1开始，以0结尾的不同好子序列的个数
endswith[1] 表示以1开始，以1结尾的不同好子序列的个数

haszero 对应 单个0

class Solution
{
public:
    int numberOfUniqueGoodSubsequences(string binary)
    {
        long endswith[2] = {0};
        const long mod = 1e9 + 7;
        bool haszero = false;
        for (char c : binary)
        {
            haszero |= (c == '0');
            endswith[c - '0'] = (endswith[0] + endswith[1] + (c == '0' ? 0L : 1L)) % mod;
        }
        return (endswith[0] + endswith[1] + haszero) % mod;
    }
};


// Source https://leetcode.com/problems/find-the-middle-index-in-array/

Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).

A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].

If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.

Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.

 

Example 1:

Input: nums = [2,3,-1,8,4]
Output: 3
Explanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4
The sum of the numbers after index 3 is: 4 = 4
Example 2:

Input: nums = [1,-1,4]
Output: 2
Explanation: The sum of the numbers before index 2 is: 1 + -1 = 0
The sum of the numbers after index 2 is: 0
Example 3:

Input: nums = [2,5]
Output: -1
Explanation: There is no valid middleIndex.
 

Constraints:

1 <= nums.length <= 100
-1000 <= nums[i] <= 1000

class Solution
{
public:
    int findMiddleIndex(vector<int> &nums)
    {
        int n = nums.size();
        int rightSum = 0, leftSum = 0;
        for(int i = 0; i < n; i++)
        {
            rightSum += nums[i];
        }
        for(int i = 0; i < n; i++)
        {
            rightSum -= nums[i];
            if(rightSum == leftSum)
            {
                return i;
            }
            leftSum += nums[i];
        }
        return -1;
    }
};


// Source https://leetcode.com/problems/find-all-groups-of-farmland/

You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.

To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. 
These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.

land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). 
Find the coordinates of the top left and bottom right corner of each group of farmland. 
A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].

Return a 2D array containing the 4-length arrays described above for each group of farmland in land. 
If there are no groups of farmland, return an empty array. You may return the answer in any order.

 

Example 1:


Input: land = [[1,0,0],[0,1,1],[0,1,1]]
Output: [[0,0,0,0],[1,1,2,2]]
Explanation:
The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].
The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].
Example 2:


Input: land = [[1,1],[1,1]]
Output: [[0,0,1,1]]
Explanation:
The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].
Example 3:


Input: land = [[0]]
Output: []
Explanation:
There are no groups of farmland.
 

Constraints:

m == land.length
n == land[i].length
1 <= m, n <= 300
land consists of only 0's and 1's.
Groups of farmland are rectangular in shape.

class Solution
{
public:
    int n, m;
    int xmin, ymin, xmax, ymax;
    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
 
   void dfs(int x, int y, vector<vector<int>> &land)
    {
        xmin = min(x, xmin);
        ymin = min(y, ymin);
        xmax = max(x, xmax);
        ymax = max(y, ymax);
        land[x][y] = 0;
        for(int i = 0; i < 4; i++)
        {
            int row = x + dirs[i][0];
            int col = y + dirs[i][1];
            if(row >= 0 && col >= 0 && row < n && col < m && land[row][col] == 1)
            {
                dfs(row, col, land);
            }
        }
    }

    vector<vector<int>> findFarmland(vector<vector<int>> &land)
    {
        n = land.size();
        m = land[0].size();
        vector<vector<int>> ans;
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < m; j++)
            {
                if(land[i][j] == 1)
                {
                    xmin = INT_MAX, ymin = INT_MAX, xmax = INT_MIN, ymax = INT_MIN;
                    dfs(i, j, land);
                    ans.push_back({xmin, ymin, xmax, ymax});
                }
            }
        }
        return ans;
    }
};


// Source https://leetcode.com/problems/operations-on-tree/

You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of the ith node. 
The root of the tree is node 0, so parent[0] = -1 since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.

The data structure should support the following functions:

Lock: Locks the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.
Unlock: Unlocks the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.
Upgrade: Locks the given node for the given user and unlocks all of its descendants regardless of who locked it. You may only upgrade a node if all 3 conditions are true:
The node is unlocked,
It has at least one locked descendant (by any user), and
It does not have any locked ancestors.
Implement the LockingTree class:

LockingTree(int[] parent) initializes the data structure with the parent array.
lock(int num, int user) returns true if it is possible for the user with id user to lock the node num, or false otherwise. If it is possible, the node num will become locked by the user with id user.
unlock(int num, int user) returns true if it is possible for the user with id user to unlock the node num, or false otherwise. If it is possible, the node num will become unlocked.
upgrade(int num, int user) returns true if it is possible for the user with id user to upgrade the node num, or false otherwise. If it is possible, the node num will be upgraded.
 

Example 1:


Input
["LockingTree", "lock", "unlock", "unlock", "lock", "upgrade", "lock"]
[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
Output
[null, true, false, true, true, true, false]

Explanation
LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
lockingTree.lock(2, 2);    // return true because node 2 is unlocked.
                           // Node 2 will now be locked by user 2.
lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.
lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.
                           // Node 2 will now be unlocked.
lockingTree.lock(4, 5);    // return true because node 4 is unlocked.
                           // Node 4 will now be locked by user 5.
lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).
                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.
lockingTree.lock(0, 1);    // return false because node 0 is already locked.
 

Constraints:

n == parent.length
2 <= n <= 2000
0 <= parent[i] <= n - 1 for i != 0
parent[0] == -1
0 <= num <= n - 1
1 <= user <= 104
parent represents a valid tree.
At most 2000 calls in total will be made to lock, unlock, and upgrade.

class LockingTree
{
public:
    int n;
    vector<int> mutex;
    vector<vector<int>> children;
    vector<int> parent;
    vector<int> childVec;

    LockingTree(vector<int> &parent)
    {
        n = parent.size();
        mutex.resize(n);
        children.resize(n);
        this->parent = parent;
        childVec.reserve(128);
        for(int i = 0; i < n; i++)
        {
            if(parent[i] == -1)continue;
            children[parent[i]].push_back(i);
        }
    }

    bool lock(int num, int user)
    {
        if(mutex[num] > 0) return false; //already locked
        mutex[num] = user;              //node is locked by user
        return true;
    }

    bool unlock(int num, int user)
    {
        if(mutex[num] != user)return false; //node is locked by some other user or node is not locked at all
        mutex[num] = 0;                     //unlock the lock and return true
        return true;
    }

    bool upgrade(int num, int user)
    {
        int k = num;
        while(k != -1)
        {
            if(mutex[k] > 0)return false;   //atleast one of the ancestor is locked and hence return false
            k = parent[k];
        }

        //bfs
        queue<int> q;
        q.push(num);
        bool flag = false;
        childVec.clear();
        while(!q.empty())
        {
            auto z = q.front();
            q.pop();
            for(auto child : children[z])
            {
                if(mutex[child] > 0)    //atleast one in descendants is locked, hence flag is true
                {
                    childVec.push_back(child);
                    flag = true;
                }
                q.push(child);
            }
        }
        if(flag) 
        {
            mutex[num] = user;
            for (auto child : childVec)
            {
                mutex[child] = 0;
            }
            return true;
        }
        return false;
    }
};


// Source https://leetcode.com/problems/the-number-of-good-subsets/

You are given an integer array nums. We call a subset of nums good if its product can be represented as a product of one or more distinct prime numbers.

For example, if nums = [1, 2, 3, 4]:
[2, 3], [1, 2, 3], and [1, 3] are good subsets with products 6 = 2*3, 6 = 2*3, and 3 = 3 respectively.
[1, 4] and [4] are not good subsets with products 4 = 2*2 and 4 = 2*2 respectively.
Return the number of different good subsets in nums modulo 109 + 7.

A subset of nums is any array that can be obtained by deleting some (possibly none or all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.

 

Example 1:

Input: nums = [1,2,3,4]
Output: 6
Explanation: The good subsets are:
- [1,2]: product is 2, which is the product of distinct prime 2.
- [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [1,3]: product is 3, which is the product of distinct prime 3.
- [2]: product is 2, which is the product of distinct prime 2.
- [2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [3]: product is 3, which is the product of distinct prime 3.
Example 2:

Input: nums = [4,2,3,15]
Output: 5
Explanation: The good subsets are:
- [2]: product is 2, which is the product of distinct prime 2.
- [2,3]: product is 6, which is the product of distinct primes 2 and 3.
- [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.
- [3]: product is 3, which is the product of distinct prime 3.
- [15]: product is 15, which is the product of distinct primes 3 and 5.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 30


Few Oberservation

Need to maintain the frequency counter for each number
Total prime number less than 30 is 10 (can use bitmask to track the used prime number)
2,3,5,7,11,13,17,19,23,29
Handle the case of 1 differently
Each number from 1 to 30 can repersented as prime mask i.e. bit for the prime number can be set to 1 which divisior of this number. 
If same prime number divides the number more that one time we can set mask for that number 0. For example MASK[4] = MASK[8] = MASK[9] = 0 , etc

假设nums中有5个不同的数（比如2，3，5，7，11），这5个数各自出现的次数为a,b,c,d,e
这5个数选1个、2个、3个等等，its product can be represented as a product of one or more distinct prime numbers.
包含第1个数（比如2）的subset的种类为a + a * b + a * b * c + a * b * c * d + a * b * c * d * e = a * (1 + b * (1 + c * (1 + d * (1 + e * (1 + 0)))))
2
2 * 3
2 * 3 * 5
2 * 3 * 5 * 7
2 * 3 * 5 * 7 * 11
3
3 * 5
3 * 5 * 7
3 * 5 * 7 * 11
5
5 * 7
5 * 7 * 11
7
7 * 11
11

dp[last][mask] 表示已经使用的数的最大值为last，当前可用的数从last + 1开始，已经使用的质数下标对应mask中为1的bit位， the number of different good subsets

class Solution
{
public:
    int prime[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    int MASK[31], seen[31];
    long dp[31][1050];
    const long mod = 1e9 + 7;

    long powmod(long base, long exponent)
    {
        long ans = 1;
        while(exponent > 0)
        {
            if(exponent & 1) ans = (ans * base) % mod;
            base = (base * base) % mod;
            exponent /= 2;
        }
        return ans;
    }

    long recur(int last, int mask)
    {
        if (dp[last][mask] != -1) return dp[last][mask];
        long ret = 1;
        for (int i = last + 1; i <= 30; ++i)
        {
            if (seen[i] > 0 && MASK[i] > 0 && (MASK[i]&mask) == 0)
            {
                long cnt = seen[i];
                ret += (cnt * recur(i, mask | MASK[i])) % mod;
                ret %= mod;
            }
        }
        return dp[last][mask] = ret;
    }

    int numberOfGoodSubsets(vector<int> &nums)
    {
        memset(MASK, 0, sizeof(MASK));
        memset(seen, 0, sizeof(seen));
        memset(dp, -1, sizeof(dp));
        for (int val : nums) seen[val]++;
        for (int i = 1 ; i <= 30; ++i)
        {
            if (seen[i] == 0) continue;
            int mask = 0, len = 10;
            int val = i;
            for (int j = 0; j < len; j++)
            {
                if (val % prime[j] == 0)
                {
                    int cnt = 0;
                    while (val % prime[j] == 0) val /= prime[j], cnt++;
                    if (cnt > 1)
                    {
                        mask = 0;
                        break;
                    }
                    mask |= (1 << j);
                }
            }
            MASK[i] = mask;
        }
        long ans = 0, one_cnt = seen[1];
        for (int i = 2; i <= 30; ++i)
        {
            if (seen[i] > 0 && MASK[i] > 0)
            {
                long cnt = seen[i];
                ans += (cnt * recur(i, MASK[i])) % mod;
                ans %= mod;
            }
        }
        auto multi = powmod(2, one_cnt);
        ans = (multi * ans) % mod;
        return ans;
    }
};


// Source https://leetcode.com/problems/count-special-quadruplets/

Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:

nums[a] + nums[b] + nums[c] == nums[d], and
a < b < c < d
 

Example 1:

Input: nums = [1,2,3,6]
Output: 1
Explanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6.
Example 2:

Input: nums = [3,3,6,4,5]
Output: 0
Explanation: There are no such quadruplets in [3,3,6,4,5].
Example 3:

Input: nums = [1,1,1,3,5]
Output: 4
Explanation: The 4 quadruplets that satisfy the requirement are:
- (0, 1, 2, 3): 1 + 1 + 1 == 3
- (0, 1, 3, 4): 1 + 1 + 3 == 5
- (0, 2, 3, 4): 1 + 1 + 3 == 5
- (1, 2, 3, 4): 1 + 1 + 3 == 5
 

Constraints:

4 <= nums.length <= 50
1 <= nums[i] <= 100

class Solution
{
public:
    int countQuadruplets(vector<int> &nums)
    {
        int n = nums.size();
        unordered_map<int, int> mp;
        int res = 0;
        for(int c = 2; c < n - 1; ++c)
        {
            int j = c - 1;
            for(int i = 0; i < j; ++i)
            {
                mp[nums[i] + nums[j]]++;
            }
            for(int d = c + 1; d < n; ++d)
            {
                res += mp[nums[d] - nums[c]];
            }
        }
        return res;
    }
};


// Source https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/

You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. 
You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.

A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. 
More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.

Return the number of weak characters.

 

Example 1:

Input: properties = [[5,5],[6,3],[3,6]]
Output: 0
Explanation: No character has strictly greater attack and defense than the other.
Example 2:

Input: properties = [[2,2],[3,3]]
Output: 1
Explanation: The first character is weak because the second character has a strictly greater attack and defense.
Example 3:

Input: properties = [[1,5],[10,4],[4,3]]
Output: 1
Explanation: The third character is weak because the second character has a strictly greater attack and defense.
 

Constraints:

2 <= properties.length <= 105
properties[i].length == 2
1 <= attacki, defensei <= 105

class Solution
{
public:
    int numberOfWeakCharacters(vector<vector<int>> &properties)
    {
        sort(properties.begin(), properties.end(), [] (auto &v1, auto &v2) -> bool {
            if (v1[0] == v2[0]) return v1[1] > v2[1];
            return v1[0] < v2[0];
        });
        int n = properties.size();
        int res = 0;
        vector<int> defenses;
        for(int i = 0, pre_attack = -1; i < n; ++i)
        {
            if(properties[i][0] == pre_attack)
            {
                defenses.push_back(properties[i][1]);
            }
            else
            {
                while(!defenses.empty() && defenses.back() < properties[i][1])
                {
                    defenses.pop_back();
                    res++;
                }
                defenses.push_back(properties[i][1]);
            }
            pre_attack = properties[i][0];
        }
        return res;
    }
};


// Source https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/

There are n rooms you need to visit, labeled from 0 to n - 1. Each day is labeled, starting from 0. You will go in and visit one room a day.

Initially on day 0, you visit room 0. The order you visit the rooms for the coming days is determined by the following rules and a given 0-indexed array nextVisit of length n:

Assuming that on a day, you visit room i,
if you have been in room i an odd number of times (including the current visit), on the next day you will visit a room with a lower or equal room number specified by nextVisit[i] 
where 0 <= nextVisit[i] <= i;
if you have been in room i an even number of times (including the current visit), on the next day you will visit room (i + 1) mod n.
Return the label of the first day where you have been in all the rooms. It can be shown that such a day exists. Since the answer may be very large, return it modulo 109 + 7.

 

Example 1:

Input: nextVisit = [0,0]
Output: 2
Explanation:
- On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.
  On the next day you will visit room nextVisit[0] = 0
- On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.
  On the next day you will visit room (0 + 1) mod 2 = 1
- On day 2, you visit room 1. This is the first day where you have been in all the rooms.
Example 2:

Input: nextVisit = [0,0,2]
Output: 6
Explanation:
Your room visiting order for each day is: [0,0,1,0,0,1,2,...].
Day 6 is the first day where you have been in all the rooms.
Example 3:

Input: nextVisit = [0,1,2,0]
Output: 6
Explanation:
Your room visiting order for each day is: [0,0,1,1,2,2,3,...].
Day 6 is the first day where you have been in all the rooms.
 

Constraints:

n == nextVisit.length
2 <= n <= 105
0 <= nextVisit[i] <= i


[0,0,2,1,2,3]
0 0 1 0 0 1 2 2 3 1 0 0 1 2 2 3 4 2 2 3 1 0 0 1 2 2 3 4 5

第一次到达房间i，下一步回访房间nextVisit[i]，此时小于i的房间都到达了偶数次
如果nextVisit[i] < i，则回访房间nextVisit[i]后，再次到达房间i，整个过程与第一次到达房间nextVisit[i]，再经过若干步，到达房间i的过程一样，因为都是奇数次访问房间nextVisit[i]

steps[i] 表示第一次到达房间 i 时的天数，则
steps[i] = steps[i - 1] + 1 + (steps[i - 1] - steps[nextVisit[i - 1]]) + 1 = 2 * steps[i - 1] - steps[nextVisit[i - 1]] + 2
                              从steps[i - 1] 跳到 steps[nextVisit[i - 1]] 算1天  从steps[i - 1] 跳到 steps[i] 算1天

class Solution
{
public:
    int firstDayBeenInAllRooms(vector<int> &nextVisit)
    {
        int n = nextVisit.size();
        const long mod = 1e9 + 7;
        vector<long> dp(n);
        for (int i = 1; i < n; i++)
        {
            dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2 + mod) % mod;
        }
        return dp[n - 1];
    }
};


// Source https://leetcode.com/problems/gcd-sort-of-an-array/

You are given an integer array nums, and you can perform the following operation any number of times on nums:

Swap the positions of two elements nums[i] and nums[j] if gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest common divisor of nums[i] and nums[j].
Return true if it is possible to sort nums in non-decreasing order using the above swap method, or false otherwise.

 

Example 1:

Input: nums = [7,21,3]
Output: true
Explanation: We can sort [7,21,3] by performing the following operations:
- Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3]
- Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21]
Example 2:

Input: nums = [5,2,6,2]
Output: false
Explanation: It is impossible to sort the array because 5 cannot be swapped with any other element.
Example 3:

Input: nums = [10,5,9,3,15]
Output: true
We can sort [10,5,9,3,15] by performing the following operations:
- Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10]
- Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10]
- Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15]
 

Constraints:

1 <= nums.length <= 3 * 104
2 <= nums[i] <= 105

class Solution
{
public:

    struct DSU
    {
        vector<int> parent;
        vector<int> size;

        DSU(int n)
        {
            parent = vector<int>(n);
            size = vector<int>(n, 1);
            for(int i = 0; i < n; i++)
            {
                parent[i] = i;
            }
        }

        int find(int x)
        {
            if(parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }

        bool join(int a, int b)
        {
            int root_a = find(a);
            int root_b = find(b);
            if (root_a == root_b) return false;
            if (size[root_a] > size[root_b])
            {
                parent[root_b] = root_a;
                size[root_a] += size[root_b];
            }
            else
            {
                parent[root_a] = root_b;
                size[root_b] += size[root_a];
            }
            return true;
        }

        int count(int x)
        {
            return size[x];
        }
    };

    bool gcdSort(vector<int> &nums)
    {
        int n = nums.size();
        int mxVal = *max_element(nums.begin(), nums.end()) ;
        DSU dsu(mxVal + 1) ;
        for(int val : nums)
        {
            for(int j = 2 ; j * j <= val; ++j)
            {
                if(val % j == 0)
                {
                    dsu.join(val, j) ;
                    dsu.join(val, val / j) ;
                }
            }
        }
        vector<int> r = nums;
        sort(r.begin(), r.end()) ;
        for(int i = 0 ; i < n ; i++)
        {
            if(r[i] != nums[i] && dsu.find(r[i]) != dsu.find(nums[i]))  return false ;
        }
        return true ;
    }
};


// Source https://leetcode.com/problems/reverse-prefix-of-word/

Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). 
If the character ch does not exist in word, do nothing.

For example, if word = "abcdefd" and ch = "d", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be "dcbaefd".
Return the resulting string.

 

Example 1:

Input: word = "abcdefd", ch = "d"
Output: "dcbaefd"
Explanation: The first occurrence of "d" is at index 3. 
Reverse the part of word from 0 to 3 (inclusive), the resulting string is "dcbaefd".
Example 2:

Input: word = "xyxzxe", ch = "z"
Output: "zxyxxe"
Explanation: The first and only occurrence of "z" is at index 3.
Reverse the part of word from 0 to 3 (inclusive), the resulting string is "zxyxxe".
Example 3:

Input: word = "abcd", ch = "z"
Output: "abcd"
Explanation: "z" does not exist in word.
You should not do any reverse operation, the resulting string is "abcd".
 

Constraints:

1 <= word.length <= 250
word consists of lowercase English letters.
ch is a lowercase English letter.

class Solution
{
public:
    string reversePrefix(string word, char ch)
    {
        int index = word.find(ch);
        if(index != string::npos) reverse(word.begin(), word.begin() + index + 1);
        return word;
    }
};
